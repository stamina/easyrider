   1               		.file	"easyrider.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.check_battery_read,"ax",@progbits
  13               	check_battery_read:
  14               	.LFB7:
  15               		.file 1 "easyrider.c"
   1:easyrider.c   **** /*
   2:easyrider.c   ****  *
   3:easyrider.c   ****  *  Copyright (C) 2013 Bas Brugman
   4:easyrider.c   ****  *  http://www.visionnaire.nl
   5:easyrider.c   ****  *
   6:easyrider.c   ****  *  Licensed under the Apache License, Version 2.0 (the "License");
   7:easyrider.c   ****  *  you may not use this file except in compliance with the License.
   8:easyrider.c   ****  *  You may obtain a copy of the License at
   9:easyrider.c   ****  *
  10:easyrider.c   ****  *    http://www.apache.org/licenses/LICENSE-2.0
  11:easyrider.c   ****  *
  12:easyrider.c   ****  *  Unless required by applicable law or agreed to in writing, software
  13:easyrider.c   ****  *  distributed under the License is distributed on an "AS IS" BASIS,
  14:easyrider.c   ****  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15:easyrider.c   ****  *  See the License for the specific language governing permissions and
  16:easyrider.c   ****  *  limitations under the License.
  17:easyrider.c   ****  *
  18:easyrider.c   ****  */
  19:easyrider.c   **** #include <avr/io.h>
  20:easyrider.c   **** #include <avr/interrupt.h>
  21:easyrider.c   **** #include <avr/pgmspace.h>
  22:easyrider.c   **** #include <avr/eeprom.h>
  23:easyrider.c   **** #include <avr/wdt.h>
  24:easyrider.c   **** #include <avr/sleep.h>
  25:easyrider.c   **** #include <avr/power.h>
  26:easyrider.c   **** #include <stdlib.h>
  27:easyrider.c   **** #include <stdint.h>
  28:easyrider.c   **** #include <string.h>
  29:easyrider.c   **** 
  30:easyrider.c   **** #include "command.h"
  31:easyrider.c   **** #include "usart.h"
  32:easyrider.c   **** #include "command_usart.h"
  33:easyrider.c   **** #include "command_handlers.h"
  34:easyrider.c   **** #include "easyrider.h"
  35:easyrider.c   **** 
  36:easyrider.c   **** #include "sound/alarm.h"
  37:easyrider.c   **** #include "sound/frogger.h"
  38:easyrider.c   **** #include "sound/furelise.h"
  39:easyrider.c   **** #include "sound/larry.h"
  40:easyrider.c   **** #include "sound/pipi.h"
  41:easyrider.c   **** #include "sound/popcorn.h"
  42:easyrider.c   **** 
  43:easyrider.c   **** // state transition struct array: handler assigment for state/event combo's
  44:easyrider.c   **** tTransition g_trans[] = {
  45:easyrider.c   ****   {check_claxon_on, EV_CLAXON_ON, process_claxon_on},
  46:easyrider.c   ****   {check_claxon_off, EV_CLAXON_OFF, process_claxon_off},
  47:easyrider.c   ****   {check_ri_on, EV_RI_ON, process_ri_on},
  48:easyrider.c   ****   {check_ri_off, EV_RI_OFF, process_ri_off},
  49:easyrider.c   ****   {check_li_on, EV_LI_ON, process_li_on},
  50:easyrider.c   ****   {check_li_off, EV_LI_OFF, process_li_off},
  51:easyrider.c   ****   {check_ign_on, EV_IGN_ON, process_ign_on},
  52:easyrider.c   ****   {check_ign_off, EV_IGN_OFF, process_ign_off},
  53:easyrider.c   ****   {check_alarm_on, EV_ALARM_ON, process_alarm_on},
  54:easyrider.c   ****   {check_alarm_off, EV_ALARM_OFF, process_alarm_off},
  55:easyrider.c   ****   {check_brake_on, EV_BRAKE_ON, process_brake_on},
  56:easyrider.c   ****   {check_brake_off, EV_BRAKE_OFF, process_brake_off},
  57:easyrider.c   ****   {check_pilot_on, EV_PILOT_ON, process_pilot_on},
  58:easyrider.c   ****   {check_pilot_off, EV_PILOT_OFF, process_pilot_off},
  59:easyrider.c   ****   {check_light_on, EV_LIGHT_ON, process_light_on},
  60:easyrider.c   ****   {check_light_off, EV_LIGHT_OFF, process_light_off},
  61:easyrider.c   ****   {check_battery_read, EV_READ_BATT, process_battery},
  62:easyrider.c   ****   {check_warning_on, EV_WARNING_ON, process_warning_on},
  63:easyrider.c   ****   {check_warning_off, EV_WARNING_OFF, process_warning_off},
  64:easyrider.c   ****   {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
  65:easyrider.c   **** };
  66:easyrider.c   **** 
  67:easyrider.c   **** static uint16_t get_substate(uint16_t st) {
  68:easyrider.c   ****   return (g_state & st);
  69:easyrider.c   **** }
  70:easyrider.c   **** 
  71:easyrider.c   **** static void set_substate(uint16_t st) {
  72:easyrider.c   ****   g_state |= st;
  73:easyrider.c   **** }
  74:easyrider.c   **** 
  75:easyrider.c   **** static void remove_substate(uint16_t st) {
  76:easyrider.c   ****   g_state &= ~st;
  77:easyrider.c   **** }
  78:easyrider.c   **** 
  79:easyrider.c   **** // Gets called from the main loop, reads all senses and puts them in the event queue.
  80:easyrider.c   **** // The complete queue is handled (emptied) in each main loop iteration in a FIFO way, so better
  81:easyrider.c   **** // put the higher priority events at the top, i.e. claxon sound is more important then indicator li
  82:easyrider.c   **** static void dispatch_events() {
  83:easyrider.c   ****   check_brake();
  84:easyrider.c   ****   check_claxon();
  85:easyrider.c   ****   check_ri();
  86:easyrider.c   ****   check_li();
  87:easyrider.c   ****   check_light();
  88:easyrider.c   ****   check_pilot();
  89:easyrider.c   ****   check_ign();
  90:easyrider.c   ****   check_settle();
  91:easyrider.c   ****   check_sound();
  92:easyrider.c   ****   check_alarm();
  93:easyrider.c   ****   check_alarm_settle();
  94:easyrider.c   ****   check_alarm_trigger();
  95:easyrider.c   ****   check_battery();
  96:easyrider.c   ****   check_warning();
  97:easyrider.c   ****   check_sleep();
  98:easyrider.c   ****   if (g_settings.backpedal) {
  99:easyrider.c   ****     check_backpedal();
 100:easyrider.c   ****   }
 101:easyrider.c   **** }
 102:easyrider.c   **** 
 103:easyrider.c   **** uint8_t check_battery_read() {
  16               		.loc 1 103 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 104:easyrider.c   ****   return ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state);
  22               		.loc 1 104 0
  23 0000 2091 0000 		lds r18,g_state
  24 0004 3091 0000 		lds r19,g_state+1
  25 0008 4091 0000 		lds r20,g_state
  26 000c 5091 0000 		lds r21,g_state+1
  27 0010 2F7B      		andi r18,191
  28 0012 387F      		andi r19,248
  29 0014 81E0      		ldi r24,lo8(1)
  30 0016 2417      		cp r18,r20
  31 0018 3507      		cpc r19,r21
  32 001a 01F0      		breq .L2
  33 001c 80E0      		ldi r24,0
  34               	.L2:
 105:easyrider.c   **** }
  35               		.loc 1 105 0
  36 001e 0895      		ret
  37               		.cfi_endproc
  38               	.LFE7:
  40               		.section	.text.check_ri_on,"ax",@progbits
  42               	check_ri_on:
  43               	.LFB8:
 106:easyrider.c   **** 
 107:easyrider.c   **** uint8_t check_ri_on() {
  44               		.loc 1 107 0
  45               		.cfi_startproc
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 0 */
  49               	.L__stack_usage = 0
 108:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state)
  50               		.loc 1 108 0
  51 0000 8091 0000 		lds r24,g_state
  52 0004 9091 0000 		lds r25,g_state+1
  53 0008 2091 0000 		lds r18,g_state
  54 000c 3091 0000 		lds r19,g_state+1
  55 0010 8B7B      		andi r24,187
  56 0012 9927      		clr r25
  57 0014 8217      		cp r24,r18
  58 0016 9307      		cpc r25,r19
  59 0018 01F0      		breq .L8
  60 001a 80E0      		ldi r24,0
  61               	.L5:
 109:easyrider.c   ****         ((g_state & ~(ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g
 110:easyrider.c   **** }
  62               		.loc 1 110 0 discriminator 4
  63 001c 0895      		ret
  64               	.L8:
 109:easyrider.c   ****         ((g_state & ~(ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g
  65               		.loc 1 109 0 discriminator 1
  66 001e 2091 0000 		lds r18,g_state
  67 0022 3091 0000 		lds r19,g_state+1
  68 0026 4091 0000 		lds r20,g_state
  69 002a 5091 0000 		lds r21,g_state+1
  70 002e 2B7B      		andi r18,187
  71 0030 307F      		andi r19,240
 108:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state)
  72               		.loc 1 108 0 discriminator 1
  73 0032 81E0      		ldi r24,lo8(1)
  74 0034 2417      		cp r18,r20
  75 0036 3507      		cpc r19,r21
  76 0038 01F0      		breq .L5
  77 003a 80E0      		ldi r24,0
  78 003c 00C0      		rjmp .L5
  79               		.cfi_endproc
  80               	.LFE8:
  82               		.section	.text.check_li_on,"ax",@progbits
  84               	check_li_on:
  85               	.LFB9:
 111:easyrider.c   **** 
 112:easyrider.c   **** uint8_t check_li_on() {
  86               		.loc 1 112 0
  87               		.cfi_startproc
  88               	/* prologue: function */
  89               	/* frame size = 0 */
  90               	/* stack size = 0 */
  91               	.L__stack_usage = 0
 113:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_LI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state)
  92               		.loc 1 113 0
  93 0000 8091 0000 		lds r24,g_state
  94 0004 9091 0000 		lds r25,g_state+1
  95 0008 2091 0000 		lds r18,g_state
  96 000c 3091 0000 		lds r19,g_state+1
  97 0010 8D7B      		andi r24,189
  98 0012 9927      		clr r25
  99 0014 8217      		cp r24,r18
 100 0016 9307      		cpc r25,r19
 101 0018 01F0      		breq .L13
 102 001a 80E0      		ldi r24,0
 103               	.L10:
 114:easyrider.c   ****         ((g_state & ~(ST_RI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g
 115:easyrider.c   **** }
 104               		.loc 1 115 0 discriminator 4
 105 001c 0895      		ret
 106               	.L13:
 114:easyrider.c   ****         ((g_state & ~(ST_RI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g
 107               		.loc 1 114 0 discriminator 1
 108 001e 2091 0000 		lds r18,g_state
 109 0022 3091 0000 		lds r19,g_state+1
 110 0026 4091 0000 		lds r20,g_state
 111 002a 5091 0000 		lds r21,g_state+1
 112 002e 2D7B      		andi r18,189
 113 0030 307F      		andi r19,240
 113:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_LI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state)
 114               		.loc 1 113 0 discriminator 1
 115 0032 81E0      		ldi r24,lo8(1)
 116 0034 2417      		cp r18,r20
 117 0036 3507      		cpc r19,r21
 118 0038 01F0      		breq .L10
 119 003a 80E0      		ldi r24,0
 120 003c 00C0      		rjmp .L10
 121               		.cfi_endproc
 122               	.LFE9:
 124               		.section	.text.check_brake_on,"ax",@progbits
 126               	check_brake_on:
 127               	.LFB10:
 116:easyrider.c   **** 
 117:easyrider.c   **** uint8_t check_brake_on() {
 128               		.loc 1 117 0
 129               		.cfi_startproc
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 0 */
 133               	.L__stack_usage = 0
 118:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_WARNING)) =
 134               		.loc 1 118 0
 135 0000 8091 0000 		lds r24,g_state
 136 0004 9091 0000 		lds r25,g_state+1
 137 0008 2091 0000 		lds r18,g_state
 138 000c 3091 0000 		lds r19,g_state+1
 139 0010 8F7A      		andi r24,175
 140 0012 9870      		andi r25,8
 141 0014 8217      		cp r24,r18
 142 0016 9307      		cpc r25,r19
 143 0018 01F0      		breq .L18
 144 001a 80E0      		ldi r24,0
 145               	.L15:
 119:easyrider.c   ****         ((g_state & ~(ST_BRAKE | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 120:easyrider.c   **** }
 146               		.loc 1 120 0 discriminator 4
 147 001c 0895      		ret
 148               	.L18:
 119:easyrider.c   ****         ((g_state & ~(ST_BRAKE | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 149               		.loc 1 119 0 discriminator 1
 150 001e 2091 0000 		lds r18,g_state
 151 0022 3091 0000 		lds r19,g_state+1
 152 0026 4091 0000 		lds r20,g_state
 153 002a 5091 0000 		lds r21,g_state+1
 154 002e 2F7A      		andi r18,175
 155 0030 387F      		andi r19,248
 118:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_WARNING)) =
 156               		.loc 1 118 0 discriminator 1
 157 0032 81E0      		ldi r24,lo8(1)
 158 0034 2417      		cp r18,r20
 159 0036 3507      		cpc r19,r21
 160 0038 01F0      		breq .L15
 161 003a 80E0      		ldi r24,0
 162 003c 00C0      		rjmp .L15
 163               		.cfi_endproc
 164               	.LFE10:
 166               		.section	.text.check_warning_on,"ax",@progbits
 168               	check_warning_on:
 169               	.LFB11:
 121:easyrider.c   **** 
 122:easyrider.c   **** uint8_t check_warning_on() {
 170               		.loc 1 122 0
 171               		.cfi_startproc
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
 123:easyrider.c   ****   // warning blinks override RI/LI
 124:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_WARNING | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | S
 176               		.loc 1 124 0
 177 0000 8091 0000 		lds r24,g_state
 178 0004 9091 0000 		lds r25,g_state+1
 179 0008 2091 0000 		lds r18,g_state
 180 000c 3091 0000 		lds r19,g_state+1
 181 0010 8F7B      		andi r24,191
 182 0012 9870      		andi r25,8
 183 0014 8217      		cp r24,r18
 184 0016 9307      		cpc r25,r19
 185 0018 01F0      		breq .L23
 186 001a 80E0      		ldi r24,0
 187               	.L20:
 125:easyrider.c   ****         ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 126:easyrider.c   **** }
 188               		.loc 1 126 0 discriminator 4
 189 001c 0895      		ret
 190               	.L23:
 125:easyrider.c   ****         ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 191               		.loc 1 125 0 discriminator 1
 192 001e 2091 0000 		lds r18,g_state
 193 0022 3091 0000 		lds r19,g_state+1
 194 0026 4091 0000 		lds r20,g_state
 195 002a 5091 0000 		lds r21,g_state+1
 196 002e 2F7B      		andi r18,191
 197 0030 387F      		andi r19,248
 124:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_WARNING | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | S
 198               		.loc 1 124 0 discriminator 1
 199 0032 81E0      		ldi r24,lo8(1)
 200 0034 2417      		cp r18,r20
 201 0036 3507      		cpc r19,r21
 202 0038 01F0      		breq .L20
 203 003a 80E0      		ldi r24,0
 204 003c 00C0      		rjmp .L20
 205               		.cfi_endproc
 206               	.LFE11:
 208               		.section	.text.check_pilot_on,"ax",@progbits
 210               	check_pilot_on:
 211               	.LFB12:
 127:easyrider.c   **** 
 128:easyrider.c   **** uint8_t check_pilot_on() {
 212               		.loc 1 128 0
 213               		.cfi_startproc
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 216               	/* stack size = 0 */
 217               	.L__stack_usage = 0
 129:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_BRAKE | ST_WARNING)) =
 218               		.loc 1 129 0
 219 0000 8091 0000 		lds r24,g_state
 220 0004 9091 0000 		lds r25,g_state+1
 221 0008 2091 0000 		lds r18,g_state
 222 000c 3091 0000 		lds r19,g_state+1
 223 0010 8F73      		andi r24,63
 224 0012 9870      		andi r25,8
 225 0014 8217      		cp r24,r18
 226 0016 9307      		cpc r25,r19
 227 0018 01F0      		breq .L28
 228 001a 80E0      		ldi r24,0
 229               	.L25:
 130:easyrider.c   ****         ((g_state & ~(ST_PILOT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 131:easyrider.c   **** }
 230               		.loc 1 131 0 discriminator 4
 231 001c 0895      		ret
 232               	.L28:
 130:easyrider.c   ****         ((g_state & ~(ST_PILOT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 233               		.loc 1 130 0 discriminator 1
 234 001e 2091 0000 		lds r18,g_state
 235 0022 3091 0000 		lds r19,g_state+1
 236 0026 4091 0000 		lds r20,g_state
 237 002a 5091 0000 		lds r21,g_state+1
 238 002e 2F73      		andi r18,63
 239 0030 387F      		andi r19,248
 129:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_BRAKE | ST_WARNING)) =
 240               		.loc 1 129 0 discriminator 1
 241 0032 81E0      		ldi r24,lo8(1)
 242 0034 2417      		cp r18,r20
 243 0036 3507      		cpc r19,r21
 244 0038 01F0      		breq .L25
 245 003a 80E0      		ldi r24,0
 246 003c 00C0      		rjmp .L25
 247               		.cfi_endproc
 248               	.LFE12:
 250               		.section	.text.check_light_on,"ax",@progbits
 252               	check_light_on:
 253               	.LFB13:
 132:easyrider.c   **** 
 133:easyrider.c   **** uint8_t check_light_on() {
 254               		.loc 1 133 0
 255               		.cfi_startproc
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 134:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) =
 260               		.loc 1 134 0
 261 0000 8091 0000 		lds r24,g_state
 262 0004 9091 0000 		lds r25,g_state+1
 263 0008 2091 0000 		lds r18,g_state
 264 000c 3091 0000 		lds r19,g_state+1
 265 0010 8F79      		andi r24,159
 266 0012 9870      		andi r25,8
 267 0014 8217      		cp r24,r18
 268 0016 9307      		cpc r25,r19
 269 0018 01F0      		breq .L33
 270 001a 80E0      		ldi r24,0
 271               	.L30:
 135:easyrider.c   ****         ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 136:easyrider.c   **** }
 272               		.loc 1 136 0 discriminator 4
 273 001c 0895      		ret
 274               	.L33:
 135:easyrider.c   ****         ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 275               		.loc 1 135 0 discriminator 1
 276 001e 2091 0000 		lds r18,g_state
 277 0022 3091 0000 		lds r19,g_state+1
 278 0026 4091 0000 		lds r20,g_state
 279 002a 5091 0000 		lds r21,g_state+1
 280 002e 2F79      		andi r18,159
 281 0030 387F      		andi r19,248
 134:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) =
 282               		.loc 1 134 0 discriminator 1
 283 0032 81E0      		ldi r24,lo8(1)
 284 0034 2417      		cp r18,r20
 285 0036 3507      		cpc r19,r21
 286 0038 01F0      		breq .L30
 287 003a 80E0      		ldi r24,0
 288 003c 00C0      		rjmp .L30
 289               		.cfi_endproc
 290               	.LFE13:
 292               		.section	.text.check_backpedal_on,"ax",@progbits
 294               	check_backpedal_on:
 295               	.LFB14:
 137:easyrider.c   **** 
 138:easyrider.c   **** uint8_t check_backpedal_on() {
 296               		.loc 1 138 0
 297               		.cfi_startproc
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 0 */
 301               	.L__stack_usage = 0
 139:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
 302               		.loc 1 139 0
 303 0000 8091 0000 		lds r24,g_state
 304 0004 9091 0000 		lds r25,g_state+1
 305 0008 2091 0000 		lds r18,g_state
 306 000c 3091 0000 		lds r19,g_state+1
 307 0010 897B      		andi r24,185
 308 0012 9927      		clr r25
 309 0014 8217      		cp r24,r18
 310 0016 9307      		cpc r25,r19
 311 0018 01F0      		breq .L38
 312 001a 80E0      		ldi r24,0
 313               	.L35:
 140:easyrider.c   ****         ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEE
 141:easyrider.c   **** }
 314               		.loc 1 141 0 discriminator 4
 315 001c 0895      		ret
 316               	.L38:
 140:easyrider.c   ****         ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEE
 317               		.loc 1 140 0 discriminator 1
 318 001e 2091 0000 		lds r18,g_state
 319 0022 3091 0000 		lds r19,g_state+1
 320 0026 4091 0000 		lds r20,g_state
 321 002a 5091 0000 		lds r21,g_state+1
 322 002e 297B      		andi r18,185
 323 0030 307F      		andi r19,240
 139:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
 324               		.loc 1 139 0 discriminator 1
 325 0032 81E0      		ldi r24,lo8(1)
 326 0034 2417      		cp r18,r20
 327 0036 3507      		cpc r19,r21
 328 0038 01F0      		breq .L35
 329 003a 80E0      		ldi r24,0
 330 003c 00C0      		rjmp .L35
 331               		.cfi_endproc
 332               	.LFE14:
 334               		.section	.text.check_claxon_on,"ax",@progbits
 336               	check_claxon_on:
 337               	.LFB15:
 142:easyrider.c   **** 
 143:easyrider.c   **** uint8_t check_claxon_on() {
 338               		.loc 1 143 0
 339               		.cfi_startproc
 340               	/* prologue: function */
 341               	/* frame size = 0 */
 342               	/* stack size = 0 */
 343               	.L__stack_usage = 0
 144:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_BRAKE | ST_LIGHT | ST_PILOT | ST_WARNING)) ==
 344               		.loc 1 144 0
 345 0000 8091 0000 		lds r24,g_state
 346 0004 9091 0000 		lds r25,g_state+1
 347 0008 2091 0000 		lds r18,g_state
 348 000c 3091 0000 		lds r19,g_state+1
 349 0010 877B      		andi r24,183
 350 0012 9870      		andi r25,8
 351 0014 8217      		cp r24,r18
 352 0016 9307      		cpc r25,r19
 353 0018 01F0      		breq .L43
 354 001a 80E0      		ldi r24,0
 355               	.L40:
 145:easyrider.c   ****         ((g_state & ~(ST_CLAXON | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 146:easyrider.c   **** }
 356               		.loc 1 146 0 discriminator 4
 357 001c 0895      		ret
 358               	.L43:
 145:easyrider.c   ****         ((g_state & ~(ST_CLAXON | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
 359               		.loc 1 145 0 discriminator 1
 360 001e 2091 0000 		lds r18,g_state
 361 0022 3091 0000 		lds r19,g_state+1
 362 0026 4091 0000 		lds r20,g_state
 363 002a 5091 0000 		lds r21,g_state+1
 364 002e 277B      		andi r18,183
 365 0030 387F      		andi r19,248
 144:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_BRAKE | ST_LIGHT | ST_PILOT | ST_WARNING)) ==
 366               		.loc 1 144 0 discriminator 1
 367 0032 81E0      		ldi r24,lo8(1)
 368 0034 2417      		cp r18,r20
 369 0036 3507      		cpc r19,r21
 370 0038 01F0      		breq .L40
 371 003a 80E0      		ldi r24,0
 372 003c 00C0      		rjmp .L40
 373               		.cfi_endproc
 374               	.LFE15:
 376               		.section	.text.check_ign_on,"ax",@progbits
 378               	check_ign_on:
 379               	.LFB16:
 147:easyrider.c   **** 
 148:easyrider.c   **** uint8_t check_ign_on() {
 380               		.loc 1 148 0
 381               		.cfi_startproc
 382               	/* prologue: function */
 383               	/* frame size = 0 */
 384               	/* stack size = 0 */
 385               	.L__stack_usage = 0
 149:easyrider.c   ****   return ((g_state & (ST_SLEEP | ST_ALARM_SETTLE | ST_ALARM)) == g_state);
 386               		.loc 1 149 0
 387 0000 2091 0000 		lds r18,g_state
 388 0004 3091 0000 		lds r19,g_state+1
 389 0008 4091 0000 		lds r20,g_state
 390 000c 5091 0000 		lds r21,g_state+1
 391 0010 2074      		andi r18,64
 392 0012 3370      		andi r19,3
 393 0014 81E0      		ldi r24,lo8(1)
 394 0016 2417      		cp r18,r20
 395 0018 3507      		cpc r19,r21
 396 001a 01F0      		breq .L45
 397 001c 80E0      		ldi r24,0
 398               	.L45:
 150:easyrider.c   **** }
 399               		.loc 1 150 0
 400 001e 0895      		ret
 401               		.cfi_endproc
 402               	.LFE16:
 404               		.section	.text.check_alarm_on,"ax",@progbits
 406               	check_alarm_on:
 407               	.LFB17:
 151:easyrider.c   **** 
 152:easyrider.c   **** uint8_t check_alarm_on() {
 408               		.loc 1 152 0
 409               		.cfi_startproc
 410               	/* prologue: function */
 411               	/* frame size = 0 */
 412               	/* stack size = 0 */
 413               	.L__stack_usage = 0
 153:easyrider.c   ****   //BUG: change this..
 154:easyrider.c   ****   return ((g_state & ST_SLEEP) == g_state);
 414               		.loc 1 154 0
 415 0000 2091 0000 		lds r18,g_state
 416 0004 3091 0000 		lds r19,g_state+1
 417 0008 4091 0000 		lds r20,g_state
 418 000c 5091 0000 		lds r21,g_state+1
 419 0010 2227      		clr r18
 420 0012 3270      		andi r19,2
 421 0014 81E0      		ldi r24,lo8(1)
 422 0016 2417      		cp r18,r20
 423 0018 3507      		cpc r19,r21
 424 001a 01F0      		breq .L47
 425 001c 80E0      		ldi r24,0
 426               	.L47:
 155:easyrider.c   **** }
 427               		.loc 1 155 0
 428 001e 0895      		ret
 429               		.cfi_endproc
 430               	.LFE17:
 432               		.section	.text.check_ri_off,"ax",@progbits
 434               	check_ri_off:
 435               	.LFB18:
 156:easyrider.c   **** 
 157:easyrider.c   **** uint8_t check_ri_off() {
 436               		.loc 1 157 0
 437               		.cfi_startproc
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440               	/* stack size = 0 */
 441               	.L__stack_usage = 0
 158:easyrider.c   ****  return ((ST_RI & g_state) == ST_RI);
 442               		.loc 1 158 0
 443 0000 8091 0000 		lds r24,g_state
 444 0004 9091 0000 		lds r25,g_state+1
 445 0008 9695      		lsr r25
 446 000a 8795      		ror r24
 159:easyrider.c   **** }
 447               		.loc 1 159 0
 448 000c 8170      		andi r24,lo8(1)
 449 000e 0895      		ret
 450               		.cfi_endproc
 451               	.LFE18:
 453               		.section	.text.check_li_off,"ax",@progbits
 455               	check_li_off:
 456               	.LFB19:
 160:easyrider.c   **** 
 161:easyrider.c   **** uint8_t check_li_off() {
 457               		.loc 1 161 0
 458               		.cfi_startproc
 459               	/* prologue: function */
 460               	/* frame size = 0 */
 461               	/* stack size = 0 */
 462               	.L__stack_usage = 0
 162:easyrider.c   ****  return ((ST_LI & g_state) == ST_LI);
 463               		.loc 1 162 0
 464 0000 8091 0000 		lds r24,g_state
 465 0004 9091 0000 		lds r25,g_state+1
 466 0008 9695      		lsr r25
 467 000a 8795      		ror r24
 468 000c 9695      		lsr r25
 469 000e 8795      		ror r24
 163:easyrider.c   **** }
 470               		.loc 1 163 0
 471 0010 8170      		andi r24,lo8(1)
 472 0012 0895      		ret
 473               		.cfi_endproc
 474               	.LFE19:
 476               		.section	.text.check_claxon_off,"ax",@progbits
 478               	check_claxon_off:
 479               	.LFB20:
 164:easyrider.c   **** 
 165:easyrider.c   **** uint8_t check_claxon_off() {
 480               		.loc 1 165 0
 481               		.cfi_startproc
 482               	/* prologue: function */
 483               	/* frame size = 0 */
 484               	/* stack size = 0 */
 485               	.L__stack_usage = 0
 166:easyrider.c   ****  return ((ST_CLAXON & g_state) == ST_CLAXON);
 486               		.loc 1 166 0
 487 0000 8091 0000 		lds r24,g_state
 488 0004 9091 0000 		lds r25,g_state+1
 489 0008 9695      		lsr r25
 490 000a 8795      		ror r24
 491 000c 9695      		lsr r25
 492 000e 8795      		ror r24
 493 0010 9695      		lsr r25
 494 0012 8795      		ror r24
 167:easyrider.c   **** }
 495               		.loc 1 167 0
 496 0014 8170      		andi r24,lo8(1)
 497 0016 0895      		ret
 498               		.cfi_endproc
 499               	.LFE20:
 501               		.section	.text.check_pilot_off,"ax",@progbits
 503               	check_pilot_off:
 504               	.LFB21:
 168:easyrider.c   **** 
 169:easyrider.c   **** uint8_t check_pilot_off() {
 505               		.loc 1 169 0
 506               		.cfi_startproc
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509               	/* stack size = 0 */
 510               	.L__stack_usage = 0
 170:easyrider.c   ****  return ((ST_PILOT & g_state) == ST_PILOT);
 511               		.loc 1 170 0
 512 0000 8091 0000 		lds r24,g_state
 513 0004 9091 0000 		lds r25,g_state+1
 514 0008 880F      		lsl r24
 515 000a 892F      		mov r24,r25
 516 000c 881F      		rol r24
 517 000e 990B      		sbc r25,r25
 518 0010 9195      		neg r25
 171:easyrider.c   **** }
 519               		.loc 1 171 0
 520 0012 8170      		andi r24,lo8(1)
 521 0014 0895      		ret
 522               		.cfi_endproc
 523               	.LFE21:
 525               		.section	.text.check_brake_off,"ax",@progbits
 527               	check_brake_off:
 528               	.LFB22:
 172:easyrider.c   **** 
 173:easyrider.c   **** uint8_t check_brake_off() {
 529               		.loc 1 173 0
 530               		.cfi_startproc
 531               	/* prologue: function */
 532               	/* frame size = 0 */
 533               	/* stack size = 0 */
 534               	.L__stack_usage = 0
 174:easyrider.c   ****  return ((ST_BRAKE & g_state) == ST_BRAKE);
 535               		.loc 1 174 0
 536 0000 8091 0000 		lds r24,g_state
 537 0004 9091 0000 		lds r25,g_state+1
 538 0008 9295      		swap r25
 539 000a 8295      		swap r24
 540 000c 8F70      		andi r24,0x0f
 541 000e 8927      		eor r24,r25
 542 0010 9F70      		andi r25,0x0f
 543 0012 8927      		eor r24,r25
 175:easyrider.c   **** }
 544               		.loc 1 175 0
 545 0014 8170      		andi r24,lo8(1)
 546 0016 0895      		ret
 547               		.cfi_endproc
 548               	.LFE22:
 550               		.section	.text.check_warning_off,"ax",@progbits
 552               	check_warning_off:
 553               	.LFB23:
 176:easyrider.c   **** 
 177:easyrider.c   **** uint8_t check_warning_off() {
 554               		.loc 1 177 0
 555               		.cfi_startproc
 556               	/* prologue: function */
 557               	/* frame size = 0 */
 558               	/* stack size = 0 */
 559               	.L__stack_usage = 0
 178:easyrider.c   ****  return ((ST_WARNING & g_state) == ST_WARNING);
 560               		.loc 1 178 0
 561 0000 8091 0000 		lds r24,g_state
 562 0004 9091 0000 		lds r25,g_state+1
 179:easyrider.c   **** }
 563               		.loc 1 179 0
 564 0008 93FB      		bst r25,3
 565 000a 8827      		clr r24
 566 000c 80F9      		bld r24,0
 567 000e 0895      		ret
 568               		.cfi_endproc
 569               	.LFE23:
 571               		.section	.text.check_light_off,"ax",@progbits
 573               	check_light_off:
 574               	.LFB24:
 180:easyrider.c   **** 
 181:easyrider.c   **** uint8_t check_light_off() {
 575               		.loc 1 181 0
 576               		.cfi_startproc
 577               	/* prologue: function */
 578               	/* frame size = 0 */
 579               	/* stack size = 0 */
 580               	.L__stack_usage = 0
 182:easyrider.c   ****  return ((ST_LIGHT & g_state) == ST_LIGHT);
 581               		.loc 1 182 0
 582 0000 8091 0000 		lds r24,g_state
 583 0004 9091 0000 		lds r25,g_state+1
 584 0008 9695      		lsr r25
 585 000a 8795      		ror r24
 586 000c 9295      		swap r25
 587 000e 8295      		swap r24
 588 0010 8F70      		andi r24,0x0f
 589 0012 8927      		eor r24,r25
 590 0014 9F70      		andi r25,0x0f
 591 0016 8927      		eor r24,r25
 183:easyrider.c   **** }
 592               		.loc 1 183 0
 593 0018 8170      		andi r24,lo8(1)
 594 001a 0895      		ret
 595               		.cfi_endproc
 596               	.LFE24:
 598               		.section	.text.check_ign_off,"ax",@progbits
 600               	check_ign_off:
 601               	.LFB25:
 184:easyrider.c   **** 
 185:easyrider.c   **** uint8_t check_ign_off() {
 602               		.loc 1 185 0
 603               		.cfi_startproc
 604               	/* prologue: function */
 605               	/* frame size = 0 */
 606               	/* stack size = 0 */
 607               	.L__stack_usage = 0
 186:easyrider.c   ****   return ((g_state & ~(ST_SLEEP | ST_ALARM | ST_ALARM_SETTLE)) == g_state);
 608               		.loc 1 186 0
 609 0000 2091 0000 		lds r18,g_state
 610 0004 3091 0000 		lds r19,g_state+1
 611 0008 4091 0000 		lds r20,g_state
 612 000c 5091 0000 		lds r21,g_state+1
 613 0010 2F7B      		andi r18,191
 614 0012 3C7F      		andi r19,252
 615 0014 81E0      		ldi r24,lo8(1)
 616 0016 2417      		cp r18,r20
 617 0018 3507      		cpc r19,r21
 618 001a 01F0      		breq .L56
 619 001c 80E0      		ldi r24,0
 620               	.L56:
 187:easyrider.c   **** }
 621               		.loc 1 187 0
 622 001e 0895      		ret
 623               		.cfi_endproc
 624               	.LFE25:
 626               		.section	.text.check_alarm_off,"ax",@progbits
 628               	check_alarm_off:
 629               	.LFB26:
 188:easyrider.c   **** 
 189:easyrider.c   **** uint8_t check_alarm_off() {
 630               		.loc 1 189 0
 631               		.cfi_startproc
 632               	/* prologue: function */
 633               	/* frame size = 0 */
 634               	/* stack size = 0 */
 635               	.L__stack_usage = 0
 190:easyrider.c   ****   // alarm can't be switched off in alarm state, only explicitly in alarm_settle mode
 191:easyrider.c   ****   // or automatically when ignition is switched on
 192:easyrider.c   ****   return ((g_state & (ST_ALARM_SETTLE)) == g_state);
 636               		.loc 1 192 0
 637 0000 2091 0000 		lds r18,g_state
 638 0004 3091 0000 		lds r19,g_state+1
 639 0008 4091 0000 		lds r20,g_state
 640 000c 5091 0000 		lds r21,g_state+1
 641 0010 2227      		clr r18
 642 0012 3170      		andi r19,1
 643 0014 81E0      		ldi r24,lo8(1)
 644 0016 2417      		cp r18,r20
 645 0018 3507      		cpc r19,r21
 646 001a 01F0      		breq .L58
 647 001c 80E0      		ldi r24,0
 648               	.L58:
 193:easyrider.c   **** }
 649               		.loc 1 193 0
 650 001e 0895      		ret
 651               		.cfi_endproc
 652               	.LFE26:
 654               		.section	.text.reset_ports,"ax",@progbits
 656               	reset_ports:
 657               	.LFB65:
 194:easyrider.c   **** 
 195:easyrider.c   **** void check_ri() {
 196:easyrider.c   ****   // pin senses
 197:easyrider.c   ****   if ((g_senses & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) {
 198:easyrider.c   ****     if (~STATUS_C90_SENSE_LIGHT_RI) { // low, RI on
 199:easyrider.c   ****       set_event(EV_RI_ON);
 200:easyrider.c   ****     }
 201:easyrider.c   ****     if (STATUS_C90_SENSE_LIGHT_RI) { // RI off
 202:easyrider.c   ****       set_event(EV_RI_OFF);
 203:easyrider.c   ****     }
 204:easyrider.c   ****   }
 205:easyrider.c   ****   // dynamic senses
 206:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) {
 207:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) { // high, RI off
 208:easyrider.c   ****       set_event(EV_RI_OFF);
 209:easyrider.c   ****     } else {
 210:easyrider.c   ****       set_event(EV_RI_ON); // RI on
 211:easyrider.c   ****     }
 212:easyrider.c   ****   }
 213:easyrider.c   **** }
 214:easyrider.c   **** 
 215:easyrider.c   **** void check_li() {
 216:easyrider.c   ****   // pin senses
 217:easyrider.c   ****   if ((g_senses & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) {
 218:easyrider.c   ****     if (~STATUS_C90_SENSE_LIGHT_LI) { // low, LI on
 219:easyrider.c   ****       set_event(EV_LI_ON);
 220:easyrider.c   ****     }
 221:easyrider.c   ****     if (STATUS_C90_SENSE_LIGHT_LI) { // LI off
 222:easyrider.c   ****       set_event(EV_LI_OFF);
 223:easyrider.c   ****     }
 224:easyrider.c   ****   }
 225:easyrider.c   ****   // dynamic senses
 226:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) {
 227:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) { // high, LI off
 228:easyrider.c   ****       set_event(EV_LI_OFF);
 229:easyrider.c   ****     } else {
 230:easyrider.c   ****       set_event(EV_LI_ON); // LI on
 231:easyrider.c   ****     }
 232:easyrider.c   ****   }
 233:easyrider.c   **** }
 234:easyrider.c   **** 
 235:easyrider.c   **** void check_claxon() {
 236:easyrider.c   ****   // pin senses
 237:easyrider.c   ****   if ((g_senses & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
 238:easyrider.c   ****     if (~STATUS_C90_SENSE_CLAXON) {
 239:easyrider.c   ****       set_event(EV_CLAXON_ON);
 240:easyrider.c   ****     }
 241:easyrider.c   ****     if (STATUS_C90_SENSE_CLAXON) {
 242:easyrider.c   ****       set_event(EV_CLAXON_OFF);
 243:easyrider.c   ****     }
 244:easyrider.c   ****   }
 245:easyrider.c   ****   // dynamic senses
 246:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
 247:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
 248:easyrider.c   ****       set_event(EV_CLAXON_OFF);
 249:easyrider.c   ****     } else {
 250:easyrider.c   ****       set_event(EV_CLAXON_ON);
 251:easyrider.c   ****     }
 252:easyrider.c   ****   }
 253:easyrider.c   **** }
 254:easyrider.c   **** 
 255:easyrider.c   **** void check_pilot() {
 256:easyrider.c   ****   // pin senses
 257:easyrider.c   ****   if ((g_senses & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
 258:easyrider.c   ****     if (~STATUS_C90_SENSE_PILOT) {
 259:easyrider.c   ****       set_event(EV_PILOT_ON);
 260:easyrider.c   ****     }
 261:easyrider.c   ****     if (STATUS_C90_SENSE_PILOT) {
 262:easyrider.c   ****       set_event(EV_PILOT_OFF);
 263:easyrider.c   ****     }
 264:easyrider.c   ****   }
 265:easyrider.c   ****   // dynamic senses
 266:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
 267:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
 268:easyrider.c   ****       set_event(EV_PILOT_OFF);
 269:easyrider.c   ****     } else {
 270:easyrider.c   ****       set_event(EV_PILOT_ON);
 271:easyrider.c   ****     }
 272:easyrider.c   ****   }
 273:easyrider.c   **** }
 274:easyrider.c   **** 
 275:easyrider.c   **** void check_light() {
 276:easyrider.c   ****   // pin senses
 277:easyrider.c   ****   if ((g_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
 278:easyrider.c   ****     if (~STATUS_C90_SENSE_LIGHT) {
 279:easyrider.c   ****       set_event(EV_LIGHT_ON);
 280:easyrider.c   ****     }
 281:easyrider.c   ****     if (STATUS_C90_SENSE_LIGHT) {
 282:easyrider.c   ****       set_event(EV_LIGHT_OFF);
 283:easyrider.c   ****     }
 284:easyrider.c   ****   }
 285:easyrider.c   ****   // dynamic senses
 286:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
 287:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
 288:easyrider.c   ****       set_event(EV_LIGHT_OFF);
 289:easyrider.c   ****     } else {
 290:easyrider.c   ****       set_event(EV_LIGHT_ON);
 291:easyrider.c   ****     }
 292:easyrider.c   ****   }
 293:easyrider.c   **** }
 294:easyrider.c   **** 
 295:easyrider.c   **** void check_brake() {
 296:easyrider.c   ****   // pin senses
 297:easyrider.c   ****   if ((g_senses & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
 298:easyrider.c   ****     if (~STATUS_C90_SENSE_BRAKE) {
 299:easyrider.c   ****       set_event(EV_BRAKE_ON);
 300:easyrider.c   ****     }
 301:easyrider.c   ****     if (STATUS_C90_SENSE_BRAKE) {
 302:easyrider.c   ****       set_event(EV_BRAKE_OFF);
 303:easyrider.c   ****     }
 304:easyrider.c   ****   }
 305:easyrider.c   ****   // dynamic senses
 306:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
 307:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
 308:easyrider.c   ****       set_event(EV_BRAKE_OFF);
 309:easyrider.c   ****     } else {
 310:easyrider.c   ****       set_event(EV_BRAKE_ON);
 311:easyrider.c   ****     }
 312:easyrider.c   ****   }
 313:easyrider.c   **** }
 314:easyrider.c   **** 
 315:easyrider.c   **** void check_ign() {
 316:easyrider.c   ****   // pin senses
 317:easyrider.c   ****   if ((g_senses & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
 318:easyrider.c   ****     if (~STATUS_C90_SENSE_IGN) {
 319:easyrider.c   ****       set_event(EV_IGN_ON);
 320:easyrider.c   ****     }
 321:easyrider.c   ****     if (STATUS_C90_SENSE_IGN) {
 322:easyrider.c   ****       set_event(EV_IGN_OFF);
 323:easyrider.c   ****     }
 324:easyrider.c   ****   }
 325:easyrider.c   ****   // dynamic senses
 326:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
 327:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
 328:easyrider.c   ****       set_event(EV_IGN_OFF);
 329:easyrider.c   ****     } else {
 330:easyrider.c   ****       set_event(EV_IGN_ON);
 331:easyrider.c   ****     }
 332:easyrider.c   ****   }
 333:easyrider.c   **** }
 334:easyrider.c   **** 
 335:easyrider.c   **** void check_alarm() {
 336:easyrider.c   ****   // pin senses
 337:easyrider.c   ****   if ((g_senses & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
 338:easyrider.c   ****     if (~STATUS_C90_SENSE_ALARM) {
 339:easyrider.c   ****       set_event(EV_ALARM_ON);
 340:easyrider.c   ****     }
 341:easyrider.c   ****     if (STATUS_C90_SENSE_ALARM) {
 342:easyrider.c   ****       set_event(EV_ALARM_OFF);
 343:easyrider.c   ****     }
 344:easyrider.c   ****   }
 345:easyrider.c   ****   // dynamic senses
 346:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
 347:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
 348:easyrider.c   ****       set_event(EV_ALARM_OFF);
 349:easyrider.c   ****     } else {
 350:easyrider.c   ****       set_event(EV_ALARM_ON);
 351:easyrider.c   ****     }
 352:easyrider.c   ****   }
 353:easyrider.c   **** }
 354:easyrider.c   **** 
 355:easyrider.c   **** void check_battery() {
 356:easyrider.c   ****   if (check_battery_read()) {
 357:easyrider.c   ****     set_event(EV_READ_BATT);
 358:easyrider.c   ****   }
 359:easyrider.c   **** }
 360:easyrider.c   **** 
 361:easyrider.c   **** void check_sleep() {
 362:easyrider.c   ****   if (g_state == ST_SLEEP) {
 363:easyrider.c   ****     if (g_sleep_counter == 0) {
 364:easyrider.c   ****       sleep_now();
 365:easyrider.c   ****     }
 366:easyrider.c   ****   } else {
 367:easyrider.c   ****     g_sleep_counter = g_settings.deep_sleep_counter;
 368:easyrider.c   ****   }
 369:easyrider.c   **** }
 370:easyrider.c   **** 
 371:easyrider.c   **** void check_backpedal() {
 372:easyrider.c   ****   if (check_backpedal_on()) {
 373:easyrider.c   ****     set_event(EV_BACKPEDAL);
 374:easyrider.c   ****   }
 375:easyrider.c   **** }
 376:easyrider.c   **** 
 377:easyrider.c   **** void check_warning() {
 378:easyrider.c   ****   // pin senses
 379:easyrider.c   ****   if ((g_senses & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
 380:easyrider.c   ****     if (~STATUS_C90_SENSE_WARNING) {
 381:easyrider.c   ****       set_event(EV_WARNING_ON);
 382:easyrider.c   ****     }
 383:easyrider.c   ****     if (STATUS_C90_SENSE_WARNING) {
 384:easyrider.c   ****       set_event(EV_WARNING_OFF);
 385:easyrider.c   ****     }
 386:easyrider.c   ****   }
 387:easyrider.c   ****   // dynamic senses
 388:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
 389:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
 390:easyrider.c   ****       set_event(EV_WARNING_OFF);
 391:easyrider.c   ****     } else {
 392:easyrider.c   ****       set_event(EV_WARNING_ON);
 393:easyrider.c   ****     }
 394:easyrider.c   ****   }
 395:easyrider.c   **** }
 396:easyrider.c   **** 
 397:easyrider.c   **** void check_settle() {
 398:easyrider.c   ****   if (g_state == ST_SETTLE) {
 399:easyrider.c   ****     if (!FLAG_SETTLE) { // first time in settle mode
 400:easyrider.c   ****       uint8_t song_idx = g_settings.startup_sound;
 401:easyrider.c   ****       FLAG_SETTLE = 1;
 402:easyrider.c   ****       // activate all lights
 403:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 404:easyrider.c   ****       PORT_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 405:easyrider.c   ****       PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
 406:easyrider.c   ****       PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
 407:easyrider.c   ****       PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
 408:easyrider.c   ****       PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
 409:easyrider.c   ****       PORT_C90_BRAKE |= (1 << PIN_C90_BRAKE);
 410:easyrider.c   ****       PORT_C90_PILOT |= (1 << PIN_C90_PILOT);
 411:easyrider.c   ****       PORT_C90_LIGHT |= (1 << PIN_C90_LIGHT);
 412:easyrider.c   ****       PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // silence a possible claxon from the alarm
 413:easyrider.c   ****       // check voltage and activate according sound
 414:easyrider.c   ****       g_music_duration = 0;
 415:easyrider.c   ****       // check for random startup song
 416:easyrider.c   ****       if (song_idx == 0) {
 417:easyrider.c   ****         srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda 
 418:easyrider.c   ****         song_idx = 2 + (uint8_t)(rand() / (RAND_MAX / 5));
 419:easyrider.c   ****       }
 420:easyrider.c   ****       g_current_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 421:easyrider.c   ****       g_selected_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 422:easyrider.c   ****       FLAG_MUSIC = 1;
 423:easyrider.c   ****       g_current_settle_time = g_settings.settle_time;
 424:easyrider.c   ****     }
 425:easyrider.c   ****     if (!g_current_settle_time) { // settle time is over
 426:easyrider.c   ****       FLAG_SETTLE = 0; // reset settle
 427:easyrider.c   ****       g_state = ST_NORMAL;
 428:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 429:easyrider.c   ****       PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 430:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 431:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 432:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 433:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 434:easyrider.c   ****       PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
 435:easyrider.c   ****       PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 436:easyrider.c   ****       PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 437:easyrider.c   ****       PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 438:easyrider.c   ****     }
 439:easyrider.c   ****   }
 440:easyrider.c   **** }
 441:easyrider.c   **** 
 442:easyrider.c   **** void check_alarm_settle() {
 443:easyrider.c   ****   if (g_state == ST_ALARM_SETTLE) {
 444:easyrider.c   ****     if (!FLAG_ALARM_SETTLE) { // first time in alarm settle mode
 445:easyrider.c   ****       uint8_t song_idx = g_settings.alarm_sound;
 446:easyrider.c   ****       // check for random startup song
 447:easyrider.c   ****       if (song_idx == 0) {
 448:easyrider.c   ****         srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda 
 449:easyrider.c   ****         song_idx = 1 + (uint8_t)(rand() / (RAND_MAX / 6));
 450:easyrider.c   ****       }
 451:easyrider.c   ****       FLAG_ALARM_SETTLE = 1;
 452:easyrider.c   ****       // activate indicators
 453:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 454:easyrider.c   ****       PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
 455:easyrider.c   ****       PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
 456:easyrider.c   ****       PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
 457:easyrider.c   ****       PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
 458:easyrider.c   ****       g_music_duration = 0;
 459:easyrider.c   ****       g_current_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 460:easyrider.c   ****       g_selected_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 461:easyrider.c   ****       FLAG_MUSIC = 1;
 462:easyrider.c   ****       g_current_alarm_settle_time = g_settings.alarm_settle_time;
 463:easyrider.c   ****       g_alarm_snapshot[0] = 0;
 464:easyrider.c   ****       g_alarm_snapshot[1] = 0;
 465:easyrider.c   ****       g_alarm_snapshot[2] = 0;
 466:easyrider.c   ****     }
 467:easyrider.c   ****     // save the AVERAGE accelerometer values as the alarm trigger reference during the settlement
 468:easyrider.c   ****     if (g_alarm_snapshot[0]) {
 469:easyrider.c   ****       g_alarm_snapshot[0] = ((g_alarm_snapshot[0] + g_adc_voltage[1])/2);
 470:easyrider.c   ****     } else {
 471:easyrider.c   ****       g_alarm_snapshot[0] = g_adc_voltage[1];
 472:easyrider.c   ****     }
 473:easyrider.c   ****     if (g_alarm_snapshot[1]) {
 474:easyrider.c   ****       g_alarm_snapshot[1] = ((g_alarm_snapshot[1] + g_adc_voltage[2])/2);
 475:easyrider.c   ****     } else {
 476:easyrider.c   ****       g_alarm_snapshot[1] = g_adc_voltage[2];
 477:easyrider.c   ****     }
 478:easyrider.c   ****     if (g_alarm_snapshot[2]) {
 479:easyrider.c   ****       g_alarm_snapshot[2] = ((g_alarm_snapshot[2] + g_adc_voltage[3])/2);
 480:easyrider.c   ****     } else {
 481:easyrider.c   ****       g_alarm_snapshot[2] = g_adc_voltage[3];
 482:easyrider.c   ****     }
 483:easyrider.c   ****     // alarm settle time is over: only start alarm with valid accelerometer voltages
 484:easyrider.c   ****     if ((!g_current_alarm_settle_time) && ((g_alarm_snapshot[0] > g_settings.alarm_thres_min) && (g
 485:easyrider.c   ****        ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.ala
 486:easyrider.c   ****        ((g_alarm_snapshot[2] > g_settings.alarm_thres_min) && (g_alarm_snapshot[2] < g_settings.ala
 487:easyrider.c   ****       // prepare for alarm mode
 488:easyrider.c   ****       FLAG_ALARM_SETTLE = 0;
 489:easyrider.c   ****       all_lights_off();
 490:easyrider.c   ****       g_alarm_counter = g_settings.alarm_counter;
 491:easyrider.c   ****       g_trigger_counter = 0;
 492:easyrider.c   ****       g_state = ST_ALARM;
 493:easyrider.c   ****     }
 494:easyrider.c   ****   }
 495:easyrider.c   **** }
 496:easyrider.c   **** 
 497:easyrider.c   **** // triggers alarm if movement (voltage change) is high enough 
 498:easyrider.c   **** // 1.5g setting:  Sensitivity: 800 mV/g  -1g = 850mV  0g = 1650mV 1g = 2450mV
 499:easyrider.c   **** // 1 degree tilt is about 9mv, so by default: if the voltage differs 90mv (~10 degrees), for a cert
 500:easyrider.c   **** void check_alarm_trigger() {
 501:easyrider.c   ****   if (g_state == ST_ALARM) {
 502:easyrider.c   ****     if (FLAG_ALARM_TRIGGER) {
 503:easyrider.c   ****       if (FLAG_ALARM_BLINK) {
 504:easyrider.c   ****         FLAG_ALARM_BLINK = 0;
 505:easyrider.c   ****         PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 506:easyrider.c   ****         PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 507:easyrider.c   ****         PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
 508:easyrider.c   ****         PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
 509:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 510:easyrider.c   ****         PORT_C90_CLAXON ^= (1 << PIN_C90_CLAXON);
 511:easyrider.c   ****         g_alarm_counter--;
 512:easyrider.c   ****         if (!g_alarm_counter) {
 513:easyrider.c   ****           all_lights_off();
 514:easyrider.c   ****           FLAG_ALARM_TRIGGER = 0; // reset alarm trigger
 515:easyrider.c   ****           g_state = ST_ALARM_SETTLE; // go back to new alarm settle mode
 516:easyrider.c   ****           FLAG_ALARM_SETTLE = 0; // reset alarm settle
 517:easyrider.c   ****         }
 518:easyrider.c   ****       }
 519:easyrider.c   ****     } else if (FLAG_ALARM_BLINK) {
 520:easyrider.c   ****       FLAG_ALARM_BLINK = 0;
 521:easyrider.c   ****       if (g_alarm_blink_counter % 4 == 0) { // blink for 1 tick every timer1 4 counts
 522:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 523:easyrider.c   ****       } else {
 524:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 525:easyrider.c   ****       }
 526:easyrider.c   ****       if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
 527:easyrider.c   ****        (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
 528:easyrider.c   ****        (abs(g_adc_voltage[3] - g_alarm_snapshot[2]) > g_settings.alarm_trigger)) {
 529:easyrider.c   ****         g_trigger_counter++;
 530:easyrider.c   ****         if (g_trigger_counter >= g_settings.alarm_trigger_counter) {
 531:easyrider.c   ****           FLAG_ALARM_TRIGGER = 1;
 532:easyrider.c   ****         }
 533:easyrider.c   ****       }
 534:easyrider.c   ****     }
 535:easyrider.c   ****   }
 536:easyrider.c   **** }
 537:easyrider.c   **** 
 538:easyrider.c   **** uint8_t get_event() {
 539:easyrider.c   ****   uint8_t ev;
 540:easyrider.c   ****   if (g_buffer_tail != g_buffer_head) { // not empty
 541:easyrider.c   ****     ev = g_event_buffer[g_buffer_tail];
 542:easyrider.c   ****     g_buffer_tail++;
 543:easyrider.c   ****     if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 544:easyrider.c   ****       g_buffer_tail = 0;
 545:easyrider.c   ****     }
 546:easyrider.c   ****     return ev;
 547:easyrider.c   ****   } else {
 548:easyrider.c   ****     return EV_VOID; // just keep returning a void event
 549:easyrider.c   ****   }
 550:easyrider.c   **** }
 551:easyrider.c   **** 
 552:easyrider.c   **** void set_event(uint8_t ev) {
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 554:easyrider.c   ****   g_buffer_head++; // advance head
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 557:easyrider.c   ****   }
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 560:easyrider.c   ****   }
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 563:easyrider.c   ****   }
 564:easyrider.c   **** }
 565:easyrider.c   **** 
 566:easyrider.c   **** void process_ri_off() {
 567:easyrider.c   ****   if (FLAG_DEBOUNCE_RI) { // check for 3 positives based on 5ms timer
 568:easyrider.c   ****     g_ri_debounce = (g_ri_debounce << 1);
 569:easyrider.c   ****     FLAG_DEBOUNCE_RI = 0; // reset to wait for next timer event
 570:easyrider.c   ****     if (((g_ri_debounce & 0b00000111) << 5) == 0) {
 571:easyrider.c   ****       remove_substate(ST_RI); // debouncing done, remove state
 572:easyrider.c   ****       // disable indicators
 573:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
 574:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
 575:easyrider.c   ****       if (g_settings.indicator_sound) {
 576:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 577:easyrider.c   ****       }
 578:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 579:easyrider.c   ****     }
 580:easyrider.c   ****   }
 581:easyrider.c   **** }
 582:easyrider.c   **** 
 583:easyrider.c   **** void process_ri_on() {
 584:easyrider.c   ****   if (FLAG_DEBOUNCE_RI) { // check for 3 positives based on 5ms timer
 585:easyrider.c   ****     g_ri_debounce = (g_ri_debounce << 1) | 0x01;
 586:easyrider.c   ****     FLAG_DEBOUNCE_RI = 0; // reset to wait for next timer event
 587:easyrider.c   ****     if (((g_ri_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_RI)) { // blink indicators
 588:easyrider.c   ****       PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 589:easyrider.c   ****       PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 590:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 591:easyrider.c   ****       if (g_settings.indicator_sound) {
 592:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 593:easyrider.c   ****       }
 594:easyrider.c   ****       FLAG_BLINK_RI = 0; // reset to wait for next timer event
 595:easyrider.c   ****       if (!get_substate(ST_RI)) { // first time to blink
 596:easyrider.c   ****         TCNT1 = 0; // reset timer so the blink starts in an even pace
 597:easyrider.c   ****         set_substate(ST_RI);
 598:easyrider.c   ****       }
 599:easyrider.c   ****     }
 600:easyrider.c   ****   }
 601:easyrider.c   **** }
 602:easyrider.c   **** 
 603:easyrider.c   **** void process_li_off() {
 604:easyrider.c   ****   if (FLAG_DEBOUNCE_LI) { // check for 3 positives based on 5ms timer
 605:easyrider.c   ****     g_li_debounce = (g_li_debounce << 1);
 606:easyrider.c   ****     FLAG_DEBOUNCE_LI = 0; // reset to wait for next timer event
 607:easyrider.c   ****     if (((g_li_debounce & 0b00000111) << 5) == 0) {
 608:easyrider.c   ****       remove_substate(ST_LI); // debouncing done, remove state
 609:easyrider.c   ****       // disable indicators
 610:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
 611:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
 612:easyrider.c   ****       if (g_settings.indicator_sound) {
 613:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 614:easyrider.c   ****       }
 615:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 616:easyrider.c   ****     }
 617:easyrider.c   ****   }
 618:easyrider.c   **** }
 619:easyrider.c   **** 
 620:easyrider.c   **** void process_li_on() {
 621:easyrider.c   ****   if (FLAG_DEBOUNCE_LI) { // check for 3 positives based on 5ms timer
 622:easyrider.c   ****     g_li_debounce = (g_li_debounce << 1) | 0x01;
 623:easyrider.c   ****     FLAG_DEBOUNCE_LI = 0; // reset to wait for next timer event
 624:easyrider.c   ****     if (((g_li_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_LI)) { // blink indicators
 625:easyrider.c   ****       PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F); // front
 626:easyrider.c   ****       PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B); // rear
 627:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 628:easyrider.c   ****       if (g_settings.indicator_sound) {
 629:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 630:easyrider.c   ****       }
 631:easyrider.c   ****       FLAG_BLINK_LI = 0; // reset to wait for next timer event
 632:easyrider.c   ****       if (!get_substate(ST_LI)) { // first time to blink
 633:easyrider.c   ****         TCNT1 = 0; // set 0.5 sec timer counter explicitly to 0, so the first blink happens exactly
 634:easyrider.c   ****         set_substate(ST_LI);
 635:easyrider.c   ****       }
 636:easyrider.c   ****     }
 637:easyrider.c   ****   }
 638:easyrider.c   **** }
 639:easyrider.c   **** 
 640:easyrider.c   **** void process_claxon_on() {
 641:easyrider.c   ****   if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
 642:easyrider.c   ****     g_claxon_debounce = (g_claxon_debounce << 1) | 0x01;
 643:easyrider.c   ****     FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
 644:easyrider.c   ****     if ((g_claxon_debounce & 0b00000111) == 0b00000111) { // start claxon
 645:easyrider.c   ****       PORT_C90_CLAXON |= (1 << PIN_C90_CLAXON);
 646:easyrider.c   ****       if (!get_substate(ST_CLAXON)) {
 647:easyrider.c   ****         set_substate(ST_CLAXON);
 648:easyrider.c   ****       }
 649:easyrider.c   ****     }
 650:easyrider.c   ****   }
 651:easyrider.c   **** }
 652:easyrider.c   **** 
 653:easyrider.c   **** void process_claxon_off() {
 654:easyrider.c   ****   if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
 655:easyrider.c   ****     g_claxon_debounce = (g_claxon_debounce << 1);
 656:easyrider.c   ****     FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
 657:easyrider.c   ****     if (((g_claxon_debounce & 0b00000111) << 5) == 0) {
 658:easyrider.c   ****       remove_substate(ST_CLAXON); // debouncing done, remove state
 659:easyrider.c   ****       PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
 660:easyrider.c   ****     }
 661:easyrider.c   ****   }
 662:easyrider.c   **** }
 663:easyrider.c   **** 
 664:easyrider.c   **** void process_warning_on() {
 665:easyrider.c   ****   if (FLAG_DEBOUNCE_WARNING) { // check for 3 positives based on 5ms timer
 666:easyrider.c   ****     g_warning_debounce = (g_warning_debounce << 1) | 0x01;
 667:easyrider.c   ****     FLAG_DEBOUNCE_WARNING = 0; // reset to wait for next timer event
 668:easyrider.c   ****     if (((g_warning_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_WARNING)) { // blink indic
 669:easyrider.c   ****       PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 670:easyrider.c   ****       PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 671:easyrider.c   ****       PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
 672:easyrider.c   ****       PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
 673:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 674:easyrider.c   ****       if (g_settings.indicator_sound) {
 675:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 676:easyrider.c   ****       }
 677:easyrider.c   ****       FLAG_BLINK_WARNING = 0; // reset to wait for next timer event
 678:easyrider.c   ****       if (!get_substate(ST_WARNING)) { // first time to blink
 679:easyrider.c   ****         TCNT1 = 0; // reset timer so the blink starts in an even pace
 680:easyrider.c   ****         // initial ON for indicators to prevent a  RI/LI ON messing with the synchronization, i.e. 
 681:easyrider.c   ****         PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
 682:easyrider.c   ****         PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
 683:easyrider.c   ****         PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
 684:easyrider.c   ****         PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
 685:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 686:easyrider.c   ****         set_substate(ST_WARNING);
 687:easyrider.c   ****       }
 688:easyrider.c   ****     }
 689:easyrider.c   ****   }
 690:easyrider.c   **** }
 691:easyrider.c   **** 
 692:easyrider.c   **** void process_warning_off() {
 693:easyrider.c   ****   if (FLAG_DEBOUNCE_WARNING) { // check for 3 positives based on 5ms timer
 694:easyrider.c   ****     g_warning_debounce = (g_warning_debounce << 1);
 695:easyrider.c   ****     FLAG_DEBOUNCE_WARNING = 0; // reset to wait for next timer event
 696:easyrider.c   ****     if (((g_warning_debounce & 0b00000111) << 5) == 0) {
 697:easyrider.c   ****       remove_substate(ST_WARNING); // debouncing done, remove state
 698:easyrider.c   ****       // disable indicators
 699:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
 700:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
 701:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
 702:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
 703:easyrider.c   ****       if (g_settings.indicator_sound) {
 704:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 705:easyrider.c   ****       }
 706:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 707:easyrider.c   ****     }
 708:easyrider.c   ****   }
 709:easyrider.c   **** }
 710:easyrider.c   **** 
 711:easyrider.c   **** // check for an acceleration of 25cm/s, 20mV change in the negative Y-axis
 712:easyrider.c   **** void process_backpedal() {
 713:easyrider.c   ****   if (FLAG_READ_BACKPEDAL) {
 714:easyrider.c   ****     FLAG_READ_BACKPEDAL = 0; // reset to wait for next timer event
 715:easyrider.c   ****     if ((g_adc_voltage[2] < g_settings.backpedal_thres_min) && FLAG_BLINK_BACKPEDAL) {
 716:easyrider.c   ****       FLAG_BACKPEDAL = 1;
 717:easyrider.c   ****       PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 718:easyrider.c   ****       PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 719:easyrider.c   ****       PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
 720:easyrider.c   ****       PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
 721:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 722:easyrider.c   ****       if (g_settings.indicator_sound) {
 723:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 724:easyrider.c   ****       }
 725:easyrider.c   ****       FLAG_BLINK_BACKPEDAL = 0;
 726:easyrider.c   ****     } else if ((g_adc_voltage[2] >= g_settings.backpedal_thres_min) && FLAG_BACKPEDAL && FLAG_BLINK
 727:easyrider.c   ****       FLAG_BACKPEDAL = 0;
 728:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
 729:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
 730:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
 731:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
 732:easyrider.c   ****       if (g_settings.indicator_sound) {
 733:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 734:easyrider.c   ****       }
 735:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 736:easyrider.c   ****     }
 737:easyrider.c   ****   }
 738:easyrider.c   **** }
 739:easyrider.c   **** 
 740:easyrider.c   **** void process_ign_on() {
 741:easyrider.c   ****   if (FLAG_DEBOUNCE_IGN) { // check for 3 positives based on 5ms timer
 742:easyrider.c   ****     g_ign_debounce= (g_ign_debounce << 1) | 0x01;
 743:easyrider.c   ****     FLAG_DEBOUNCE_IGN = 0; // reset to wait for next timer event
 744:easyrider.c   ****     if ((g_ign_debounce & 0b00000111) == 0b00000111) {
 745:easyrider.c   ****       g_state = ST_SETTLE;
 746:easyrider.c   ****     }
 747:easyrider.c   ****   }
 748:easyrider.c   **** }
 749:easyrider.c   **** 
 750:easyrider.c   **** void process_ign_off() {
 751:easyrider.c   ****   if (FLAG_DEBOUNCE_IGN) { // check for 3 positives based on 5ms timer
 752:easyrider.c   ****     g_ign_debounce = (g_ign_debounce << 1);
 753:easyrider.c   ****     FLAG_DEBOUNCE_IGN = 0; // reset to wait for next timer event
 754:easyrider.c   ****     if (((g_ign_debounce & 0b00000111) << 5) == 0) {
 755:easyrider.c   ****       all_lights_off();
 756:easyrider.c   ****       PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER); // buzzer off
 757:easyrider.c   ****       FLAG_SETTLE = 0; // reset settle
 758:easyrider.c   ****       g_state = ST_SLEEP;
 759:easyrider.c   ****     }
 760:easyrider.c   ****   }
 761:easyrider.c   **** }
 762:easyrider.c   **** 
 763:easyrider.c   **** void process_brake_on() {
 764:easyrider.c   ****   if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
 765:easyrider.c   ****     g_brake_debounce = (g_brake_debounce << 1) | 0x01;
 766:easyrider.c   ****     FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
 767:easyrider.c   ****     if ((g_brake_debounce & 0b00000111) == 0b00000111) { // start brake
 768:easyrider.c   ****       PORT_C90_BRAKE |= (1 << PIN_C90_BRAKE);
 769:easyrider.c   ****       if (!get_substate(ST_BRAKE)) {
 770:easyrider.c   ****         set_substate(ST_BRAKE);
 771:easyrider.c   ****       }
 772:easyrider.c   ****     }
 773:easyrider.c   ****   }
 774:easyrider.c   **** }
 775:easyrider.c   **** 
 776:easyrider.c   **** void process_brake_off() {
 777:easyrider.c   ****   if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
 778:easyrider.c   ****     g_brake_debounce = (g_brake_debounce << 1);
 779:easyrider.c   ****     FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
 780:easyrider.c   ****     if (((g_brake_debounce & 0b00000111) << 5) == 0) {
 781:easyrider.c   ****       remove_substate(ST_BRAKE); // debouncing done, remove state
 782:easyrider.c   ****       PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE); // disable brake
 783:easyrider.c   ****     }
 784:easyrider.c   ****   }
 785:easyrider.c   **** }
 786:easyrider.c   **** 
 787:easyrider.c   **** void process_pilot_on() {
 788:easyrider.c   ****   if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
 789:easyrider.c   ****     g_pilot_debounce = (g_pilot_debounce << 1) | 0x01;
 790:easyrider.c   ****     FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
 791:easyrider.c   ****     if ((g_pilot_debounce & 0b00000111) == 0b00000111) { // start pilot
 792:easyrider.c   ****       PORT_C90_PILOT |= (1 << PIN_C90_PILOT);
 793:easyrider.c   ****       if (!get_substate(ST_PILOT)) {
 794:easyrider.c   ****         set_substate(ST_PILOT);
 795:easyrider.c   ****       }
 796:easyrider.c   ****     }
 797:easyrider.c   ****   }
 798:easyrider.c   **** }
 799:easyrider.c   **** 
 800:easyrider.c   **** void process_pilot_off() {
 801:easyrider.c   ****   if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
 802:easyrider.c   ****     g_pilot_debounce = (g_pilot_debounce << 1);
 803:easyrider.c   ****     FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
 804:easyrider.c   ****     if (((g_pilot_debounce & 0b00000111) << 5) == 0) {
 805:easyrider.c   ****       remove_substate(ST_PILOT); // debouncing done, remove state
 806:easyrider.c   ****       PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT); // disable pilot
 807:easyrider.c   ****     }
 808:easyrider.c   ****   }
 809:easyrider.c   **** }
 810:easyrider.c   **** 
 811:easyrider.c   **** void process_light_on() {
 812:easyrider.c   ****   if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
 813:easyrider.c   ****     g_light_debounce = (g_light_debounce << 1) | 0x01;
 814:easyrider.c   ****     FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
 815:easyrider.c   ****     if ((g_light_debounce & 0b00000111) == 0b00000111) { // start light
 816:easyrider.c   ****       PORT_C90_LIGHT |= (1 << PIN_C90_LIGHT);
 817:easyrider.c   ****       if (!get_substate(ST_LIGHT)) {
 818:easyrider.c   ****         set_substate(ST_LIGHT);
 819:easyrider.c   ****       }
 820:easyrider.c   ****     }
 821:easyrider.c   ****   }
 822:easyrider.c   **** }
 823:easyrider.c   **** 
 824:easyrider.c   **** void process_light_off() {
 825:easyrider.c   ****   if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
 826:easyrider.c   ****     g_light_debounce = (g_light_debounce << 1);
 827:easyrider.c   ****     FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
 828:easyrider.c   ****     if (((g_light_debounce & 0b00000111) << 5) == 0) {
 829:easyrider.c   ****       remove_substate(ST_LIGHT); // debouncing done, remove state
 830:easyrider.c   ****       PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT); // disable light
 831:easyrider.c   ****     }
 832:easyrider.c   ****   }
 833:easyrider.c   **** }
 834:easyrider.c   **** 
 835:easyrider.c   **** void process_alarm_off() {
 836:easyrider.c   ****   if (FLAG_DEBOUNCE_ALARM) { // check for 3 positives based on 5ms timer
 837:easyrider.c   ****     g_alarm_debounce = (g_alarm_debounce << 1);
 838:easyrider.c   ****     FLAG_DEBOUNCE_ALARM = 0; // reset to wait for next timer event
 839:easyrider.c   ****     if (((g_alarm_debounce & 0b00000111) << 5) == 0) {
 840:easyrider.c   ****       all_lights_off();
 841:easyrider.c   ****       FLAG_ALARM_SETTLE = 0; // reset alarm settle
 842:easyrider.c   ****       g_state = ST_SLEEP;
 843:easyrider.c   ****     }
 844:easyrider.c   ****   }
 845:easyrider.c   **** }
 846:easyrider.c   **** 
 847:easyrider.c   **** void process_alarm_on() {
 848:easyrider.c   ****   if (FLAG_DEBOUNCE_ALARM) { // check for 3 positives based on 5ms timer
 849:easyrider.c   ****     g_alarm_debounce = (g_alarm_debounce << 1) | 0x01;
 850:easyrider.c   ****     FLAG_DEBOUNCE_ALARM = 0; // reset to wait for next timer event
 851:easyrider.c   ****     if ((g_alarm_debounce & 0b00000111) == 0b00000111) { // start alarm
 852:easyrider.c   ****       FLAG_ALARM_SETTLE = 0; // reset alarm settle
 853:easyrider.c   ****       g_state = ST_ALARM_SETTLE;
 854:easyrider.c   ****     }
 855:easyrider.c   ****   }
 856:easyrider.c   **** }
 857:easyrider.c   **** 
 858:easyrider.c   **** // check if battery voltage is OK: between 12.0 and 16.0 volts
 859:easyrider.c   **** // 10bit ADC value 0-1023: (Vmeasure*1024)/Vref
 860:easyrider.c   **** // for 12v battery readout: my voltage divider ratio: 100K -- 18K = 0.1525 * Vmeasure
 861:easyrider.c   **** // of the full voltage. 
 862:easyrider.c   **** // initial voltage
 863:easyrider.c   **** // If Vref isnt exactly 5.00v, but a bit off, tweak C90_OFFSET_ADC_READING
 864:easyrider.c   **** void process_battery() {
 865:easyrider.c   ****   if (FLAG_READ_BATT) {
 866:easyrider.c   ****     if (g_adc_voltage[0] < 370) { // battery too low
 867:easyrider.c   ****       // slow blink cockpit status led
 868:easyrider.c   ****       if (g_battery_blink_counter % 100 == 0) { 
 869:easyrider.c   ****         PORT_C90_LIGHT_STATUS_COCKPIT ^= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 870:easyrider.c   ****       }
 871:easyrider.c   ****     } else if (g_adc_voltage[0] > 500) { // battery too high
 872:easyrider.c   ****       // fast blink cockpit status led
 873:easyrider.c   ****       if (g_battery_blink_counter % 50 == 0) { 
 874:easyrider.c   ****         PORT_C90_LIGHT_STATUS_COCKPIT ^= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 875:easyrider.c   ****       }
 876:easyrider.c   ****     } else { // battery Ok
 877:easyrider.c   ****       PORT_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 878:easyrider.c   ****     }
 879:easyrider.c   ****     FLAG_READ_BATT = 0;
 880:easyrider.c   ****   }
 881:easyrider.c   **** }
 882:easyrider.c   **** 
 883:easyrider.c   **** // all lighting pins go low
 884:easyrider.c   **** void all_lights_off() {
 885:easyrider.c   ****   PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 886:easyrider.c   ****   PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 887:easyrider.c   ****   PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 888:easyrider.c   ****   PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 889:easyrider.c   ****   PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 890:easyrider.c   ****   PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 891:easyrider.c   ****   PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 892:easyrider.c   ****   PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 893:easyrider.c   ****   PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 894:easyrider.c   ****   PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
 895:easyrider.c   **** }
 896:easyrider.c   **** 
 897:easyrider.c   **** void reset_ports() {
 658               		.loc 1 897 0
 659               		.cfi_startproc
 660               	/* prologue: function */
 661               	/* frame size = 0 */
 662               	/* stack size = 0 */
 663               	.L__stack_usage = 0
 898:easyrider.c   ****   // sense pins: as input, set high and activate internal pullups
 899:easyrider.c   ****   DDR_C90_SENSE_LIGHT_RI &= ~(1 << PIN_C90_SENSE_LIGHT_RI);
 664               		.loc 1 899 0
 665 0000 0C98      		cbi 0x1,4
 900:easyrider.c   ****   PORT_C90_SENSE_LIGHT_RI |= (1 << PIN_C90_SENSE_LIGHT_RI);
 666               		.loc 1 900 0
 667 0002 049A      		sbi 0,4
 901:easyrider.c   ****   DDR_C90_SENSE_LIGHT_LI &= ~(1 << PIN_C90_SENSE_LIGHT_LI);
 668               		.loc 1 901 0
 669 0004 0D98      		cbi 0x1,5
 902:easyrider.c   ****   PORT_C90_SENSE_LIGHT_LI |= (1 << PIN_C90_SENSE_LIGHT_LI);
 670               		.loc 1 902 0
 671 0006 059A      		sbi 0,5
 903:easyrider.c   ****   DDR_C90_SENSE_CLAXON &= ~(1 << PIN_C90_SENSE_CLAXON);
 672               		.loc 1 903 0
 673 0008 2398      		cbi 0x4,3
 904:easyrider.c   ****   PORT_C90_SENSE_CLAXON |= (1 << PIN_C90_SENSE_CLAXON);
 674               		.loc 1 904 0
 675 000a 1B9A      		sbi 0x3,3
 905:easyrider.c   ****   DDR_C90_SENSE_BRAKE &= ~(1 << PIN_C90_SENSE_BRAKE);
 676               		.loc 1 905 0
 677 000c 2098      		cbi 0x4,0
 906:easyrider.c   ****   PORT_C90_SENSE_BRAKE |= (1 << PIN_C90_SENSE_BRAKE);
 678               		.loc 1 906 0
 679 000e 189A      		sbi 0x3,0
 907:easyrider.c   ****   DDR_C90_SENSE_PILOT &= ~(1 << PIN_C90_SENSE_PILOT);
 680               		.loc 1 907 0
 681 0010 0E98      		cbi 0x1,6
 908:easyrider.c   ****   PORT_C90_SENSE_PILOT |= (1 << PIN_C90_SENSE_PILOT);
 682               		.loc 1 908 0
 683 0012 069A      		sbi 0,6
 909:easyrider.c   ****   DDR_C90_SENSE_ALARM &= ~(1 << PIN_C90_SENSE_ALARM);
 684               		.loc 1 909 0
 685 0014 2198      		cbi 0x4,1
 910:easyrider.c   ****   PORT_C90_SENSE_ALARM |= (1 << PIN_C90_SENSE_ALARM);
 686               		.loc 1 910 0
 687 0016 199A      		sbi 0x3,1
 911:easyrider.c   ****   DDR_C90_SENSE_LIGHT &= ~(1 << PIN_C90_SENSE_LIGHT);
 688               		.loc 1 911 0
 689 0018 0F98      		cbi 0x1,7
 912:easyrider.c   ****   PORT_C90_SENSE_LIGHT |= (1 << PIN_C90_SENSE_LIGHT);
 690               		.loc 1 912 0
 691 001a 079A      		sbi 0,7
 913:easyrider.c   ****   DDR_C90_SENSE_IGN &= ~(1 << PIN_C90_SENSE_IGN);
 692               		.loc 1 913 0
 693 001c 2298      		cbi 0x4,2
 914:easyrider.c   ****   PORT_C90_SENSE_IGN |= (1 << PIN_C90_SENSE_IGN);
 694               		.loc 1 914 0
 695 001e 1A9A      		sbi 0x3,2
 915:easyrider.c   ****   DDR_C90_SENSE_WARNING &= ~(1 << PIN_C90_SENSE_WARNING);
 696               		.loc 1 915 0
 697 0020 5098      		cbi 0xa,0
 916:easyrider.c   ****   PORT_C90_SENSE_WARNING |= (1 << PIN_C90_SENSE_WARNING);
 698               		.loc 1 916 0
 699 0022 489A      		sbi 0x9,0
 917:easyrider.c   ****   DDR_C90_SENSE_RESERVE &= ~(1 << PIN_C90_SENSE_RESERVE);
 700               		.loc 1 917 0
 701 0024 5198      		cbi 0xa,1
 918:easyrider.c   ****   PORT_C90_SENSE_RESERVE |= (1 << PIN_C90_SENSE_RESERVE);
 702               		.loc 1 918 0
 703 0026 499A      		sbi 0x9,1
 919:easyrider.c   ****   // relay pins: as output, set low at start
 920:easyrider.c   ****   // outputs
 921:easyrider.c   ****   DDR_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 704               		.loc 1 921 0
 705 0028 3A9A      		sbi 0x7,2
 922:easyrider.c   ****   DDR_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 706               		.loc 1 922 0
 707 002a 3D9A      		sbi 0x7,5
 923:easyrider.c   ****   DDR_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
 708               		.loc 1 923 0
 709 002c 389A      		sbi 0x7,0
 924:easyrider.c   ****   DDR_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
 710               		.loc 1 924 0
 711 002e 3B9A      		sbi 0x7,3
 925:easyrider.c   ****   DDR_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
 712               		.loc 1 925 0
 713 0030 399A      		sbi 0x7,1
 926:easyrider.c   ****   DDR_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
 714               		.loc 1 926 0
 715 0032 3C9A      		sbi 0x7,4
 927:easyrider.c   ****   DDR_C90_CLAXON |= (1 << PIN_C90_CLAXON);
 716               		.loc 1 927 0
 717 0034 569A      		sbi 0xa,6
 928:easyrider.c   ****   DDR_C90_BRAKE |= (1 << PIN_C90_BRAKE);
 718               		.loc 1 928 0
 719 0036 3F9A      		sbi 0x7,7
 929:easyrider.c   ****   DDR_C90_PILOT |= (1 << PIN_C90_PILOT);
 720               		.loc 1 929 0
 721 0038 579A      		sbi 0xa,7
 930:easyrider.c   ****   DDR_C90_LIGHT |= (1 << PIN_C90_LIGHT);
 722               		.loc 1 930 0
 723 003a 3E9A      		sbi 0x7,6
 931:easyrider.c   ****   // lows
 932:easyrider.c   ****   PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 724               		.loc 1 932 0
 725 003c 4298      		cbi 0x8,2
 933:easyrider.c   ****   PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 726               		.loc 1 933 0
 727 003e 4598      		cbi 0x8,5
 934:easyrider.c   ****   PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 728               		.loc 1 934 0
 729 0040 4098      		cbi 0x8,0
 935:easyrider.c   ****   PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 730               		.loc 1 935 0
 731 0042 4398      		cbi 0x8,3
 936:easyrider.c   ****   PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 732               		.loc 1 936 0
 733 0044 4198      		cbi 0x8,1
 937:easyrider.c   ****   PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 734               		.loc 1 937 0
 735 0046 4498      		cbi 0x8,4
 938:easyrider.c   ****   PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
 736               		.loc 1 938 0
 737 0048 5E98      		cbi 0xb,6
 939:easyrider.c   ****   PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 738               		.loc 1 939 0
 739 004a 4798      		cbi 0x8,7
 940:easyrider.c   ****   PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 740               		.loc 1 940 0
 741 004c 5F98      		cbi 0xb,7
 941:easyrider.c   ****   PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 742               		.loc 1 941 0
 743 004e 4698      		cbi 0x8,6
 942:easyrider.c   ****   // buzzer
 943:easyrider.c   ****   DDR_C90_BUZZER |= (1 << PIN_C90_BUZZER); // output
 744               		.loc 1 943 0
 745 0050 559A      		sbi 0xa,5
 944:easyrider.c   ****   PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER); // low
 746               		.loc 1 944 0
 747 0052 5D98      		cbi 0xb,5
 945:easyrider.c   ****   // heart beat led
 946:easyrider.c   ****   DDR_C90_HEARTBEAT_LED |= (1 << PIN_C90_HEARTBEAT_LED); // output
 748               		.loc 1 946 0
 749 0054 549A      		sbi 0xa,4
 947:easyrider.c   ****   PORT_C90_HEARTBEAT_LED |= (1 << PIN_C90_HEARTBEAT_LED); // high
 750               		.loc 1 947 0
 751 0056 5C9A      		sbi 0xb,4
 752               	.LBB106:
 753               	.LBB107:
 948:easyrider.c   ****   // activate all physical senses
 949:easyrider.c   ****   enable_psenses();
 950:easyrider.c   **** }
 951:easyrider.c   **** 
 952:easyrider.c   **** void enable_psenses() {
 953:easyrider.c   ****   g_senses = 0b11111111;
 754               		.loc 1 953 0
 755 0058 8FEF      		ldi r24,lo8(-1)
 756 005a 90E0      		ldi r25,0
 757 005c 9093 0000 		sts g_senses+1,r25
 758 0060 8093 0000 		sts g_senses,r24
 954:easyrider.c   ****   g_senses = ((g_senses << 8) | 0b11111111);
 759               		.loc 1 954 0
 760 0064 8091 0000 		lds r24,g_senses
 761 0068 9091 0000 		lds r25,g_senses+1
 762 006c 982F      		mov r25,r24
 763 006e 8827      		clr r24
 764 0070 8F6F      		ori r24,255
 765 0072 9093 0000 		sts g_senses+1,r25
 766 0076 8093 0000 		sts g_senses,r24
 767 007a 0895      		ret
 768               	.LBE107:
 769               	.LBE106:
 770               		.cfi_endproc
 771               	.LFE65:
 773               		.section	.text.process_ri_off,"ax",@progbits
 775               	process_ri_off:
 776               	.LFB44:
 566:easyrider.c   **** void process_ri_off() {
 777               		.loc 1 566 0
 778               		.cfi_startproc
 779               	/* prologue: function */
 780               	/* frame size = 0 */
 781               	/* stack size = 0 */
 782               	.L__stack_usage = 0
 567:easyrider.c   ****   if (FLAG_DEBOUNCE_RI) { // check for 3 positives based on 5ms timer
 783               		.loc 1 567 0
 784 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_RI
 785 0004 8823      		tst r24
 786 0006 01F0      		breq .L60
 568:easyrider.c   ****     g_ri_debounce = (g_ri_debounce << 1);
 787               		.loc 1 568 0
 788 0008 8091 0000 		lds r24,g_ri_debounce
 789 000c 880F      		lsl r24
 790 000e 8093 0000 		sts g_ri_debounce,r24
 569:easyrider.c   ****     FLAG_DEBOUNCE_RI = 0; // reset to wait for next timer event
 791               		.loc 1 569 0
 792 0012 1092 0000 		sts FLAG_DEBOUNCE_RI,__zero_reg__
 570:easyrider.c   ****     if (((g_ri_debounce & 0b00000111) << 5) == 0) {
 793               		.loc 1 570 0
 794 0016 8091 0000 		lds r24,g_ri_debounce
 795 001a 20E2      		ldi r18,lo8(32)
 796 001c 829F      		mul r24,r18
 797 001e C001      		movw r24,r0
 798 0020 1124      		clr __zero_reg__
 799 0022 9927      		clr r25
 800 0024 892B      		or r24,r25
 801 0026 01F4      		brne .L60
 802               	.LVL0:
 803               	.LBB112:
 804               	.LBB113:
 805               	.LBB114:
 806               	.LBB115:
  76:easyrider.c   ****   g_state &= ~st;
 807               		.loc 1 76 0
 808 0028 8091 0000 		lds r24,g_state
 809 002c 9091 0000 		lds r25,g_state+1
 810 0030 8D7F      		andi r24,253
 811 0032 9093 0000 		sts g_state+1,r25
 812 0036 8093 0000 		sts g_state,r24
 813               	.LBE115:
 814               	.LBE114:
 573:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
 815               		.loc 1 573 0
 816 003a 4098      		cbi 0x8,0
 574:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
 817               		.loc 1 574 0
 818 003c 4398      		cbi 0x8,3
 575:easyrider.c   ****       if (g_settings.indicator_sound) {
 819               		.loc 1 575 0
 820 003e 8091 0000 		lds r24,g_settings+6
 821 0042 8111      		cpse r24,__zero_reg__
 576:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 822               		.loc 1 576 0
 823 0044 5D98      		cbi 0xb,5
 824               	.L64:
 578:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 825               		.loc 1 578 0
 826 0046 4298      		cbi 0x8,2
 827               	.LVL1:
 828               	.L60:
 829 0048 0895      		ret
 830               	.LBE113:
 831               	.LBE112:
 832               		.cfi_endproc
 833               	.LFE44:
 835               		.section	.text.process_ri_on,"ax",@progbits
 837               	process_ri_on:
 838               	.LFB45:
 583:easyrider.c   **** void process_ri_on() {
 839               		.loc 1 583 0
 840               		.cfi_startproc
 841               	/* prologue: function */
 842               	/* frame size = 0 */
 843               	/* stack size = 0 */
 844               	.L__stack_usage = 0
 584:easyrider.c   ****   if (FLAG_DEBOUNCE_RI) { // check for 3 positives based on 5ms timer
 845               		.loc 1 584 0
 846 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_RI
 847 0004 8823      		tst r24
 848 0006 01F0      		breq .L68
 585:easyrider.c   ****     g_ri_debounce = (g_ri_debounce << 1) | 0x01;
 849               		.loc 1 585 0
 850 0008 8091 0000 		lds r24,g_ri_debounce
 851 000c 880F      		lsl r24
 852 000e 8160      		ori r24,lo8(1)
 853 0010 8093 0000 		sts g_ri_debounce,r24
 586:easyrider.c   ****     FLAG_DEBOUNCE_RI = 0; // reset to wait for next timer event
 854               		.loc 1 586 0
 855 0014 1092 0000 		sts FLAG_DEBOUNCE_RI,__zero_reg__
 587:easyrider.c   ****     if (((g_ri_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_RI)) { // blink indicators
 856               		.loc 1 587 0
 857 0018 8091 0000 		lds r24,g_ri_debounce
 858 001c 8770      		andi r24,lo8(7)
 859 001e 8730      		cpi r24,lo8(7)
 860 0020 01F0      		breq .L79
 861               	.L68:
 862 0022 0895      		ret
 863               	.L79:
 587:easyrider.c   ****     if (((g_ri_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_RI)) { // blink indicators
 864               		.loc 1 587 0 is_stmt 0 discriminator 1
 865 0024 8091 0000 		lds r24,FLAG_BLINK_RI
 866 0028 8823      		tst r24
 867 002a 01F0      		breq .L68
 588:easyrider.c   ****       PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 868               		.loc 1 588 0 is_stmt 1
 869 002c 88B1      		in r24,0x8
 870 002e 91E0      		ldi r25,lo8(1)
 871 0030 8927      		eor r24,r25
 872 0032 88B9      		out 0x8,r24
 589:easyrider.c   ****       PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 873               		.loc 1 589 0
 874 0034 88B1      		in r24,0x8
 875 0036 98E0      		ldi r25,lo8(8)
 876 0038 8927      		eor r24,r25
 877 003a 88B9      		out 0x8,r24
 590:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 878               		.loc 1 590 0
 879 003c 88B1      		in r24,0x8
 880 003e 94E0      		ldi r25,lo8(4)
 881 0040 8927      		eor r24,r25
 882 0042 88B9      		out 0x8,r24
 591:easyrider.c   ****       if (g_settings.indicator_sound) {
 883               		.loc 1 591 0
 884 0044 8091 0000 		lds r24,g_settings+6
 885 0048 8823      		tst r24
 886 004a 01F0      		breq .L72
 592:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 887               		.loc 1 592 0
 888 004c 8BB1      		in r24,0xb
 889 004e 90E2      		ldi r25,lo8(32)
 890 0050 8927      		eor r24,r25
 891 0052 8BB9      		out 0xb,r24
 892               	.L72:
 594:easyrider.c   ****       FLAG_BLINK_RI = 0; // reset to wait for next timer event
 893               		.loc 1 594 0
 894 0054 1092 0000 		sts FLAG_BLINK_RI,__zero_reg__
 895               	.LVL2:
 896               	.LBB124:
 897               	.LBB125:
  68:easyrider.c   ****   return (g_state & st);
 898               		.loc 1 68 0
 899 0058 8091 0000 		lds r24,g_state
 900 005c 9091 0000 		lds r25,g_state+1
 901               	.LBE125:
 902               	.LBE124:
 595:easyrider.c   ****       if (!get_substate(ST_RI)) { // first time to blink
 903               		.loc 1 595 0
 904 0060 81FD      		sbrc r24,1
 905 0062 00C0      		rjmp .L68
 906               	.LBB126:
 596:easyrider.c   ****         TCNT1 = 0; // reset timer so the blink starts in an even pace
 907               		.loc 1 596 0
 908 0064 1092 8500 		sts 132+1,__zero_reg__
 909 0068 1092 8400 		sts 132,__zero_reg__
 910               	.LVL3:
 911               	.LBB127:
 912               	.LBB128:
  72:easyrider.c   ****   g_state |= st;
 913               		.loc 1 72 0
 914 006c 8091 0000 		lds r24,g_state
 915 0070 9091 0000 		lds r25,g_state+1
 916 0074 8260      		ori r24,2
 917 0076 9093 0000 		sts g_state+1,r25
 918 007a 8093 0000 		sts g_state,r24
 919 007e 0895      		ret
 920               	.LBE128:
 921               	.LBE127:
 922               	.LBE126:
 923               		.cfi_endproc
 924               	.LFE45:
 926               		.section	.text.process_li_off,"ax",@progbits
 928               	process_li_off:
 929               	.LFB46:
 603:easyrider.c   **** void process_li_off() {
 930               		.loc 1 603 0
 931               		.cfi_startproc
 932               	/* prologue: function */
 933               	/* frame size = 0 */
 934               	/* stack size = 0 */
 935               	.L__stack_usage = 0
 604:easyrider.c   ****   if (FLAG_DEBOUNCE_LI) { // check for 3 positives based on 5ms timer
 936               		.loc 1 604 0
 937 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_LI
 938 0004 8823      		tst r24
 939 0006 01F0      		breq .L80
 605:easyrider.c   ****     g_li_debounce = (g_li_debounce << 1);
 940               		.loc 1 605 0
 941 0008 8091 0000 		lds r24,g_li_debounce
 942 000c 880F      		lsl r24
 943 000e 8093 0000 		sts g_li_debounce,r24
 606:easyrider.c   ****     FLAG_DEBOUNCE_LI = 0; // reset to wait for next timer event
 944               		.loc 1 606 0
 945 0012 1092 0000 		sts FLAG_DEBOUNCE_LI,__zero_reg__
 607:easyrider.c   ****     if (((g_li_debounce & 0b00000111) << 5) == 0) {
 946               		.loc 1 607 0
 947 0016 8091 0000 		lds r24,g_li_debounce
 948 001a 20E2      		ldi r18,lo8(32)
 949 001c 829F      		mul r24,r18
 950 001e C001      		movw r24,r0
 951 0020 1124      		clr __zero_reg__
 952 0022 9927      		clr r25
 953 0024 892B      		or r24,r25
 954 0026 01F4      		brne .L80
 955               	.LVL4:
 956               	.LBB133:
 957               	.LBB134:
 958               	.LBB135:
 959               	.LBB136:
  76:easyrider.c   ****   g_state &= ~st;
 960               		.loc 1 76 0
 961 0028 8091 0000 		lds r24,g_state
 962 002c 9091 0000 		lds r25,g_state+1
 963 0030 8B7F      		andi r24,251
 964 0032 9093 0000 		sts g_state+1,r25
 965 0036 8093 0000 		sts g_state,r24
 966               	.LBE136:
 967               	.LBE135:
 610:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
 968               		.loc 1 610 0
 969 003a 4198      		cbi 0x8,1
 611:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
 970               		.loc 1 611 0
 971 003c 4498      		cbi 0x8,4
 612:easyrider.c   ****       if (g_settings.indicator_sound) {
 972               		.loc 1 612 0
 973 003e 8091 0000 		lds r24,g_settings+6
 974 0042 8111      		cpse r24,__zero_reg__
 613:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 975               		.loc 1 613 0
 976 0044 5D98      		cbi 0xb,5
 977               	.L84:
 615:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 978               		.loc 1 615 0
 979 0046 4298      		cbi 0x8,2
 980               	.LVL5:
 981               	.L80:
 982 0048 0895      		ret
 983               	.LBE134:
 984               	.LBE133:
 985               		.cfi_endproc
 986               	.LFE46:
 988               		.section	.text.process_li_on,"ax",@progbits
 990               	process_li_on:
 991               	.LFB47:
 620:easyrider.c   **** void process_li_on() {
 992               		.loc 1 620 0
 993               		.cfi_startproc
 994               	/* prologue: function */
 995               	/* frame size = 0 */
 996               	/* stack size = 0 */
 997               	.L__stack_usage = 0
 621:easyrider.c   ****   if (FLAG_DEBOUNCE_LI) { // check for 3 positives based on 5ms timer
 998               		.loc 1 621 0
 999 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_LI
 1000 0004 8823      		tst r24
 1001 0006 01F0      		breq .L88
 622:easyrider.c   ****     g_li_debounce = (g_li_debounce << 1) | 0x01;
 1002               		.loc 1 622 0
 1003 0008 8091 0000 		lds r24,g_li_debounce
 1004 000c 880F      		lsl r24
 1005 000e 8160      		ori r24,lo8(1)
 1006 0010 8093 0000 		sts g_li_debounce,r24
 623:easyrider.c   ****     FLAG_DEBOUNCE_LI = 0; // reset to wait for next timer event
 1007               		.loc 1 623 0
 1008 0014 1092 0000 		sts FLAG_DEBOUNCE_LI,__zero_reg__
 624:easyrider.c   ****     if (((g_li_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_LI)) { // blink indicators
 1009               		.loc 1 624 0
 1010 0018 8091 0000 		lds r24,g_li_debounce
 1011 001c 8770      		andi r24,lo8(7)
 1012 001e 8730      		cpi r24,lo8(7)
 1013 0020 01F0      		breq .L99
 1014               	.L88:
 1015 0022 0895      		ret
 1016               	.L99:
 624:easyrider.c   ****     if (((g_li_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_LI)) { // blink indicators
 1017               		.loc 1 624 0 is_stmt 0 discriminator 1
 1018 0024 8091 0000 		lds r24,FLAG_BLINK_LI
 1019 0028 8823      		tst r24
 1020 002a 01F0      		breq .L88
 625:easyrider.c   ****       PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F); // front
 1021               		.loc 1 625 0 is_stmt 1
 1022 002c 88B1      		in r24,0x8
 1023 002e 92E0      		ldi r25,lo8(2)
 1024 0030 8927      		eor r24,r25
 1025 0032 88B9      		out 0x8,r24
 626:easyrider.c   ****       PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B); // rear
 1026               		.loc 1 626 0
 1027 0034 88B1      		in r24,0x8
 1028 0036 90E1      		ldi r25,lo8(16)
 1029 0038 8927      		eor r24,r25
 1030 003a 88B9      		out 0x8,r24
 627:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 1031               		.loc 1 627 0
 1032 003c 88B1      		in r24,0x8
 1033 003e 94E0      		ldi r25,lo8(4)
 1034 0040 8927      		eor r24,r25
 1035 0042 88B9      		out 0x8,r24
 628:easyrider.c   ****       if (g_settings.indicator_sound) {
 1036               		.loc 1 628 0
 1037 0044 8091 0000 		lds r24,g_settings+6
 1038 0048 8823      		tst r24
 1039 004a 01F0      		breq .L92
 629:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 1040               		.loc 1 629 0
 1041 004c 8BB1      		in r24,0xb
 1042 004e 90E2      		ldi r25,lo8(32)
 1043 0050 8927      		eor r24,r25
 1044 0052 8BB9      		out 0xb,r24
 1045               	.L92:
 631:easyrider.c   ****       FLAG_BLINK_LI = 0; // reset to wait for next timer event
 1046               		.loc 1 631 0
 1047 0054 1092 0000 		sts FLAG_BLINK_LI,__zero_reg__
 1048               	.LVL6:
 1049               	.LBB145:
 1050               	.LBB146:
  68:easyrider.c   ****   return (g_state & st);
 1051               		.loc 1 68 0
 1052 0058 8091 0000 		lds r24,g_state
 1053 005c 9091 0000 		lds r25,g_state+1
 1054               	.LBE146:
 1055               	.LBE145:
 632:easyrider.c   ****       if (!get_substate(ST_LI)) { // first time to blink
 1056               		.loc 1 632 0
 1057 0060 82FD      		sbrc r24,2
 1058 0062 00C0      		rjmp .L88
 1059               	.LBB147:
 633:easyrider.c   ****         TCNT1 = 0; // set 0.5 sec timer counter explicitly to 0, so the first blink happens exactly
 1060               		.loc 1 633 0
 1061 0064 1092 8500 		sts 132+1,__zero_reg__
 1062 0068 1092 8400 		sts 132,__zero_reg__
 1063               	.LVL7:
 1064               	.LBB148:
 1065               	.LBB149:
  72:easyrider.c   ****   g_state |= st;
 1066               		.loc 1 72 0
 1067 006c 8091 0000 		lds r24,g_state
 1068 0070 9091 0000 		lds r25,g_state+1
 1069 0074 8460      		ori r24,4
 1070 0076 9093 0000 		sts g_state+1,r25
 1071 007a 8093 0000 		sts g_state,r24
 1072 007e 0895      		ret
 1073               	.LBE149:
 1074               	.LBE148:
 1075               	.LBE147:
 1076               		.cfi_endproc
 1077               	.LFE47:
 1079               		.section	.text.process_claxon_on,"ax",@progbits
 1081               	process_claxon_on:
 1082               	.LFB48:
 640:easyrider.c   **** void process_claxon_on() {
 1083               		.loc 1 640 0
 1084               		.cfi_startproc
 1085               	/* prologue: function */
 1086               	/* frame size = 0 */
 1087               	/* stack size = 0 */
 1088               	.L__stack_usage = 0
 641:easyrider.c   ****   if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
 1089               		.loc 1 641 0
 1090 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_CLAXON
 1091 0004 8823      		tst r24
 1092 0006 01F0      		breq .L100
 642:easyrider.c   ****     g_claxon_debounce = (g_claxon_debounce << 1) | 0x01;
 1093               		.loc 1 642 0
 1094 0008 8091 0000 		lds r24,g_claxon_debounce
 1095 000c 880F      		lsl r24
 1096 000e 8160      		ori r24,lo8(1)
 1097 0010 8093 0000 		sts g_claxon_debounce,r24
 643:easyrider.c   ****     FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
 1098               		.loc 1 643 0
 1099 0014 1092 0000 		sts FLAG_DEBOUNCE_CLAXON,__zero_reg__
 644:easyrider.c   ****     if ((g_claxon_debounce & 0b00000111) == 0b00000111) { // start claxon
 1100               		.loc 1 644 0
 1101 0018 8091 0000 		lds r24,g_claxon_debounce
 1102 001c 8770      		andi r24,lo8(7)
 1103 001e 8730      		cpi r24,lo8(7)
 1104 0020 01F0      		breq .L104
 1105               	.L100:
 1106 0022 0895      		ret
 1107               	.L104:
 645:easyrider.c   ****       PORT_C90_CLAXON |= (1 << PIN_C90_CLAXON);
 1108               		.loc 1 645 0
 1109 0024 5E9A      		sbi 0xb,6
 1110               	.LVL8:
 1111               	.LBB158:
 1112               	.LBB159:
  68:easyrider.c   ****   return (g_state & st);
 1113               		.loc 1 68 0
 1114 0026 8091 0000 		lds r24,g_state
 1115 002a 9091 0000 		lds r25,g_state+1
 1116               	.LBE159:
 1117               	.LBE158:
 646:easyrider.c   ****       if (!get_substate(ST_CLAXON)) {
 1118               		.loc 1 646 0
 1119 002e 83FD      		sbrc r24,3
 1120 0030 00C0      		rjmp .L100
 1121               	.LVL9:
 1122               	.LBB160:
 1123               	.LBB161:
  72:easyrider.c   ****   g_state |= st;
 1124               		.loc 1 72 0
 1125 0032 8091 0000 		lds r24,g_state
 1126 0036 9091 0000 		lds r25,g_state+1
 1127 003a 8860      		ori r24,8
 1128 003c 9093 0000 		sts g_state+1,r25
 1129 0040 8093 0000 		sts g_state,r24
 1130 0044 0895      		ret
 1131               	.LBE161:
 1132               	.LBE160:
 1133               		.cfi_endproc
 1134               	.LFE48:
 1136               		.section	.text.process_claxon_off,"ax",@progbits
 1138               	process_claxon_off:
 1139               	.LFB49:
 653:easyrider.c   **** void process_claxon_off() {
 1140               		.loc 1 653 0
 1141               		.cfi_startproc
 1142               	/* prologue: function */
 1143               	/* frame size = 0 */
 1144               	/* stack size = 0 */
 1145               	.L__stack_usage = 0
 654:easyrider.c   ****   if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
 1146               		.loc 1 654 0
 1147 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_CLAXON
 1148 0004 8823      		tst r24
 1149 0006 01F0      		breq .L105
 655:easyrider.c   ****     g_claxon_debounce = (g_claxon_debounce << 1);
 1150               		.loc 1 655 0
 1151 0008 8091 0000 		lds r24,g_claxon_debounce
 1152 000c 880F      		lsl r24
 1153 000e 8093 0000 		sts g_claxon_debounce,r24
 656:easyrider.c   ****     FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
 1154               		.loc 1 656 0
 1155 0012 1092 0000 		sts FLAG_DEBOUNCE_CLAXON,__zero_reg__
 657:easyrider.c   ****     if (((g_claxon_debounce & 0b00000111) << 5) == 0) {
 1156               		.loc 1 657 0
 1157 0016 8091 0000 		lds r24,g_claxon_debounce
 1158 001a 20E2      		ldi r18,lo8(32)
 1159 001c 829F      		mul r24,r18
 1160 001e C001      		movw r24,r0
 1161 0020 1124      		clr __zero_reg__
 1162 0022 9927      		clr r25
 1163 0024 892B      		or r24,r25
 1164 0026 01F4      		brne .L105
 1165               	.LVL10:
 1166               	.LBB166:
 1167               	.LBB167:
 1168               	.LBB168:
  76:easyrider.c   ****   g_state &= ~st;
 1169               		.loc 1 76 0
 1170 0028 8091 0000 		lds r24,g_state
 1171 002c 9091 0000 		lds r25,g_state+1
 1172 0030 877F      		andi r24,247
 1173 0032 9093 0000 		sts g_state+1,r25
 1174 0036 8093 0000 		sts g_state,r24
 1175               	.LBE168:
 1176               	.LBE167:
 659:easyrider.c   ****       PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
 1177               		.loc 1 659 0
 1178 003a 5E98      		cbi 0xb,6
 1179               	.LVL11:
 1180               	.L105:
 1181 003c 0895      		ret
 1182               	.LBE166:
 1183               		.cfi_endproc
 1184               	.LFE49:
 1186               		.section	.text.process_warning_on,"ax",@progbits
 1188               	process_warning_on:
 1189               	.LFB50:
 664:easyrider.c   **** void process_warning_on() {
 1190               		.loc 1 664 0
 1191               		.cfi_startproc
 1192               	/* prologue: function */
 1193               	/* frame size = 0 */
 1194               	/* stack size = 0 */
 1195               	.L__stack_usage = 0
 665:easyrider.c   ****   if (FLAG_DEBOUNCE_WARNING) { // check for 3 positives based on 5ms timer
 1196               		.loc 1 665 0
 1197 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_WARNING
 1198 0004 8823      		tst r24
 1199 0006 01F0      		breq .L109
 666:easyrider.c   ****     g_warning_debounce = (g_warning_debounce << 1) | 0x01;
 1200               		.loc 1 666 0
 1201 0008 8091 0000 		lds r24,g_warning_debounce
 1202 000c 880F      		lsl r24
 1203 000e 8160      		ori r24,lo8(1)
 1204 0010 8093 0000 		sts g_warning_debounce,r24
 667:easyrider.c   ****     FLAG_DEBOUNCE_WARNING = 0; // reset to wait for next timer event
 1205               		.loc 1 667 0
 1206 0014 1092 0000 		sts FLAG_DEBOUNCE_WARNING,__zero_reg__
 668:easyrider.c   ****     if (((g_warning_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_WARNING)) { // blink indic
 1207               		.loc 1 668 0
 1208 0018 8091 0000 		lds r24,g_warning_debounce
 1209 001c 8770      		andi r24,lo8(7)
 1210 001e 8730      		cpi r24,lo8(7)
 1211 0020 01F0      		breq .L120
 1212               	.L109:
 1213 0022 0895      		ret
 1214               	.L120:
 668:easyrider.c   ****     if (((g_warning_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_WARNING)) { // blink indic
 1215               		.loc 1 668 0 is_stmt 0 discriminator 1
 1216 0024 8091 0000 		lds r24,FLAG_BLINK_WARNING
 1217 0028 8823      		tst r24
 1218 002a 01F0      		breq .L109
 1219               	.LBB175:
 1220               	.LBB176:
 669:easyrider.c   ****       PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 1221               		.loc 1 669 0 is_stmt 1
 1222 002c 88B1      		in r24,0x8
 1223 002e 91E0      		ldi r25,lo8(1)
 1224 0030 8927      		eor r24,r25
 1225 0032 88B9      		out 0x8,r24
 670:easyrider.c   ****       PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 1226               		.loc 1 670 0
 1227 0034 88B1      		in r24,0x8
 1228 0036 98E0      		ldi r25,lo8(8)
 1229 0038 8927      		eor r24,r25
 1230 003a 88B9      		out 0x8,r24
 671:easyrider.c   ****       PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
 1231               		.loc 1 671 0
 1232 003c 88B1      		in r24,0x8
 1233 003e 92E0      		ldi r25,lo8(2)
 1234 0040 8927      		eor r24,r25
 1235 0042 88B9      		out 0x8,r24
 672:easyrider.c   ****       PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
 1236               		.loc 1 672 0
 1237 0044 88B1      		in r24,0x8
 1238 0046 90E1      		ldi r25,lo8(16)
 1239 0048 8927      		eor r24,r25
 1240 004a 88B9      		out 0x8,r24
 673:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 1241               		.loc 1 673 0
 1242 004c 88B1      		in r24,0x8
 1243 004e 94E0      		ldi r25,lo8(4)
 1244 0050 8927      		eor r24,r25
 1245 0052 88B9      		out 0x8,r24
 674:easyrider.c   ****       if (g_settings.indicator_sound) {
 1246               		.loc 1 674 0
 1247 0054 8091 0000 		lds r24,g_settings+6
 1248 0058 8823      		tst r24
 1249 005a 01F0      		breq .L113
 675:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 1250               		.loc 1 675 0
 1251 005c 8BB1      		in r24,0xb
 1252 005e 90E2      		ldi r25,lo8(32)
 1253 0060 8927      		eor r24,r25
 1254 0062 8BB9      		out 0xb,r24
 1255               	.L113:
 677:easyrider.c   ****       FLAG_BLINK_WARNING = 0; // reset to wait for next timer event
 1256               		.loc 1 677 0
 1257 0064 1092 0000 		sts FLAG_BLINK_WARNING,__zero_reg__
 1258               	.LVL12:
 1259               	.LBB177:
 1260               	.LBB178:
  68:easyrider.c   ****   return (g_state & st);
 1261               		.loc 1 68 0
 1262 0068 8091 0000 		lds r24,g_state
 1263 006c 9091 0000 		lds r25,g_state+1
 1264               	.LBE178:
 1265               	.LBE177:
 678:easyrider.c   ****       if (!get_substate(ST_WARNING)) { // first time to blink
 1266               		.loc 1 678 0
 1267 0070 93FD      		sbrc r25,3
 1268 0072 00C0      		rjmp .L109
 679:easyrider.c   ****         TCNT1 = 0; // reset timer so the blink starts in an even pace
 1269               		.loc 1 679 0
 1270 0074 1092 8500 		sts 132+1,__zero_reg__
 1271 0078 1092 8400 		sts 132,__zero_reg__
 681:easyrider.c   ****         PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
 1272               		.loc 1 681 0
 1273 007c 409A      		sbi 0x8,0
 682:easyrider.c   ****         PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
 1274               		.loc 1 682 0
 1275 007e 439A      		sbi 0x8,3
 683:easyrider.c   ****         PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
 1276               		.loc 1 683 0
 1277 0080 419A      		sbi 0x8,1
 684:easyrider.c   ****         PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
 1278               		.loc 1 684 0
 1279 0082 449A      		sbi 0x8,4
 685:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 1280               		.loc 1 685 0
 1281 0084 429A      		sbi 0x8,2
 1282               	.LVL13:
 1283               	.LBB179:
 1284               	.LBB180:
  72:easyrider.c   ****   g_state |= st;
 1285               		.loc 1 72 0
 1286 0086 8091 0000 		lds r24,g_state
 1287 008a 9091 0000 		lds r25,g_state+1
 1288 008e 9860      		ori r25,8
 1289 0090 9093 0000 		sts g_state+1,r25
 1290 0094 8093 0000 		sts g_state,r24
 1291 0098 0895      		ret
 1292               	.LBE180:
 1293               	.LBE179:
 1294               	.LBE176:
 1295               	.LBE175:
 1296               		.cfi_endproc
 1297               	.LFE50:
 1299               		.section	.text.process_warning_off,"ax",@progbits
 1301               	process_warning_off:
 1302               	.LFB51:
 692:easyrider.c   **** void process_warning_off() {
 1303               		.loc 1 692 0
 1304               		.cfi_startproc
 1305               	/* prologue: function */
 1306               	/* frame size = 0 */
 1307               	/* stack size = 0 */
 1308               	.L__stack_usage = 0
 693:easyrider.c   ****   if (FLAG_DEBOUNCE_WARNING) { // check for 3 positives based on 5ms timer
 1309               		.loc 1 693 0
 1310 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_WARNING
 1311 0004 8823      		tst r24
 1312 0006 01F0      		breq .L121
 694:easyrider.c   ****     g_warning_debounce = (g_warning_debounce << 1);
 1313               		.loc 1 694 0
 1314 0008 8091 0000 		lds r24,g_warning_debounce
 1315 000c 880F      		lsl r24
 1316 000e 8093 0000 		sts g_warning_debounce,r24
 695:easyrider.c   ****     FLAG_DEBOUNCE_WARNING = 0; // reset to wait for next timer event
 1317               		.loc 1 695 0
 1318 0012 1092 0000 		sts FLAG_DEBOUNCE_WARNING,__zero_reg__
 696:easyrider.c   ****     if (((g_warning_debounce & 0b00000111) << 5) == 0) {
 1319               		.loc 1 696 0
 1320 0016 8091 0000 		lds r24,g_warning_debounce
 1321 001a 20E2      		ldi r18,lo8(32)
 1322 001c 829F      		mul r24,r18
 1323 001e C001      		movw r24,r0
 1324 0020 1124      		clr __zero_reg__
 1325 0022 9927      		clr r25
 1326 0024 892B      		or r24,r25
 1327 0026 01F4      		brne .L121
 1328               	.LVL14:
 1329               	.LBB185:
 1330               	.LBB186:
 1331               	.LBB187:
 1332               	.LBB188:
  76:easyrider.c   ****   g_state &= ~st;
 1333               		.loc 1 76 0
 1334 0028 8091 0000 		lds r24,g_state
 1335 002c 9091 0000 		lds r25,g_state+1
 1336 0030 977F      		andi r25,247
 1337 0032 9093 0000 		sts g_state+1,r25
 1338 0036 8093 0000 		sts g_state,r24
 1339               	.LBE188:
 1340               	.LBE187:
 699:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
 1341               		.loc 1 699 0
 1342 003a 4198      		cbi 0x8,1
 700:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
 1343               		.loc 1 700 0
 1344 003c 4498      		cbi 0x8,4
 701:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
 1345               		.loc 1 701 0
 1346 003e 4098      		cbi 0x8,0
 702:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
 1347               		.loc 1 702 0
 1348 0040 4398      		cbi 0x8,3
 703:easyrider.c   ****       if (g_settings.indicator_sound) {
 1349               		.loc 1 703 0
 1350 0042 8091 0000 		lds r24,g_settings+6
 1351 0046 8111      		cpse r24,__zero_reg__
 704:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 1352               		.loc 1 704 0
 1353 0048 5D98      		cbi 0xb,5
 1354               	.L125:
 706:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 1355               		.loc 1 706 0
 1356 004a 4298      		cbi 0x8,2
 1357               	.LVL15:
 1358               	.L121:
 1359 004c 0895      		ret
 1360               	.LBE186:
 1361               	.LBE185:
 1362               		.cfi_endproc
 1363               	.LFE51:
 1365               		.section	.text.process_backpedal,"ax",@progbits
 1367               	process_backpedal:
 1368               	.LFB52:
 712:easyrider.c   **** void process_backpedal() {
 1369               		.loc 1 712 0
 1370               		.cfi_startproc
 1371               	/* prologue: function */
 1372               	/* frame size = 0 */
 1373               	/* stack size = 0 */
 1374               	.L__stack_usage = 0
 713:easyrider.c   ****   if (FLAG_READ_BACKPEDAL) {
 1375               		.loc 1 713 0
 1376 0000 8091 0000 		lds r24,FLAG_READ_BACKPEDAL
 1377 0004 8823      		tst r24
 1378 0006 01F0      		breq .L129
 1379               	.LBB191:
 1380               	.LBB192:
 714:easyrider.c   ****     FLAG_READ_BACKPEDAL = 0; // reset to wait for next timer event
 1381               		.loc 1 714 0
 1382 0008 1092 0000 		sts FLAG_READ_BACKPEDAL,__zero_reg__
 715:easyrider.c   ****     if ((g_adc_voltage[2] < g_settings.backpedal_thres_min) && FLAG_BLINK_BACKPEDAL) {
 1383               		.loc 1 715 0
 1384 000c 2091 0000 		lds r18,g_adc_voltage+4
 1385 0010 3091 0000 		lds r19,g_adc_voltage+4+1
 1386 0014 8091 0000 		lds r24,g_settings+16
 1387 0018 9091 0000 		lds r25,g_settings+16+1
 1388 001c 2817      		cp r18,r24
 1389 001e 3907      		cpc r19,r25
 1390 0020 00F0      		brlo .L151
 1391               	.L132:
 726:easyrider.c   ****     } else if ((g_adc_voltage[2] >= g_settings.backpedal_thres_min) && FLAG_BACKPEDAL && FLAG_BLINK
 1392               		.loc 1 726 0
 1393 0022 2091 0000 		lds r18,g_adc_voltage+4
 1394 0026 3091 0000 		lds r19,g_adc_voltage+4+1
 1395 002a 2817      		cp r18,r24
 1396 002c 3907      		cpc r19,r25
 1397 002e 00F0      		brlo .L129
 1398 0030 8091 0000 		lds r24,FLAG_BACKPEDAL
 1399 0034 8823      		tst r24
 1400 0036 01F0      		breq .L129
 1401 0038 8091 0000 		lds r24,FLAG_BLINK_BACKPEDAL
 1402 003c 8823      		tst r24
 1403 003e 01F0      		breq .L129
 727:easyrider.c   ****       FLAG_BACKPEDAL = 0;
 1404               		.loc 1 727 0
 1405 0040 1092 0000 		sts FLAG_BACKPEDAL,__zero_reg__
 728:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
 1406               		.loc 1 728 0
 1407 0044 4198      		cbi 0x8,1
 729:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
 1408               		.loc 1 729 0
 1409 0046 4498      		cbi 0x8,4
 730:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
 1410               		.loc 1 730 0
 1411 0048 4098      		cbi 0x8,0
 731:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
 1412               		.loc 1 731 0
 1413 004a 4398      		cbi 0x8,3
 732:easyrider.c   ****       if (g_settings.indicator_sound) {
 1414               		.loc 1 732 0
 1415 004c 8091 0000 		lds r24,g_settings+6
 1416 0050 8111      		cpse r24,__zero_reg__
 733:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 1417               		.loc 1 733 0
 1418 0052 5D98      		cbi 0xb,5
 1419               	.L135:
 735:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
 1420               		.loc 1 735 0
 1421 0054 4298      		cbi 0x8,2
 1422               	.L129:
 1423 0056 0895      		ret
 1424               	.L151:
 715:easyrider.c   ****     if ((g_adc_voltage[2] < g_settings.backpedal_thres_min) && FLAG_BLINK_BACKPEDAL) {
 1425               		.loc 1 715 0
 1426 0058 2091 0000 		lds r18,FLAG_BLINK_BACKPEDAL
 1427 005c 2223      		tst r18
 1428 005e 01F0      		breq .L132
 716:easyrider.c   ****       FLAG_BACKPEDAL = 1;
 1429               		.loc 1 716 0
 1430 0060 91E0      		ldi r25,lo8(1)
 1431 0062 9093 0000 		sts FLAG_BACKPEDAL,r25
 717:easyrider.c   ****       PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 1432               		.loc 1 717 0
 1433 0066 88B1      		in r24,0x8
 1434 0068 8927      		eor r24,r25
 1435 006a 88B9      		out 0x8,r24
 718:easyrider.c   ****       PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 1436               		.loc 1 718 0
 1437 006c 88B1      		in r24,0x8
 1438 006e 98E0      		ldi r25,lo8(8)
 1439 0070 8927      		eor r24,r25
 1440 0072 88B9      		out 0x8,r24
 719:easyrider.c   ****       PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
 1441               		.loc 1 719 0
 1442 0074 88B1      		in r24,0x8
 1443 0076 92E0      		ldi r25,lo8(2)
 1444 0078 8927      		eor r24,r25
 1445 007a 88B9      		out 0x8,r24
 720:easyrider.c   ****       PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
 1446               		.loc 1 720 0
 1447 007c 88B1      		in r24,0x8
 1448 007e 90E1      		ldi r25,lo8(16)
 1449 0080 8927      		eor r24,r25
 1450 0082 88B9      		out 0x8,r24
 721:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 1451               		.loc 1 721 0
 1452 0084 88B1      		in r24,0x8
 1453 0086 94E0      		ldi r25,lo8(4)
 1454 0088 8927      		eor r24,r25
 1455 008a 88B9      		out 0x8,r24
 722:easyrider.c   ****       if (g_settings.indicator_sound) {
 1456               		.loc 1 722 0
 1457 008c 8091 0000 		lds r24,g_settings+6
 1458 0090 8823      		tst r24
 1459 0092 01F0      		breq .L133
 723:easyrider.c   ****         PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 1460               		.loc 1 723 0
 1461 0094 8BB1      		in r24,0xb
 1462 0096 90E2      		ldi r25,lo8(32)
 1463 0098 8927      		eor r24,r25
 1464 009a 8BB9      		out 0xb,r24
 1465               	.L133:
 725:easyrider.c   ****       FLAG_BLINK_BACKPEDAL = 0;
 1466               		.loc 1 725 0
 1467 009c 1092 0000 		sts FLAG_BLINK_BACKPEDAL,__zero_reg__
 1468 00a0 0895      		ret
 1469               	.LBE192:
 1470               	.LBE191:
 1471               		.cfi_endproc
 1472               	.LFE52:
 1474               		.section	.text.process_ign_on,"ax",@progbits
 1476               	process_ign_on:
 1477               	.LFB53:
 740:easyrider.c   **** void process_ign_on() {
 1478               		.loc 1 740 0
 1479               		.cfi_startproc
 1480               	/* prologue: function */
 1481               	/* frame size = 0 */
 1482               	/* stack size = 0 */
 1483               	.L__stack_usage = 0
 741:easyrider.c   ****   if (FLAG_DEBOUNCE_IGN) { // check for 3 positives based on 5ms timer
 1484               		.loc 1 741 0
 1485 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_IGN
 1486 0004 8823      		tst r24
 1487 0006 01F0      		breq .L152
 1488               	.LBB195:
 742:easyrider.c   ****     g_ign_debounce= (g_ign_debounce << 1) | 0x01;
 1489               		.loc 1 742 0
 1490 0008 8091 0000 		lds r24,g_ign_debounce
 1491 000c 880F      		lsl r24
 1492 000e 8160      		ori r24,lo8(1)
 1493 0010 8093 0000 		sts g_ign_debounce,r24
 743:easyrider.c   ****     FLAG_DEBOUNCE_IGN = 0; // reset to wait for next timer event
 1494               		.loc 1 743 0
 1495 0014 1092 0000 		sts FLAG_DEBOUNCE_IGN,__zero_reg__
 744:easyrider.c   ****     if ((g_ign_debounce & 0b00000111) == 0b00000111) {
 1496               		.loc 1 744 0
 1497 0018 8091 0000 		lds r24,g_ign_debounce
 1498 001c 8770      		andi r24,lo8(7)
 1499 001e 8730      		cpi r24,lo8(7)
 1500 0020 01F0      		breq .L156
 1501               	.L152:
 1502 0022 0895      		ret
 1503               	.L156:
 745:easyrider.c   ****       g_state = ST_SETTLE;
 1504               		.loc 1 745 0
 1505 0024 80E0      		ldi r24,0
 1506 0026 94E0      		ldi r25,lo8(4)
 1507 0028 9093 0000 		sts g_state+1,r25
 1508 002c 8093 0000 		sts g_state,r24
 1509 0030 0895      		ret
 1510               	.LBE195:
 1511               		.cfi_endproc
 1512               	.LFE53:
 1514               		.section	.text.process_brake_on,"ax",@progbits
 1516               	process_brake_on:
 1517               	.LFB55:
 763:easyrider.c   **** void process_brake_on() {
 1518               		.loc 1 763 0
 1519               		.cfi_startproc
 1520               	/* prologue: function */
 1521               	/* frame size = 0 */
 1522               	/* stack size = 0 */
 1523               	.L__stack_usage = 0
 764:easyrider.c   ****   if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
 1524               		.loc 1 764 0
 1525 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_BRAKE
 1526 0004 8823      		tst r24
 1527 0006 01F0      		breq .L157
 765:easyrider.c   ****     g_brake_debounce = (g_brake_debounce << 1) | 0x01;
 1528               		.loc 1 765 0
 1529 0008 8091 0000 		lds r24,g_brake_debounce
 1530 000c 880F      		lsl r24
 1531 000e 8160      		ori r24,lo8(1)
 1532 0010 8093 0000 		sts g_brake_debounce,r24
 766:easyrider.c   ****     FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
 1533               		.loc 1 766 0
 1534 0014 1092 0000 		sts FLAG_DEBOUNCE_BRAKE,__zero_reg__
 767:easyrider.c   ****     if ((g_brake_debounce & 0b00000111) == 0b00000111) { // start brake
 1535               		.loc 1 767 0
 1536 0018 8091 0000 		lds r24,g_brake_debounce
 1537 001c 8770      		andi r24,lo8(7)
 1538 001e 8730      		cpi r24,lo8(7)
 1539 0020 01F0      		breq .L161
 1540               	.L157:
 1541 0022 0895      		ret
 1542               	.L161:
 768:easyrider.c   ****       PORT_C90_BRAKE |= (1 << PIN_C90_BRAKE);
 1543               		.loc 1 768 0
 1544 0024 479A      		sbi 0x8,7
 1545               	.LVL16:
 1546               	.LBB204:
 1547               	.LBB205:
  68:easyrider.c   ****   return (g_state & st);
 1548               		.loc 1 68 0
 1549 0026 8091 0000 		lds r24,g_state
 1550 002a 9091 0000 		lds r25,g_state+1
 1551               	.LBE205:
 1552               	.LBE204:
 769:easyrider.c   ****       if (!get_substate(ST_BRAKE)) {
 1553               		.loc 1 769 0
 1554 002e 84FD      		sbrc r24,4
 1555 0030 00C0      		rjmp .L157
 1556               	.LVL17:
 1557               	.LBB206:
 1558               	.LBB207:
  72:easyrider.c   ****   g_state |= st;
 1559               		.loc 1 72 0
 1560 0032 8091 0000 		lds r24,g_state
 1561 0036 9091 0000 		lds r25,g_state+1
 1562 003a 8061      		ori r24,16
 1563 003c 9093 0000 		sts g_state+1,r25
 1564 0040 8093 0000 		sts g_state,r24
 1565 0044 0895      		ret
 1566               	.LBE207:
 1567               	.LBE206:
 1568               		.cfi_endproc
 1569               	.LFE55:
 1571               		.section	.text.process_brake_off,"ax",@progbits
 1573               	process_brake_off:
 1574               	.LFB56:
 776:easyrider.c   **** void process_brake_off() {
 1575               		.loc 1 776 0
 1576               		.cfi_startproc
 1577               	/* prologue: function */
 1578               	/* frame size = 0 */
 1579               	/* stack size = 0 */
 1580               	.L__stack_usage = 0
 777:easyrider.c   ****   if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
 1581               		.loc 1 777 0
 1582 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_BRAKE
 1583 0004 8823      		tst r24
 1584 0006 01F0      		breq .L162
 778:easyrider.c   ****     g_brake_debounce = (g_brake_debounce << 1);
 1585               		.loc 1 778 0
 1586 0008 8091 0000 		lds r24,g_brake_debounce
 1587 000c 880F      		lsl r24
 1588 000e 8093 0000 		sts g_brake_debounce,r24
 779:easyrider.c   ****     FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
 1589               		.loc 1 779 0
 1590 0012 1092 0000 		sts FLAG_DEBOUNCE_BRAKE,__zero_reg__
 780:easyrider.c   ****     if (((g_brake_debounce & 0b00000111) << 5) == 0) {
 1591               		.loc 1 780 0
 1592 0016 8091 0000 		lds r24,g_brake_debounce
 1593 001a 20E2      		ldi r18,lo8(32)
 1594 001c 829F      		mul r24,r18
 1595 001e C001      		movw r24,r0
 1596 0020 1124      		clr __zero_reg__
 1597 0022 9927      		clr r25
 1598 0024 892B      		or r24,r25
 1599 0026 01F4      		brne .L162
 1600               	.LVL18:
 1601               	.LBB212:
 1602               	.LBB213:
 1603               	.LBB214:
  76:easyrider.c   ****   g_state &= ~st;
 1604               		.loc 1 76 0
 1605 0028 8091 0000 		lds r24,g_state
 1606 002c 9091 0000 		lds r25,g_state+1
 1607 0030 8F7E      		andi r24,239
 1608 0032 9093 0000 		sts g_state+1,r25
 1609 0036 8093 0000 		sts g_state,r24
 1610               	.LBE214:
 1611               	.LBE213:
 782:easyrider.c   ****       PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE); // disable brake
 1612               		.loc 1 782 0
 1613 003a 4798      		cbi 0x8,7
 1614               	.LVL19:
 1615               	.L162:
 1616 003c 0895      		ret
 1617               	.LBE212:
 1618               		.cfi_endproc
 1619               	.LFE56:
 1621               		.section	.text.process_pilot_on,"ax",@progbits
 1623               	process_pilot_on:
 1624               	.LFB57:
 787:easyrider.c   **** void process_pilot_on() {
 1625               		.loc 1 787 0
 1626               		.cfi_startproc
 1627               	/* prologue: function */
 1628               	/* frame size = 0 */
 1629               	/* stack size = 0 */
 1630               	.L__stack_usage = 0
 788:easyrider.c   ****   if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
 1631               		.loc 1 788 0
 1632 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_PILOT
 1633 0004 8823      		tst r24
 1634 0006 01F0      		breq .L166
 789:easyrider.c   ****     g_pilot_debounce = (g_pilot_debounce << 1) | 0x01;
 1635               		.loc 1 789 0
 1636 0008 8091 0000 		lds r24,g_pilot_debounce
 1637 000c 880F      		lsl r24
 1638 000e 8160      		ori r24,lo8(1)
 1639 0010 8093 0000 		sts g_pilot_debounce,r24
 790:easyrider.c   ****     FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
 1640               		.loc 1 790 0
 1641 0014 1092 0000 		sts FLAG_DEBOUNCE_PILOT,__zero_reg__
 791:easyrider.c   ****     if ((g_pilot_debounce & 0b00000111) == 0b00000111) { // start pilot
 1642               		.loc 1 791 0
 1643 0018 8091 0000 		lds r24,g_pilot_debounce
 1644 001c 8770      		andi r24,lo8(7)
 1645 001e 8730      		cpi r24,lo8(7)
 1646 0020 01F0      		breq .L170
 1647               	.L166:
 1648 0022 0895      		ret
 1649               	.L170:
 792:easyrider.c   ****       PORT_C90_PILOT |= (1 << PIN_C90_PILOT);
 1650               		.loc 1 792 0
 1651 0024 5F9A      		sbi 0xb,7
 1652               	.LVL20:
 1653               	.LBB223:
 1654               	.LBB224:
  68:easyrider.c   ****   return (g_state & st);
 1655               		.loc 1 68 0
 1656 0026 8091 0000 		lds r24,g_state
 1657 002a 9091 0000 		lds r25,g_state+1
 1658               	.LBE224:
 1659               	.LBE223:
 793:easyrider.c   ****       if (!get_substate(ST_PILOT)) {
 1660               		.loc 1 793 0
 1661 002e 87FD      		sbrc r24,7
 1662 0030 00C0      		rjmp .L166
 1663               	.LVL21:
 1664               	.LBB225:
 1665               	.LBB226:
  72:easyrider.c   ****   g_state |= st;
 1666               		.loc 1 72 0
 1667 0032 8091 0000 		lds r24,g_state
 1668 0036 9091 0000 		lds r25,g_state+1
 1669 003a 8068      		ori r24,128
 1670 003c 9093 0000 		sts g_state+1,r25
 1671 0040 8093 0000 		sts g_state,r24
 1672 0044 0895      		ret
 1673               	.LBE226:
 1674               	.LBE225:
 1675               		.cfi_endproc
 1676               	.LFE57:
 1678               		.section	.text.process_pilot_off,"ax",@progbits
 1680               	process_pilot_off:
 1681               	.LFB58:
 800:easyrider.c   **** void process_pilot_off() {
 1682               		.loc 1 800 0
 1683               		.cfi_startproc
 1684               	/* prologue: function */
 1685               	/* frame size = 0 */
 1686               	/* stack size = 0 */
 1687               	.L__stack_usage = 0
 801:easyrider.c   ****   if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
 1688               		.loc 1 801 0
 1689 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_PILOT
 1690 0004 8823      		tst r24
 1691 0006 01F0      		breq .L171
 802:easyrider.c   ****     g_pilot_debounce = (g_pilot_debounce << 1);
 1692               		.loc 1 802 0
 1693 0008 8091 0000 		lds r24,g_pilot_debounce
 1694 000c 880F      		lsl r24
 1695 000e 8093 0000 		sts g_pilot_debounce,r24
 803:easyrider.c   ****     FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
 1696               		.loc 1 803 0
 1697 0012 1092 0000 		sts FLAG_DEBOUNCE_PILOT,__zero_reg__
 804:easyrider.c   ****     if (((g_pilot_debounce & 0b00000111) << 5) == 0) {
 1698               		.loc 1 804 0
 1699 0016 8091 0000 		lds r24,g_pilot_debounce
 1700 001a 20E2      		ldi r18,lo8(32)
 1701 001c 829F      		mul r24,r18
 1702 001e C001      		movw r24,r0
 1703 0020 1124      		clr __zero_reg__
 1704 0022 9927      		clr r25
 1705 0024 892B      		or r24,r25
 1706 0026 01F4      		brne .L171
 1707               	.LVL22:
 1708               	.LBB231:
 1709               	.LBB232:
 1710               	.LBB233:
  76:easyrider.c   ****   g_state &= ~st;
 1711               		.loc 1 76 0
 1712 0028 8091 0000 		lds r24,g_state
 1713 002c 9091 0000 		lds r25,g_state+1
 1714 0030 8F77      		andi r24,127
 1715 0032 9093 0000 		sts g_state+1,r25
 1716 0036 8093 0000 		sts g_state,r24
 1717               	.LBE233:
 1718               	.LBE232:
 806:easyrider.c   ****       PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT); // disable pilot
 1719               		.loc 1 806 0
 1720 003a 5F98      		cbi 0xb,7
 1721               	.LVL23:
 1722               	.L171:
 1723 003c 0895      		ret
 1724               	.LBE231:
 1725               		.cfi_endproc
 1726               	.LFE58:
 1728               		.section	.text.process_light_on,"ax",@progbits
 1730               	process_light_on:
 1731               	.LFB59:
 811:easyrider.c   **** void process_light_on() {
 1732               		.loc 1 811 0
 1733               		.cfi_startproc
 1734               	/* prologue: function */
 1735               	/* frame size = 0 */
 1736               	/* stack size = 0 */
 1737               	.L__stack_usage = 0
 812:easyrider.c   ****   if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
 1738               		.loc 1 812 0
 1739 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_LIGHT
 1740 0004 8823      		tst r24
 1741 0006 01F0      		breq .L175
 813:easyrider.c   ****     g_light_debounce = (g_light_debounce << 1) | 0x01;
 1742               		.loc 1 813 0
 1743 0008 8091 0000 		lds r24,g_light_debounce
 1744 000c 880F      		lsl r24
 1745 000e 8160      		ori r24,lo8(1)
 1746 0010 8093 0000 		sts g_light_debounce,r24
 814:easyrider.c   ****     FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
 1747               		.loc 1 814 0
 1748 0014 1092 0000 		sts FLAG_DEBOUNCE_LIGHT,__zero_reg__
 815:easyrider.c   ****     if ((g_light_debounce & 0b00000111) == 0b00000111) { // start light
 1749               		.loc 1 815 0
 1750 0018 8091 0000 		lds r24,g_light_debounce
 1751 001c 8770      		andi r24,lo8(7)
 1752 001e 8730      		cpi r24,lo8(7)
 1753 0020 01F0      		breq .L179
 1754               	.L175:
 1755 0022 0895      		ret
 1756               	.L179:
 816:easyrider.c   ****       PORT_C90_LIGHT |= (1 << PIN_C90_LIGHT);
 1757               		.loc 1 816 0
 1758 0024 469A      		sbi 0x8,6
 1759               	.LVL24:
 1760               	.LBB242:
 1761               	.LBB243:
  68:easyrider.c   ****   return (g_state & st);
 1762               		.loc 1 68 0
 1763 0026 8091 0000 		lds r24,g_state
 1764 002a 9091 0000 		lds r25,g_state+1
 1765               	.LBE243:
 1766               	.LBE242:
 817:easyrider.c   ****       if (!get_substate(ST_LIGHT)) {
 1767               		.loc 1 817 0
 1768 002e 85FD      		sbrc r24,5
 1769 0030 00C0      		rjmp .L175
 1770               	.LVL25:
 1771               	.LBB244:
 1772               	.LBB245:
  72:easyrider.c   ****   g_state |= st;
 1773               		.loc 1 72 0
 1774 0032 8091 0000 		lds r24,g_state
 1775 0036 9091 0000 		lds r25,g_state+1
 1776 003a 8062      		ori r24,32
 1777 003c 9093 0000 		sts g_state+1,r25
 1778 0040 8093 0000 		sts g_state,r24
 1779 0044 0895      		ret
 1780               	.LBE245:
 1781               	.LBE244:
 1782               		.cfi_endproc
 1783               	.LFE59:
 1785               		.section	.text.process_light_off,"ax",@progbits
 1787               	process_light_off:
 1788               	.LFB60:
 824:easyrider.c   **** void process_light_off() {
 1789               		.loc 1 824 0
 1790               		.cfi_startproc
 1791               	/* prologue: function */
 1792               	/* frame size = 0 */
 1793               	/* stack size = 0 */
 1794               	.L__stack_usage = 0
 825:easyrider.c   ****   if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
 1795               		.loc 1 825 0
 1796 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_LIGHT
 1797 0004 8823      		tst r24
 1798 0006 01F0      		breq .L180
 826:easyrider.c   ****     g_light_debounce = (g_light_debounce << 1);
 1799               		.loc 1 826 0
 1800 0008 8091 0000 		lds r24,g_light_debounce
 1801 000c 880F      		lsl r24
 1802 000e 8093 0000 		sts g_light_debounce,r24
 827:easyrider.c   ****     FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
 1803               		.loc 1 827 0
 1804 0012 1092 0000 		sts FLAG_DEBOUNCE_LIGHT,__zero_reg__
 828:easyrider.c   ****     if (((g_light_debounce & 0b00000111) << 5) == 0) {
 1805               		.loc 1 828 0
 1806 0016 8091 0000 		lds r24,g_light_debounce
 1807 001a 20E2      		ldi r18,lo8(32)
 1808 001c 829F      		mul r24,r18
 1809 001e C001      		movw r24,r0
 1810 0020 1124      		clr __zero_reg__
 1811 0022 9927      		clr r25
 1812 0024 892B      		or r24,r25
 1813 0026 01F4      		brne .L180
 1814               	.LVL26:
 1815               	.LBB250:
 1816               	.LBB251:
 1817               	.LBB252:
  76:easyrider.c   ****   g_state &= ~st;
 1818               		.loc 1 76 0
 1819 0028 8091 0000 		lds r24,g_state
 1820 002c 9091 0000 		lds r25,g_state+1
 1821 0030 8F7D      		andi r24,223
 1822 0032 9093 0000 		sts g_state+1,r25
 1823 0036 8093 0000 		sts g_state,r24
 1824               	.LBE252:
 1825               	.LBE251:
 830:easyrider.c   ****       PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT); // disable light
 1826               		.loc 1 830 0
 1827 003a 4698      		cbi 0x8,6
 1828               	.LVL27:
 1829               	.L180:
 1830 003c 0895      		ret
 1831               	.LBE250:
 1832               		.cfi_endproc
 1833               	.LFE60:
 1835               		.section	.text.process_alarm_on,"ax",@progbits
 1837               	process_alarm_on:
 1838               	.LFB62:
 847:easyrider.c   **** void process_alarm_on() {
 1839               		.loc 1 847 0
 1840               		.cfi_startproc
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 0 */
 1844               	.L__stack_usage = 0
 848:easyrider.c   ****   if (FLAG_DEBOUNCE_ALARM) { // check for 3 positives based on 5ms timer
 1845               		.loc 1 848 0
 1846 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_ALARM
 1847 0004 8823      		tst r24
 1848 0006 01F0      		breq .L184
 1849               	.LBB255:
 849:easyrider.c   ****     g_alarm_debounce = (g_alarm_debounce << 1) | 0x01;
 1850               		.loc 1 849 0
 1851 0008 8091 0000 		lds r24,g_alarm_debounce
 1852 000c 880F      		lsl r24
 1853 000e 8160      		ori r24,lo8(1)
 1854 0010 8093 0000 		sts g_alarm_debounce,r24
 850:easyrider.c   ****     FLAG_DEBOUNCE_ALARM = 0; // reset to wait for next timer event
 1855               		.loc 1 850 0
 1856 0014 1092 0000 		sts FLAG_DEBOUNCE_ALARM,__zero_reg__
 851:easyrider.c   ****     if ((g_alarm_debounce & 0b00000111) == 0b00000111) { // start alarm
 1857               		.loc 1 851 0
 1858 0018 8091 0000 		lds r24,g_alarm_debounce
 1859 001c 8770      		andi r24,lo8(7)
 1860 001e 8730      		cpi r24,lo8(7)
 1861 0020 01F0      		breq .L188
 1862               	.L184:
 1863 0022 0895      		ret
 1864               	.L188:
 852:easyrider.c   ****       FLAG_ALARM_SETTLE = 0; // reset alarm settle
 1865               		.loc 1 852 0
 1866 0024 1092 0000 		sts FLAG_ALARM_SETTLE,__zero_reg__
 853:easyrider.c   ****       g_state = ST_ALARM_SETTLE;
 1867               		.loc 1 853 0
 1868 0028 80E0      		ldi r24,0
 1869 002a 91E0      		ldi r25,lo8(1)
 1870 002c 9093 0000 		sts g_state+1,r25
 1871 0030 8093 0000 		sts g_state,r24
 1872 0034 0895      		ret
 1873               	.LBE255:
 1874               		.cfi_endproc
 1875               	.LFE62:
 1877               		.section	.text.process_battery,"ax",@progbits
 1879               	process_battery:
 1880               	.LFB63:
 864:easyrider.c   **** void process_battery() {
 1881               		.loc 1 864 0
 1882               		.cfi_startproc
 1883               	/* prologue: function */
 1884               	/* frame size = 0 */
 1885               	/* stack size = 0 */
 1886               	.L__stack_usage = 0
 865:easyrider.c   ****   if (FLAG_READ_BATT) {
 1887               		.loc 1 865 0
 1888 0000 8091 0000 		lds r24,FLAG_READ_BATT
 1889 0004 8823      		tst r24
 1890 0006 01F0      		breq .L189
 1891               	.LBB258:
 1892               	.LBB259:
 866:easyrider.c   ****     if (g_adc_voltage[0] < 370) { // battery too low
 1893               		.loc 1 866 0
 1894 0008 8091 0000 		lds r24,g_adc_voltage
 1895 000c 9091 0000 		lds r25,g_adc_voltage+1
 1896 0010 8237      		cpi r24,114
 1897 0012 9140      		sbci r25,1
 1898 0014 00F4      		brsh .L191
 868:easyrider.c   ****       if (g_battery_blink_counter % 100 == 0) { 
 1899               		.loc 1 868 0
 1900 0016 9091 0000 		lds r25,g_battery_blink_counter
 1901 001a 89E2      		ldi r24,lo8(41)
 1902 001c 989F      		mul r25,r24
 1903 001e 812D      		mov r24,r1
 1904 0020 1124      		clr __zero_reg__
 1905 0022 8295      		swap r24
 1906 0024 8F70      		andi r24,lo8(15)
 1907 0026 24E6      		ldi r18,lo8(100)
 1908 0028 829F      		mul r24,r18
 1909 002a 9019      		sub r25,r0
 1910 002c 1124      		clr __zero_reg__
 1911 002e 9111      		cpse r25,__zero_reg__
 1912 0030 00C0      		rjmp .L192
 1913               	.L197:
 874:easyrider.c   ****         PORT_C90_LIGHT_STATUS_COCKPIT ^= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 1914               		.loc 1 874 0
 1915 0032 88B1      		in r24,0x8
 1916 0034 90E2      		ldi r25,lo8(32)
 1917 0036 8927      		eor r24,r25
 1918 0038 88B9      		out 0x8,r24
 1919               	.L192:
 879:easyrider.c   ****     FLAG_READ_BATT = 0;
 1920               		.loc 1 879 0
 1921 003a 1092 0000 		sts FLAG_READ_BATT,__zero_reg__
 1922               	.L189:
 1923 003e 0895      		ret
 1924               	.L191:
 871:easyrider.c   ****     } else if (g_adc_voltage[0] > 500) { // battery too high
 1925               		.loc 1 871 0
 1926 0040 8091 0000 		lds r24,g_adc_voltage
 1927 0044 9091 0000 		lds r25,g_adc_voltage+1
 1928 0048 853F      		cpi r24,-11
 1929 004a 9140      		sbci r25,1
 1930 004c 00F0      		brlo .L193
 873:easyrider.c   ****       if (g_battery_blink_counter % 50 == 0) { 
 1931               		.loc 1 873 0
 1932 004e 9091 0000 		lds r25,g_battery_blink_counter
 1933 0052 89E2      		ldi r24,lo8(41)
 1934 0054 989F      		mul r25,r24
 1935 0056 812D      		mov r24,r1
 1936 0058 1124      		clr __zero_reg__
 1937 005a 8695      		lsr r24
 1938 005c 8695      		lsr r24
 1939 005e 8695      		lsr r24
 1940 0060 22E3      		ldi r18,lo8(50)
 1941 0062 829F      		mul r24,r18
 1942 0064 9019      		sub r25,r0
 1943 0066 1124      		clr __zero_reg__
 1944 0068 9111      		cpse r25,__zero_reg__
 1945 006a 00C0      		rjmp .L192
 1946 006c 00C0      		rjmp .L197
 1947               	.L193:
 877:easyrider.c   ****       PORT_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 1948               		.loc 1 877 0
 1949 006e 459A      		sbi 0x8,5
 879:easyrider.c   ****     FLAG_READ_BATT = 0;
 1950               		.loc 1 879 0
 1951 0070 1092 0000 		sts FLAG_READ_BATT,__zero_reg__
 1952 0074 00C0      		rjmp .L189
 1953               	.LBE259:
 1954               	.LBE258:
 1955               		.cfi_endproc
 1956               	.LFE63:
 1958               		.section	.text.process_alarm_off,"ax",@progbits
 1960               	process_alarm_off:
 1961               	.LFB61:
 835:easyrider.c   **** void process_alarm_off() {
 1962               		.loc 1 835 0
 1963               		.cfi_startproc
 1964               	/* prologue: function */
 1965               	/* frame size = 0 */
 1966               	/* stack size = 0 */
 1967               	.L__stack_usage = 0
 836:easyrider.c   ****   if (FLAG_DEBOUNCE_ALARM) { // check for 3 positives based on 5ms timer
 1968               		.loc 1 836 0
 1969 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_ALARM
 1970 0004 8823      		tst r24
 1971 0006 01F0      		breq .L198
 837:easyrider.c   ****     g_alarm_debounce = (g_alarm_debounce << 1);
 1972               		.loc 1 837 0
 1973 0008 8091 0000 		lds r24,g_alarm_debounce
 1974 000c 880F      		lsl r24
 1975 000e 8093 0000 		sts g_alarm_debounce,r24
 838:easyrider.c   ****     FLAG_DEBOUNCE_ALARM = 0; // reset to wait for next timer event
 1976               		.loc 1 838 0
 1977 0012 1092 0000 		sts FLAG_DEBOUNCE_ALARM,__zero_reg__
 839:easyrider.c   ****     if (((g_alarm_debounce & 0b00000111) << 5) == 0) {
 1978               		.loc 1 839 0
 1979 0016 8091 0000 		lds r24,g_alarm_debounce
 1980 001a 20E2      		ldi r18,lo8(32)
 1981 001c 829F      		mul r24,r18
 1982 001e C001      		movw r24,r0
 1983 0020 1124      		clr __zero_reg__
 1984 0022 9927      		clr r25
 1985 0024 892B      		or r24,r25
 1986 0026 01F0      		breq .L202
 1987               	.L198:
 1988 0028 0895      		ret
 1989               	.L202:
 1990               	.LBB264:
 1991               	.LBB265:
 1992               	.LBB266:
 885:easyrider.c   ****   PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 1993               		.loc 1 885 0
 1994 002a 4298      		cbi 0x8,2
 886:easyrider.c   ****   PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 1995               		.loc 1 886 0
 1996 002c 4598      		cbi 0x8,5
 887:easyrider.c   ****   PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 1997               		.loc 1 887 0
 1998 002e 4098      		cbi 0x8,0
 888:easyrider.c   ****   PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 1999               		.loc 1 888 0
 2000 0030 4398      		cbi 0x8,3
 889:easyrider.c   ****   PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 2001               		.loc 1 889 0
 2002 0032 4198      		cbi 0x8,1
 890:easyrider.c   ****   PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 2003               		.loc 1 890 0
 2004 0034 4498      		cbi 0x8,4
 891:easyrider.c   ****   PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 2005               		.loc 1 891 0
 2006 0036 4798      		cbi 0x8,7
 892:easyrider.c   ****   PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 2007               		.loc 1 892 0
 2008 0038 5F98      		cbi 0xb,7
 893:easyrider.c   ****   PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 2009               		.loc 1 893 0
 2010 003a 4698      		cbi 0x8,6
 894:easyrider.c   ****   PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
 2011               		.loc 1 894 0
 2012 003c 5E98      		cbi 0xb,6
 2013               	.LBE266:
 2014               	.LBE265:
 841:easyrider.c   ****       FLAG_ALARM_SETTLE = 0; // reset alarm settle
 2015               		.loc 1 841 0
 2016 003e 1092 0000 		sts FLAG_ALARM_SETTLE,__zero_reg__
 842:easyrider.c   ****       g_state = ST_SLEEP;
 2017               		.loc 1 842 0
 2018 0042 80E0      		ldi r24,0
 2019 0044 92E0      		ldi r25,lo8(2)
 2020 0046 9093 0000 		sts g_state+1,r25
 2021 004a 8093 0000 		sts g_state,r24
 2022 004e 0895      		ret
 2023               	.LBE264:
 2024               		.cfi_endproc
 2025               	.LFE61:
 2027               		.section	.text.process_ign_off,"ax",@progbits
 2029               	process_ign_off:
 2030               	.LFB54:
 750:easyrider.c   **** void process_ign_off() {
 2031               		.loc 1 750 0
 2032               		.cfi_startproc
 2033               	/* prologue: function */
 2034               	/* frame size = 0 */
 2035               	/* stack size = 0 */
 2036               	.L__stack_usage = 0
 751:easyrider.c   ****   if (FLAG_DEBOUNCE_IGN) { // check for 3 positives based on 5ms timer
 2037               		.loc 1 751 0
 2038 0000 8091 0000 		lds r24,FLAG_DEBOUNCE_IGN
 2039 0004 8823      		tst r24
 2040 0006 01F0      		breq .L203
 752:easyrider.c   ****     g_ign_debounce = (g_ign_debounce << 1);
 2041               		.loc 1 752 0
 2042 0008 8091 0000 		lds r24,g_ign_debounce
 2043 000c 880F      		lsl r24
 2044 000e 8093 0000 		sts g_ign_debounce,r24
 753:easyrider.c   ****     FLAG_DEBOUNCE_IGN = 0; // reset to wait for next timer event
 2045               		.loc 1 753 0
 2046 0012 1092 0000 		sts FLAG_DEBOUNCE_IGN,__zero_reg__
 754:easyrider.c   ****     if (((g_ign_debounce & 0b00000111) << 5) == 0) {
 2047               		.loc 1 754 0
 2048 0016 8091 0000 		lds r24,g_ign_debounce
 2049 001a 20E2      		ldi r18,lo8(32)
 2050 001c 829F      		mul r24,r18
 2051 001e C001      		movw r24,r0
 2052 0020 1124      		clr __zero_reg__
 2053 0022 9927      		clr r25
 2054 0024 892B      		or r24,r25
 2055 0026 01F0      		breq .L207
 2056               	.L203:
 2057 0028 0895      		ret
 2058               	.L207:
 2059               	.LBB271:
 2060               	.LBB272:
 2061               	.LBB273:
 885:easyrider.c   ****   PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 2062               		.loc 1 885 0
 2063 002a 4298      		cbi 0x8,2
 886:easyrider.c   ****   PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 2064               		.loc 1 886 0
 2065 002c 4598      		cbi 0x8,5
 887:easyrider.c   ****   PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 2066               		.loc 1 887 0
 2067 002e 4098      		cbi 0x8,0
 888:easyrider.c   ****   PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 2068               		.loc 1 888 0
 2069 0030 4398      		cbi 0x8,3
 889:easyrider.c   ****   PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 2070               		.loc 1 889 0
 2071 0032 4198      		cbi 0x8,1
 890:easyrider.c   ****   PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 2072               		.loc 1 890 0
 2073 0034 4498      		cbi 0x8,4
 891:easyrider.c   ****   PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 2074               		.loc 1 891 0
 2075 0036 4798      		cbi 0x8,7
 892:easyrider.c   ****   PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 2076               		.loc 1 892 0
 2077 0038 5F98      		cbi 0xb,7
 893:easyrider.c   ****   PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 2078               		.loc 1 893 0
 2079 003a 4698      		cbi 0x8,6
 894:easyrider.c   ****   PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
 2080               		.loc 1 894 0
 2081 003c 5E98      		cbi 0xb,6
 2082               	.LBE273:
 2083               	.LBE272:
 756:easyrider.c   ****       PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER); // buzzer off
 2084               		.loc 1 756 0
 2085 003e 5D98      		cbi 0xb,5
 757:easyrider.c   ****       FLAG_SETTLE = 0; // reset settle
 2086               		.loc 1 757 0
 2087 0040 1092 0000 		sts FLAG_SETTLE,__zero_reg__
 758:easyrider.c   ****       g_state = ST_SLEEP;
 2088               		.loc 1 758 0
 2089 0044 80E0      		ldi r24,0
 2090 0046 92E0      		ldi r25,lo8(2)
 2091 0048 9093 0000 		sts g_state+1,r25
 2092 004c 8093 0000 		sts g_state,r24
 2093 0050 0895      		ret
 2094               	.LBE271:
 2095               		.cfi_endproc
 2096               	.LFE54:
 2098               		.section	.text.__vector_24,"ax",@progbits
 2099               	.global	__vector_24
 2101               	__vector_24:
 2102               	.LFB70:
 955:easyrider.c   **** }
 956:easyrider.c   **** 
 957:easyrider.c   **** void disable_psenses() {
 958:easyrider.c   ****   g_senses = 0;
 959:easyrider.c   **** }
 960:easyrider.c   **** 
 961:easyrider.c   **** // setup the ADC in free running mode, so we can select the read channels ourselves
 962:easyrider.c   **** void enable_adc() {
 963:easyrider.c   ****   ADMUX = (ADMUX & 0xF8) | g_adc_read_pin; // clear the bottom 3 bits before setting new pin
 964:easyrider.c   ****   ADMUX |= (1 << REFS0); // voltage reference = AVcc
 965:easyrider.c   ****   DIDR0 = 0x0F;  // disable digital inputs for ADC0-ADC3 
 966:easyrider.c   ****   ADCSRA |= (1 << ADEN); // enable ADC
 967:easyrider.c   ****   ADCSRA |= (1 << ADPS2) | (1 << ADPS1 ) | (1 << ADPS0); // prescaler = 128
 968:easyrider.c   ****   ADCSRA |= (1 << ADIE); // enable interrupt
 969:easyrider.c   ****   ADCSRA |= (1 << ADSC); // start a conversion
 970:easyrider.c   **** }
 971:easyrider.c   **** 
 972:easyrider.c   **** void disable_adc() {
 973:easyrider.c   ****   ADCSRA &= ~(1 << ADEN);
 974:easyrider.c   **** }
 975:easyrider.c   **** 
 976:easyrider.c   **** ISR(ADC_vect) {
 2103               		.loc 1 976 0
 2104               		.cfi_startproc
 2105 0000 1F92      		push r1
 2106               	.LCFI0:
 2107               		.cfi_def_cfa_offset 3
 2108               		.cfi_offset 1, -2
 2109 0002 0F92      		push r0
 2110               	.LCFI1:
 2111               		.cfi_def_cfa_offset 4
 2112               		.cfi_offset 0, -3
 2113 0004 0FB6      		in r0,__SREG__
 2114 0006 0F92      		push r0
 2115 0008 1124      		clr __zero_reg__
 2116 000a 0BB6      		in r0,__RAMPZ__
 2117 000c 0F92      		push r0
 2118 000e 2F93      		push r18
 2119               	.LCFI2:
 2120               		.cfi_def_cfa_offset 5
 2121               		.cfi_offset 18, -4
 2122 0010 8F93      		push r24
 2123               	.LCFI3:
 2124               		.cfi_def_cfa_offset 6
 2125               		.cfi_offset 24, -5
 2126 0012 9F93      		push r25
 2127               	.LCFI4:
 2128               		.cfi_def_cfa_offset 7
 2129               		.cfi_offset 25, -6
 2130 0014 AF93      		push r26
 2131               	.LCFI5:
 2132               		.cfi_def_cfa_offset 8
 2133               		.cfi_offset 26, -7
 2134 0016 BF93      		push r27
 2135               	.LCFI6:
 2136               		.cfi_def_cfa_offset 9
 2137               		.cfi_offset 27, -8
 2138 0018 EF93      		push r30
 2139               	.LCFI7:
 2140               		.cfi_def_cfa_offset 10
 2141               		.cfi_offset 30, -9
 2142 001a FF93      		push r31
 2143               	.LCFI8:
 2144               		.cfi_def_cfa_offset 11
 2145               		.cfi_offset 31, -10
 2146               	/* prologue: Signal */
 2147               	/* frame size = 0 */
 2148               	/* stack size = 11 */
 2149               	.L__stack_usage = 11
 977:easyrider.c   ****   // first read ADCL, then ADCH to keep it an atomic operation
 978:easyrider.c   ****   g_adc_voltage[g_adc_read_pin] = ADCL;
 2150               		.loc 1 978 0
 2151 001c E091 0000 		lds r30,g_adc_read_pin
 2152 0020 F0E0      		ldi r31,0
 2153 0022 8091 7800 		lds r24,120
 2154 0026 90E0      		ldi r25,0
 2155 0028 EE0F      		lsl r30
 2156 002a FF1F      		rol r31
 2157 002c E050      		subi r30,lo8(-(g_adc_voltage))
 2158 002e F040      		sbci r31,hi8(-(g_adc_voltage))
 2159 0030 9183      		std Z+1,r25
 2160 0032 8083      		st Z,r24
 979:easyrider.c   ****   g_adc_voltage[g_adc_read_pin] = (g_adc_voltage[g_adc_read_pin] | (ADCH << 8));
 2161               		.loc 1 979 0
 2162 0034 E091 0000 		lds r30,g_adc_read_pin
 2163 0038 F0E0      		ldi r31,0
 2164 003a A091 0000 		lds r26,g_adc_read_pin
 2165 003e B0E0      		ldi r27,0
 2166 0040 AA0F      		lsl r26
 2167 0042 BB1F      		rol r27
 2168 0044 A050      		subi r26,lo8(-(g_adc_voltage))
 2169 0046 B040      		sbci r27,hi8(-(g_adc_voltage))
 2170 0048 8D91      		ld r24,X+
 2171 004a 9C91      		ld r25,X
 2172 004c 2091 7900 		lds r18,121
 2173 0050 922B      		or r25,r18
 2174 0052 EE0F      		lsl r30
 2175 0054 FF1F      		rol r31
 2176 0056 E050      		subi r30,lo8(-(g_adc_voltage))
 2177 0058 F040      		sbci r31,hi8(-(g_adc_voltage))
 2178 005a 9183      		std Z+1,r25
 2179 005c 8083      		st Z,r24
 980:easyrider.c   ****   g_adc_voltage[g_adc_read_pin] += C90_OFFSET_ADC_READING;
 2180               		.loc 1 980 0
 2181 005e E091 0000 		lds r30,g_adc_read_pin
 2182 0062 F0E0      		ldi r31,0
 2183 0064 EE0F      		lsl r30
 2184 0066 FF1F      		rol r31
 2185 0068 E050      		subi r30,lo8(-(g_adc_voltage))
 2186 006a F040      		sbci r31,hi8(-(g_adc_voltage))
 2187 006c 8081      		ld r24,Z
 2188 006e 9181      		ldd r25,Z+1
 2189 0070 0196      		adiw r24,1
 2190 0072 9183      		std Z+1,r25
 2191 0074 8083      		st Z,r24
 981:easyrider.c   ****   g_adc_read_pin++;
 2192               		.loc 1 981 0
 2193 0076 8091 0000 		lds r24,g_adc_read_pin
 2194 007a 8F5F      		subi r24,lo8(-(1))
 2195 007c 8093 0000 		sts g_adc_read_pin,r24
 982:easyrider.c   ****   if (g_adc_read_pin > 3) {
 2196               		.loc 1 982 0
 2197 0080 8091 0000 		lds r24,g_adc_read_pin
 2198 0084 8430      		cpi r24,lo8(4)
 2199 0086 00F0      		brlo .L209
 983:easyrider.c   ****     g_adc_read_pin = 0;
 2200               		.loc 1 983 0
 2201 0088 1092 0000 		sts g_adc_read_pin,__zero_reg__
 2202               	.L209:
 984:easyrider.c   ****   }
 985:easyrider.c   ****   ADMUX = (ADMUX & 0xF8) | g_adc_read_pin;
 2203               		.loc 1 985 0
 2204 008c 8091 7C00 		lds r24,124
 2205 0090 9091 0000 		lds r25,g_adc_read_pin
 2206 0094 887F      		andi r24,lo8(-8)
 2207 0096 892B      		or r24,r25
 2208 0098 8093 7C00 		sts 124,r24
 986:easyrider.c   ****   ADCSRA |= (1 << ADSC); // start another conversion again
 2209               		.loc 1 986 0
 2210 009c 8091 7A00 		lds r24,122
 2211 00a0 8064      		ori r24,lo8(64)
 2212 00a2 8093 7A00 		sts 122,r24
 2213               	/* epilogue start */
 987:easyrider.c   **** }
 2214               		.loc 1 987 0
 2215 00a6 FF91      		pop r31
 2216 00a8 EF91      		pop r30
 2217 00aa BF91      		pop r27
 2218 00ac AF91      		pop r26
 2219 00ae 9F91      		pop r25
 2220 00b0 8F91      		pop r24
 2221 00b2 2F91      		pop r18
 2222 00b4 0F90      		pop r0
 2223 00b6 0BBE      		out __RAMPZ__,r0
 2224 00b8 0F90      		pop r0
 2225 00ba 0FBE      		out __SREG__,r0
 2226 00bc 0F90      		pop r0
 2227 00be 1F90      		pop r1
 2228 00c0 1895      		reti
 2229               		.cfi_endproc
 2230               	.LFE70:
 2232               		.section	.text.__vector_16,"ax",@progbits
 2233               	.global	__vector_16
 2235               	__vector_16:
 2236               	.LFB74:
 988:easyrider.c   **** 
 989:easyrider.c   **** void start_sense_timer()
 990:easyrider.c   **** {
 991:easyrider.c   ****   // Configure timer 0 (8-bit) for CTC mode (Clear on Timer Compare)
 992:easyrider.c   ****   TCCR0B |= (1 << WGM02); // CTC Mode
 993:easyrider.c   ****   TCCR0A |= (1 << WGM01) | (0 << WGM00); // CTC Mode
 994:easyrider.c   ****   TCCR0B |= ((1 << CS00) | (1 << CS02)); // prescale 1024
 995:easyrider.c   ****   TCCR0B &= ~(1 << CS01); // prescale 1024
 996:easyrider.c   ****   TIMSK0 |= (1 << OCIE0A); // Enable CTC interrupt
 997:easyrider.c   ****   OCR0A = 97; // Set CTC compare value, approx. 5 ms -> 200 times/sec
 998:easyrider.c   **** }
 999:easyrider.c   **** 
1000:easyrider.c   **** void start_blink_timer()
1001:easyrider.c   **** {
1002:easyrider.c   ****   // Configure timer 1 (16-bit) for CTC mode (Clear on Timer Compare)
1003:easyrider.c   ****   TCCR1A &= ~((1 << WGM11) | (1 << WGM10)); // CTC Mode
1004:easyrider.c   ****   TCCR1B |= (1 << WGM12); // CTC Mode
1005:easyrider.c   ****   TCCR1B |= ((1 << CS10) | (1 << CS12)); // prescale 1024
1006:easyrider.c   ****   TCCR1B &= ~(1 << CS11); // prescale 1024
1007:easyrider.c   ****   TIMSK1 |= (1 << OCIE1A); // Enable Compare A interrupt
1008:easyrider.c   ****   OCR1A = g_settings.blink_speed; // Set CTC compare value, default approx. 0.5 secs
1009:easyrider.c   **** }
1010:easyrider.c   **** 
1011:easyrider.c   **** void start_buzzer_timer(uint8_t isr_on) {
1012:easyrider.c   ****   // Configure timer 3 (16-bit) for CTC mode (Clear on Timer Compare)
1013:easyrider.c   ****   TCCR3A &= ~((1 << WGM31) | (1 << WGM30)); // CTC Mode
1014:easyrider.c   ****   TCCR3B |= (1 << WGM32); // CTC Mode
1015:easyrider.c   ****   TCCR3B |= ((1 << CS31) | (1 << CS30)); // prescale 64
1016:easyrider.c   ****   TCCR3B &= ~(1 << CS32); // prescale 64
1017:easyrider.c   ****   if (isr_on) {
1018:easyrider.c   ****     TIMSK3 |= (1 << OCIE3A); // Enable Compare A interrupt
1019:easyrider.c   ****   }
1020:easyrider.c   ****   OCR3A = 68; // Set CTC compare value, approx. 4600hz: with a square wave that is a 2400hz tone
1021:easyrider.c   **** }
1022:easyrider.c   **** 
1023:easyrider.c   **** // runs every 5ms
1024:easyrider.c   **** ISR(TIMER0_COMPA_vect)
1025:easyrider.c   **** {
 2237               		.loc 1 1025 0
 2238               		.cfi_startproc
 2239 0000 1F92      		push r1
 2240               	.LCFI9:
 2241               		.cfi_def_cfa_offset 3
 2242               		.cfi_offset 1, -2
 2243 0002 0F92      		push r0
 2244               	.LCFI10:
 2245               		.cfi_def_cfa_offset 4
 2246               		.cfi_offset 0, -3
 2247 0004 0FB6      		in r0,__SREG__
 2248 0006 0F92      		push r0
 2249 0008 1124      		clr __zero_reg__
 2250 000a 8F93      		push r24
 2251               	.LCFI11:
 2252               		.cfi_def_cfa_offset 5
 2253               		.cfi_offset 24, -4
 2254 000c 9F93      		push r25
 2255               	.LCFI12:
 2256               		.cfi_def_cfa_offset 6
 2257               		.cfi_offset 25, -5
 2258               	/* prologue: Signal */
 2259               	/* frame size = 0 */
 2260               	/* stack size = 5 */
 2261               	.L__stack_usage = 5
1026:easyrider.c   ****   FLAG_DEBOUNCE_RI = 1;
 2262               		.loc 1 1026 0
 2263 000e 81E0      		ldi r24,lo8(1)
 2264 0010 8093 0000 		sts FLAG_DEBOUNCE_RI,r24
1027:easyrider.c   ****   FLAG_DEBOUNCE_LI = 1;
 2265               		.loc 1 1027 0
 2266 0014 8093 0000 		sts FLAG_DEBOUNCE_LI,r24
1028:easyrider.c   ****   FLAG_DEBOUNCE_CLAXON = 1;
 2267               		.loc 1 1028 0
 2268 0018 8093 0000 		sts FLAG_DEBOUNCE_CLAXON,r24
1029:easyrider.c   ****   FLAG_DEBOUNCE_IGN = 1;
 2269               		.loc 1 1029 0
 2270 001c 8093 0000 		sts FLAG_DEBOUNCE_IGN,r24
1030:easyrider.c   ****   FLAG_DEBOUNCE_BRAKE = 1;
 2271               		.loc 1 1030 0
 2272 0020 8093 0000 		sts FLAG_DEBOUNCE_BRAKE,r24
1031:easyrider.c   ****   FLAG_DEBOUNCE_PILOT = 1;
 2273               		.loc 1 1031 0
 2274 0024 8093 0000 		sts FLAG_DEBOUNCE_PILOT,r24
1032:easyrider.c   ****   FLAG_DEBOUNCE_LIGHT = 1;
 2275               		.loc 1 1032 0
 2276 0028 8093 0000 		sts FLAG_DEBOUNCE_LIGHT,r24
1033:easyrider.c   ****   FLAG_DEBOUNCE_ALARM = 1;
 2277               		.loc 1 1033 0
 2278 002c 8093 0000 		sts FLAG_DEBOUNCE_ALARM,r24
1034:easyrider.c   ****   FLAG_DEBOUNCE_WARNING = 1;
 2279               		.loc 1 1034 0
 2280 0030 8093 0000 		sts FLAG_DEBOUNCE_WARNING,r24
1035:easyrider.c   ****   FLAG_READ_BATT = 1;
 2281               		.loc 1 1035 0
 2282 0034 8093 0000 		sts FLAG_READ_BATT,r24
1036:easyrider.c   ****   FLAG_READ_BACKPEDAL = 1;
 2283               		.loc 1 1036 0
 2284 0038 8093 0000 		sts FLAG_READ_BACKPEDAL,r24
1037:easyrider.c   ****   if (g_battery_blink_counter > 200) {
 2285               		.loc 1 1037 0
 2286 003c 8091 0000 		lds r24,g_battery_blink_counter
 2287 0040 893C      		cpi r24,lo8(-55)
 2288 0042 00F0      		brlo .L211
1038:easyrider.c   ****     g_battery_blink_counter = 0;
 2289               		.loc 1 1038 0
 2290 0044 1092 0000 		sts g_battery_blink_counter,__zero_reg__
 2291               	.L211:
1039:easyrider.c   ****   }
1040:easyrider.c   ****   g_battery_blink_counter++;
 2292               		.loc 1 1040 0
 2293 0048 8091 0000 		lds r24,g_battery_blink_counter
 2294 004c 8F5F      		subi r24,lo8(-(1))
 2295 004e 8093 0000 		sts g_battery_blink_counter,r24
1041:easyrider.c   ****   if (g_current_settle_time) {
 2296               		.loc 1 1041 0
 2297 0052 8091 0000 		lds r24,g_current_settle_time
 2298 0056 9091 0000 		lds r25,g_current_settle_time+1
 2299 005a 892B      		or r24,r25
 2300 005c 01F0      		breq .L212
1042:easyrider.c   ****     g_current_settle_time--;
 2301               		.loc 1 1042 0
 2302 005e 8091 0000 		lds r24,g_current_settle_time
 2303 0062 9091 0000 		lds r25,g_current_settle_time+1
 2304 0066 0197      		sbiw r24,1
 2305 0068 9093 0000 		sts g_current_settle_time+1,r25
 2306 006c 8093 0000 		sts g_current_settle_time,r24
 2307               	.L212:
1043:easyrider.c   ****   }
1044:easyrider.c   ****   if (g_current_alarm_settle_time) {
 2308               		.loc 1 1044 0
 2309 0070 8091 0000 		lds r24,g_current_alarm_settle_time
 2310 0074 9091 0000 		lds r25,g_current_alarm_settle_time+1
 2311 0078 892B      		or r24,r25
 2312 007a 01F0      		breq .L213
1045:easyrider.c   ****     g_current_alarm_settle_time--;
 2313               		.loc 1 1045 0
 2314 007c 8091 0000 		lds r24,g_current_alarm_settle_time
 2315 0080 9091 0000 		lds r25,g_current_alarm_settle_time+1
 2316 0084 0197      		sbiw r24,1
 2317 0086 9093 0000 		sts g_current_alarm_settle_time+1,r25
 2318 008a 8093 0000 		sts g_current_alarm_settle_time,r24
 2319               	.L213:
1046:easyrider.c   ****   }
1047:easyrider.c   ****   if (g_music_duration) {
 2320               		.loc 1 1047 0
 2321 008e 8091 0000 		lds r24,g_music_duration
 2322 0092 9091 0000 		lds r25,g_music_duration+1
 2323 0096 892B      		or r24,r25
 2324 0098 01F0      		breq .L210
1048:easyrider.c   ****     g_music_duration--;
 2325               		.loc 1 1048 0
 2326 009a 8091 0000 		lds r24,g_music_duration
 2327 009e 9091 0000 		lds r25,g_music_duration+1
 2328 00a2 0197      		sbiw r24,1
 2329 00a4 9093 0000 		sts g_music_duration+1,r25
 2330 00a8 8093 0000 		sts g_music_duration,r24
 2331               	.L210:
 2332               	/* epilogue start */
1049:easyrider.c   ****   }
1050:easyrider.c   **** }
 2333               		.loc 1 1050 0
 2334 00ac 9F91      		pop r25
 2335 00ae 8F91      		pop r24
 2336 00b0 0F90      		pop r0
 2337 00b2 0FBE      		out __SREG__,r0
 2338 00b4 0F90      		pop r0
 2339 00b6 1F90      		pop r1
 2340 00b8 1895      		reti
 2341               		.cfi_endproc
 2342               	.LFE74:
 2344               		.section	.text.__vector_13,"ax",@progbits
 2345               	.global	__vector_13
 2347               	__vector_13:
 2348               	.LFB75:
1051:easyrider.c   **** 
1052:easyrider.c   **** // indicator on/off pace, runs every 0.5 secs by default
1053:easyrider.c   **** ISR(TIMER1_COMPA_vect)
1054:easyrider.c   **** {
 2349               		.loc 1 1054 0
 2350               		.cfi_startproc
 2351 0000 1F92      		push r1
 2352               	.LCFI13:
 2353               		.cfi_def_cfa_offset 3
 2354               		.cfi_offset 1, -2
 2355 0002 0F92      		push r0
 2356               	.LCFI14:
 2357               		.cfi_def_cfa_offset 4
 2358               		.cfi_offset 0, -3
 2359 0004 0FB6      		in r0,__SREG__
 2360 0006 0F92      		push r0
 2361 0008 1124      		clr __zero_reg__
 2362 000a 8F93      		push r24
 2363               	.LCFI15:
 2364               		.cfi_def_cfa_offset 5
 2365               		.cfi_offset 24, -4
 2366 000c 9F93      		push r25
 2367               	.LCFI16:
 2368               		.cfi_def_cfa_offset 6
 2369               		.cfi_offset 25, -5
 2370               	/* prologue: Signal */
 2371               	/* frame size = 0 */
 2372               	/* stack size = 5 */
 2373               	.L__stack_usage = 5
1055:easyrider.c   ****   FLAG_BLINK_RI = 1;
 2374               		.loc 1 1055 0
 2375 000e 81E0      		ldi r24,lo8(1)
 2376 0010 8093 0000 		sts FLAG_BLINK_RI,r24
1056:easyrider.c   ****   FLAG_BLINK_LI = 1;
 2377               		.loc 1 1056 0
 2378 0014 8093 0000 		sts FLAG_BLINK_LI,r24
1057:easyrider.c   ****   FLAG_ALARM_BLINK = 1;
 2379               		.loc 1 1057 0
 2380 0018 8093 0000 		sts FLAG_ALARM_BLINK,r24
1058:easyrider.c   ****   FLAG_BLINK_WARNING = 1;
 2381               		.loc 1 1058 0
 2382 001c 8093 0000 		sts FLAG_BLINK_WARNING,r24
1059:easyrider.c   ****   FLAG_BLINK_BACKPEDAL = 1;
 2383               		.loc 1 1059 0
 2384 0020 8093 0000 		sts FLAG_BLINK_BACKPEDAL,r24
1060:easyrider.c   ****   if (g_sleep_counter) {
 2385               		.loc 1 1060 0
 2386 0024 8091 0000 		lds r24,g_sleep_counter
 2387 0028 9091 0000 		lds r25,g_sleep_counter+1
 2388 002c 892B      		or r24,r25
 2389 002e 01F0      		breq .L225
1061:easyrider.c   ****     g_sleep_counter--;
 2390               		.loc 1 1061 0
 2391 0030 8091 0000 		lds r24,g_sleep_counter
 2392 0034 9091 0000 		lds r25,g_sleep_counter+1
 2393 0038 0197      		sbiw r24,1
 2394 003a 9093 0000 		sts g_sleep_counter+1,r25
 2395 003e 8093 0000 		sts g_sleep_counter,r24
 2396               	.L225:
1062:easyrider.c   ****   }
1063:easyrider.c   ****   g_alarm_blink_counter++;
 2397               		.loc 1 1063 0
 2398 0042 8091 0000 		lds r24,g_alarm_blink_counter
 2399 0046 8F5F      		subi r24,lo8(-(1))
 2400 0048 8093 0000 		sts g_alarm_blink_counter,r24
 2401               	/* epilogue start */
1064:easyrider.c   **** }
 2402               		.loc 1 1064 0
 2403 004c 9F91      		pop r25
 2404 004e 8F91      		pop r24
 2405 0050 0F90      		pop r0
 2406 0052 0FBE      		out __SREG__,r0
 2407 0054 0F90      		pop r0
 2408 0056 1F90      		pop r1
 2409 0058 1895      		reti
 2410               		.cfi_endproc
 2411               	.LFE75:
 2413               		.section	.text.__vector_32,"ax",@progbits
 2414               	.global	__vector_32
 2416               	__vector_32:
 2417               	.LFB76:
1065:easyrider.c   **** 
1066:easyrider.c   **** ISR(TIMER3_COMPA_vect)
1067:easyrider.c   **** {
 2418               		.loc 1 1067 0
 2419               		.cfi_startproc
 2420 0000 1F92      		push r1
 2421               	.LCFI17:
 2422               		.cfi_def_cfa_offset 3
 2423               		.cfi_offset 1, -2
 2424 0002 0F92      		push r0
 2425               	.LCFI18:
 2426               		.cfi_def_cfa_offset 4
 2427               		.cfi_offset 0, -3
 2428 0004 0FB6      		in r0,__SREG__
 2429 0006 0F92      		push r0
 2430 0008 1124      		clr __zero_reg__
 2431 000a 8F93      		push r24
 2432               	.LCFI19:
 2433               		.cfi_def_cfa_offset 5
 2434               		.cfi_offset 24, -4
 2435 000c 9F93      		push r25
 2436               	.LCFI20:
 2437               		.cfi_def_cfa_offset 6
 2438               		.cfi_offset 25, -5
 2439               	/* prologue: Signal */
 2440               	/* frame size = 0 */
 2441               	/* stack size = 5 */
 2442               	.L__stack_usage = 5
1068:easyrider.c   ****   // toggle buzzer pin to create a 50% duty cycle
1069:easyrider.c   ****   PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
 2443               		.loc 1 1069 0
 2444 000e 8BB1      		in r24,0xb
 2445 0010 90E2      		ldi r25,lo8(32)
 2446 0012 8927      		eor r24,r25
 2447 0014 8BB9      		out 0xb,r24
 2448               	/* epilogue start */
1070:easyrider.c   **** }
 2449               		.loc 1 1070 0
 2450 0016 9F91      		pop r25
 2451 0018 8F91      		pop r24
 2452 001a 0F90      		pop r0
 2453 001c 0FBE      		out __SREG__,r0
 2454 001e 0F90      		pop r0
 2455 0020 1F90      		pop r1
 2456 0022 1895      		reti
 2457               		.cfi_endproc
 2458               	.LFE76:
 2460               		.section	.text.startup.main,"ax",@progbits
 2461               	.global	main
 2463               	main:
 2464               	.LFB81:
1071:easyrider.c   **** 
1072:easyrider.c   **** void check_sound() {
1073:easyrider.c   ****   if (FLAG_MUSIC) {
1074:easyrider.c   ****     if (!g_music_duration) {
1075:easyrider.c   ****       if (pgm_read_word(g_current_music)) { // get note data until MUSIC_END
1076:easyrider.c   ****         if (g_current_music == g_selected_music) { // still at start: first byte is the tempo
1077:easyrider.c   ****           g_music_tempo = pgm_read_word(g_current_music);
1078:easyrider.c   ****           g_current_music++;
1079:easyrider.c   ****         }
1080:easyrider.c   ****         g_music_duration = calc_note_duration(pgm_read_word(g_current_music));
1081:easyrider.c   ****         g_current_music++;
1082:easyrider.c   ****         if (pgm_read_word(g_current_music) == MUSIC_P) { // pause check (silence for a certain time
1083:easyrider.c   ****           TIMSK3 &= ~(1 << OCIE3A); // disable interrupt
1084:easyrider.c   ****           PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
1085:easyrider.c   ****         } else {
1086:easyrider.c   ****           TIMSK3 |= (1 << OCIE3A); // enable interrupt
1087:easyrider.c   ****         }
1088:easyrider.c   ****         OCR3A = pgm_read_word(g_current_music);
1089:easyrider.c   ****         TCNT3 = 0;
1090:easyrider.c   ****         g_current_music++;
1091:easyrider.c   ****       } else { // the end of song
1092:easyrider.c   ****         FLAG_MUSIC = 0;
1093:easyrider.c   ****         TIMSK3 &= ~(1 << OCIE3A); // disable interrupt
1094:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
1095:easyrider.c   ****       }
1096:easyrider.c   ****     }
1097:easyrider.c   ****   }
1098:easyrider.c   **** }
1099:easyrider.c   **** 
1100:easyrider.c   **** void sleep_now() {
1101:easyrider.c   ****   reset_ports();
1102:easyrider.c   ****   disable_adc();
1103:easyrider.c   ****   DDRA = 0;
1104:easyrider.c   ****   PORTA = 0xff;
1105:easyrider.c   ****   wdt_disable();
1106:easyrider.c   ****   PORT_C90_HEARTBEAT_LED &= ~(1 << PIN_C90_HEARTBEAT_LED); // low
1107:easyrider.c   ****   disable_psenses();
1108:easyrider.c   ****   power_all_disable();
1109:easyrider.c   ****   set_sleep_mode(SLEEP_MODE_PWR_DOWN);
1110:easyrider.c   ****   sleep_mode();         
1111:easyrider.c   **** }
1112:easyrider.c   **** 
1113:easyrider.c   **** void initialize() {
1114:easyrider.c   ****   MCUCR = 0x80; // disable JTAG at runtime (2 calls in a row needed)
1115:easyrider.c   ****   MCUCR = 0x80;
1116:easyrider.c   ****   wdt_enable(WDTO_2S);  // enable 2 sec watchdog
1117:easyrider.c   ****   sei(); //  enable global interrupts
1118:easyrider.c   ****   enable_adc();
1119:easyrider.c   ****   g_state = ST_SLEEP; // always start in sleep mode
1120:easyrider.c   ****   g_buffer_head = g_buffer_tail = 0; // init event buffer
1121:easyrider.c   ****   // init settings
1122:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.deep_sleep_counter) != g_settings.deep_sleep_counter) {
1123:easyrider.c   ****     g_settings.deep_sleep_counter = eeprom_read_word(&g_rom_settings.deep_sleep_counter);
1124:easyrider.c   ****   }
1125:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.settle_time) != g_settings.settle_time) {
1126:easyrider.c   ****     g_settings.settle_time = eeprom_read_word(&g_rom_settings.settle_time);
1127:easyrider.c   ****   }
1128:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.alarm_settle_time) != g_settings.alarm_settle_time) {
1129:easyrider.c   ****     g_settings.alarm_settle_time = eeprom_read_word(&g_rom_settings.alarm_settle_time);
1130:easyrider.c   ****   }
1131:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.indicator_sound) != g_settings.indicator_sound) {
1132:easyrider.c   ****     g_settings.indicator_sound = eeprom_read_byte(&g_rom_settings.indicator_sound);
1133:easyrider.c   ****   }
1134:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.blink_speed) != g_settings.blink_speed) {
1135:easyrider.c   ****     g_settings.blink_speed = eeprom_read_word(&g_rom_settings.blink_speed);
1136:easyrider.c   ****   }
1137:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_counter) != g_settings.alarm_counter) {
1138:easyrider.c   ****     g_settings.alarm_counter = eeprom_read_byte(&g_rom_settings.alarm_counter);
1139:easyrider.c   ****   }
1140:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_trigger) != g_settings.alarm_trigger) {
1141:easyrider.c   ****     g_settings.alarm_trigger = eeprom_read_byte(&g_rom_settings.alarm_trigger);
1142:easyrider.c   ****   }
1143:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_trigger_counter) != g_settings.alarm_trigger_counter) 
1144:easyrider.c   ****     g_settings.alarm_trigger_counter = eeprom_read_byte(&g_rom_settings.alarm_trigger_counter);
1145:easyrider.c   ****   }
1146:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_thres_min) != g_settings.alarm_thres_min) {
1147:easyrider.c   ****     g_settings.alarm_thres_min = eeprom_read_byte(&g_rom_settings.alarm_thres_min);
1148:easyrider.c   ****   }
1149:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.alarm_thres_max) != g_settings.alarm_thres_max) {
1150:easyrider.c   ****     g_settings.alarm_thres_max = eeprom_read_word(&g_rom_settings.alarm_thres_max);
1151:easyrider.c   ****   }
1152:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.backpedal) != g_settings.backpedal) {
1153:easyrider.c   ****     g_settings.backpedal = eeprom_read_byte(&g_rom_settings.backpedal);
1154:easyrider.c   ****   }
1155:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.backpedal_thres_min) != g_settings.backpedal_thres_min) {
1156:easyrider.c   ****     g_settings.backpedal_thres_min = eeprom_read_word(&g_rom_settings.backpedal_thres_min);
1157:easyrider.c   ****   }
1158:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.startup_sound) != g_settings.startup_sound) {
1159:easyrider.c   ****     g_settings.startup_sound = eeprom_read_byte(&g_rom_settings.startup_sound);
1160:easyrider.c   ****   }
1161:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_sound) != g_settings.alarm_sound) {
1162:easyrider.c   ****     g_settings.alarm_sound = eeprom_read_byte(&g_rom_settings.alarm_sound);
1163:easyrider.c   ****   }
1164:easyrider.c   ****   char passwd[32];
1165:easyrider.c   ****   eeprom_read_block((void*)passwd, (const void*)g_rom_settings.passwd, 32);
1166:easyrider.c   ****   if (strcmp(passwd, g_settings.passwd) != 0) {
1167:easyrider.c   ****     strcpy(g_settings.passwd, passwd);
1168:easyrider.c   ****   }
1169:easyrider.c   ****   g_sleep_counter = g_settings.deep_sleep_counter;
1170:easyrider.c   ****   reset_ports();
1171:easyrider.c   ****   start_sense_timer();
1172:easyrider.c   ****   start_blink_timer();
1173:easyrider.c   ****   start_buzzer_timer(0);
1174:easyrider.c   ****   uart_init();
1175:easyrider.c   ****   command_init(command_usart_input, command_usart_output);
1176:easyrider.c   ****   register_commands();
1177:easyrider.c   **** }
1178:easyrider.c   **** 
1179:easyrider.c   **** // duration of note based on the 5ms timer counter
1180:easyrider.c   **** // 200x 5ms ticks * 60sec/tempo in bmp * (beat note type / length)
1181:easyrider.c   **** // length is normally 1, 2, 4, 8 or 16 parts of a full note
1182:easyrider.c   **** uint16_t calc_note_duration(const uint16_t length) {
1183:easyrider.c   ****   return 200*60/g_music_tempo*g_music_denominator/length;
1184:easyrider.c   **** }
1185:easyrider.c   **** 
1186:easyrider.c   **** int main(void) {
 2465               		.loc 1 1186 0
 2466               		.cfi_startproc
 2467 0000 CF93      		push r28
 2468               	.LCFI21:
 2469               		.cfi_def_cfa_offset 3
 2470               		.cfi_offset 28, -2
 2471 0002 DF93      		push r29
 2472               	.LCFI22:
 2473               		.cfi_def_cfa_offset 4
 2474               		.cfi_offset 29, -3
 2475 0004 CDB7      		in r28,__SP_L__
 2476 0006 DEB7      		in r29,__SP_H__
 2477               	.LCFI23:
 2478               		.cfi_def_cfa_register 28
 2479 0008 A097      		sbiw r28,32
 2480               	.LCFI24:
 2481               		.cfi_def_cfa_offset 36
 2482 000a 0FB6      		in __tmp_reg__,__SREG__
 2483 000c F894      		cli
 2484 000e DEBF      		out __SP_H__,r29
 2485 0010 0FBE      		out __SREG__,__tmp_reg__
 2486 0012 CDBF      		out __SP_L__,r28
 2487               	/* prologue: function */
 2488               	/* frame size = 32 */
 2489               	/* stack size = 34 */
 2490               	.L__stack_usage = 34
 2491               	.LBB424:
 2492               	.LBB425:
1114:easyrider.c   ****   MCUCR = 0x80; // disable JTAG at runtime (2 calls in a row needed)
 2493               		.loc 1 1114 0
 2494 0014 80E8      		ldi r24,lo8(-128)
 2495 0016 85BF      		out 0x35,r24
1115:easyrider.c   ****   MCUCR = 0x80;
 2496               		.loc 1 1115 0
 2497 0018 85BF      		out 0x35,r24
1116:easyrider.c   ****   wdt_enable(WDTO_2S);  // enable 2 sec watchdog
 2498               		.loc 1 1116 0
 2499 001a 2FE0      		ldi r18,lo8(15)
 2500 001c 88E1      		ldi r24,lo8(24)
 2501 001e 90E0      		ldi r25,0
 2502               	/* #APP */
 2503               	 ;  1116 "easyrider.c" 1
 2504 0020 0FB6      		in __tmp_reg__,__SREG__
 2505 0022 F894      		cli
 2506 0024 A895      		wdr
 2507 0026 8093 6000 		sts 96,r24
 2508 002a 0FBE      		out __SREG__,__tmp_reg__
 2509 002c 2093 6000 		sts 96,r18
 2510               		
 2511               	 ;  0 "" 2
1117:easyrider.c   ****   sei(); //  enable global interrupts
 2512               		.loc 1 1117 0
 2513               	 ;  1117 "easyrider.c" 1
 2514 0030 7894      		sei
 2515               	 ;  0 "" 2
 2516               	/* #NOAPP */
 2517               	.LBB426:
 2518               	.LBB427:
 963:easyrider.c   ****   ADMUX = (ADMUX & 0xF8) | g_adc_read_pin; // clear the bottom 3 bits before setting new pin
 2519               		.loc 1 963 0
 2520 0032 8091 7C00 		lds r24,124
 2521 0036 9091 0000 		lds r25,g_adc_read_pin
 2522 003a 887F      		andi r24,lo8(-8)
 2523 003c 892B      		or r24,r25
 2524 003e 8093 7C00 		sts 124,r24
 964:easyrider.c   ****   ADMUX |= (1 << REFS0); // voltage reference = AVcc
 2525               		.loc 1 964 0
 2526 0042 8091 7C00 		lds r24,124
 2527 0046 8064      		ori r24,lo8(64)
 2528 0048 8093 7C00 		sts 124,r24
 965:easyrider.c   ****   DIDR0 = 0x0F;  // disable digital inputs for ADC0-ADC3 
 2529               		.loc 1 965 0
 2530 004c 8FE0      		ldi r24,lo8(15)
 2531 004e 8093 7E00 		sts 126,r24
 966:easyrider.c   ****   ADCSRA |= (1 << ADEN); // enable ADC
 2532               		.loc 1 966 0
 2533 0052 8091 7A00 		lds r24,122
 2534 0056 8068      		ori r24,lo8(-128)
 2535 0058 8093 7A00 		sts 122,r24
 967:easyrider.c   ****   ADCSRA |= (1 << ADPS2) | (1 << ADPS1 ) | (1 << ADPS0); // prescaler = 128
 2536               		.loc 1 967 0
 2537 005c 8091 7A00 		lds r24,122
 2538 0060 8760      		ori r24,lo8(7)
 2539 0062 8093 7A00 		sts 122,r24
 968:easyrider.c   ****   ADCSRA |= (1 << ADIE); // enable interrupt
 2540               		.loc 1 968 0
 2541 0066 8091 7A00 		lds r24,122
 2542 006a 8860      		ori r24,lo8(8)
 2543 006c 8093 7A00 		sts 122,r24
 969:easyrider.c   ****   ADCSRA |= (1 << ADSC); // start a conversion
 2544               		.loc 1 969 0
 2545 0070 8091 7A00 		lds r24,122
 2546 0074 8064      		ori r24,lo8(64)
 2547 0076 8093 7A00 		sts 122,r24
 2548               	.LBE427:
 2549               	.LBE426:
1119:easyrider.c   ****   g_state = ST_SLEEP; // always start in sleep mode
 2550               		.loc 1 1119 0
 2551 007a 80E0      		ldi r24,0
 2552 007c 92E0      		ldi r25,lo8(2)
 2553 007e 9093 0000 		sts g_state+1,r25
 2554 0082 8093 0000 		sts g_state,r24
1120:easyrider.c   ****   g_buffer_head = g_buffer_tail = 0; // init event buffer
 2555               		.loc 1 1120 0
 2556 0086 1092 0000 		sts g_buffer_tail,__zero_reg__
 2557 008a 1092 0000 		sts g_buffer_head,__zero_reg__
1122:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.deep_sleep_counter) != g_settings.deep_sleep_counter) {
 2558               		.loc 1 1122 0
 2559 008e 80E0      		ldi r24,lo8(g_rom_settings)
 2560 0090 90E0      		ldi r25,hi8(g_rom_settings)
 2561 0092 0E94 0000 		call __eerd_word_m1284p
 2562               	.LVL28:
 2563 0096 2091 0000 		lds r18,g_settings
 2564 009a 3091 0000 		lds r19,g_settings+1
 2565 009e 8217      		cp r24,r18
 2566 00a0 9307      		cpc r25,r19
 2567 00a2 01F0      		breq .L231
1123:easyrider.c   ****     g_settings.deep_sleep_counter = eeprom_read_word(&g_rom_settings.deep_sleep_counter);
 2568               		.loc 1 1123 0
 2569 00a4 9093 0000 		sts g_settings+1,r25
 2570 00a8 8093 0000 		sts g_settings,r24
 2571               	.L231:
1125:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.settle_time) != g_settings.settle_time) {
 2572               		.loc 1 1125 0
 2573 00ac 80E0      		ldi r24,lo8(g_rom_settings+2)
 2574 00ae 90E0      		ldi r25,hi8(g_rom_settings+2)
 2575 00b0 0E94 0000 		call __eerd_word_m1284p
 2576               	.LVL29:
 2577 00b4 2091 0000 		lds r18,g_settings+2
 2578 00b8 3091 0000 		lds r19,g_settings+2+1
 2579 00bc 8217      		cp r24,r18
 2580 00be 9307      		cpc r25,r19
 2581 00c0 01F0      		breq .L232
1126:easyrider.c   ****     g_settings.settle_time = eeprom_read_word(&g_rom_settings.settle_time);
 2582               		.loc 1 1126 0
 2583 00c2 9093 0000 		sts g_settings+2+1,r25
 2584 00c6 8093 0000 		sts g_settings+2,r24
 2585               	.L232:
1128:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.alarm_settle_time) != g_settings.alarm_settle_time) {
 2586               		.loc 1 1128 0
 2587 00ca 80E0      		ldi r24,lo8(g_rom_settings+4)
 2588 00cc 90E0      		ldi r25,hi8(g_rom_settings+4)
 2589 00ce 0E94 0000 		call __eerd_word_m1284p
 2590               	.LVL30:
 2591 00d2 2091 0000 		lds r18,g_settings+4
 2592 00d6 3091 0000 		lds r19,g_settings+4+1
 2593 00da 8217      		cp r24,r18
 2594 00dc 9307      		cpc r25,r19
 2595 00de 01F0      		breq .L233
1129:easyrider.c   ****     g_settings.alarm_settle_time = eeprom_read_word(&g_rom_settings.alarm_settle_time);
 2596               		.loc 1 1129 0
 2597 00e0 9093 0000 		sts g_settings+4+1,r25
 2598 00e4 8093 0000 		sts g_settings+4,r24
 2599               	.L233:
1131:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.indicator_sound) != g_settings.indicator_sound) {
 2600               		.loc 1 1131 0
 2601 00e8 80E0      		ldi r24,lo8(g_rom_settings+6)
 2602 00ea 90E0      		ldi r25,hi8(g_rom_settings+6)
 2603 00ec 0E94 0000 		call __eerd_byte_m1284p
 2604               	.LVL31:
 2605 00f0 9091 0000 		lds r25,g_settings+6
 2606 00f4 8913      		cpse r24,r25
1132:easyrider.c   ****     g_settings.indicator_sound = eeprom_read_byte(&g_rom_settings.indicator_sound);
 2607               		.loc 1 1132 0
 2608 00f6 8093 0000 		sts g_settings+6,r24
 2609               	.L234:
1134:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.blink_speed) != g_settings.blink_speed) {
 2610               		.loc 1 1134 0
 2611 00fa 80E0      		ldi r24,lo8(g_rom_settings+7)
 2612 00fc 90E0      		ldi r25,hi8(g_rom_settings+7)
 2613 00fe 0E94 0000 		call __eerd_word_m1284p
 2614               	.LVL32:
 2615 0102 2091 0000 		lds r18,g_settings+7
 2616 0106 3091 0000 		lds r19,g_settings+7+1
 2617 010a 8217      		cp r24,r18
 2618 010c 9307      		cpc r25,r19
 2619 010e 01F0      		breq .L235
1135:easyrider.c   ****     g_settings.blink_speed = eeprom_read_word(&g_rom_settings.blink_speed);
 2620               		.loc 1 1135 0
 2621 0110 9093 0000 		sts g_settings+7+1,r25
 2622 0114 8093 0000 		sts g_settings+7,r24
 2623               	.L235:
1137:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_counter) != g_settings.alarm_counter) {
 2624               		.loc 1 1137 0
 2625 0118 80E0      		ldi r24,lo8(g_rom_settings+9)
 2626 011a 90E0      		ldi r25,hi8(g_rom_settings+9)
 2627 011c 0E94 0000 		call __eerd_byte_m1284p
 2628               	.LVL33:
 2629 0120 9091 0000 		lds r25,g_settings+9
 2630 0124 8913      		cpse r24,r25
1138:easyrider.c   ****     g_settings.alarm_counter = eeprom_read_byte(&g_rom_settings.alarm_counter);
 2631               		.loc 1 1138 0
 2632 0126 8093 0000 		sts g_settings+9,r24
 2633               	.L236:
1140:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_trigger) != g_settings.alarm_trigger) {
 2634               		.loc 1 1140 0
 2635 012a 80E0      		ldi r24,lo8(g_rom_settings+10)
 2636 012c 90E0      		ldi r25,hi8(g_rom_settings+10)
 2637 012e 0E94 0000 		call __eerd_byte_m1284p
 2638               	.LVL34:
 2639 0132 9091 0000 		lds r25,g_settings+10
 2640 0136 8913      		cpse r24,r25
1141:easyrider.c   ****     g_settings.alarm_trigger = eeprom_read_byte(&g_rom_settings.alarm_trigger);
 2641               		.loc 1 1141 0
 2642 0138 8093 0000 		sts g_settings+10,r24
 2643               	.L237:
1143:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_trigger_counter) != g_settings.alarm_trigger_counter) 
 2644               		.loc 1 1143 0
 2645 013c 80E0      		ldi r24,lo8(g_rom_settings+11)
 2646 013e 90E0      		ldi r25,hi8(g_rom_settings+11)
 2647 0140 0E94 0000 		call __eerd_byte_m1284p
 2648               	.LVL35:
 2649 0144 9091 0000 		lds r25,g_settings+11
 2650 0148 8913      		cpse r24,r25
1144:easyrider.c   ****     g_settings.alarm_trigger_counter = eeprom_read_byte(&g_rom_settings.alarm_trigger_counter);
 2651               		.loc 1 1144 0
 2652 014a 8093 0000 		sts g_settings+11,r24
 2653               	.L238:
1146:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_thres_min) != g_settings.alarm_thres_min) {
 2654               		.loc 1 1146 0
 2655 014e 80E0      		ldi r24,lo8(g_rom_settings+12)
 2656 0150 90E0      		ldi r25,hi8(g_rom_settings+12)
 2657 0152 0E94 0000 		call __eerd_byte_m1284p
 2658               	.LVL36:
 2659 0156 9091 0000 		lds r25,g_settings+12
 2660 015a 8913      		cpse r24,r25
1147:easyrider.c   ****     g_settings.alarm_thres_min = eeprom_read_byte(&g_rom_settings.alarm_thres_min);
 2661               		.loc 1 1147 0
 2662 015c 8093 0000 		sts g_settings+12,r24
 2663               	.L239:
1149:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.alarm_thres_max) != g_settings.alarm_thres_max) {
 2664               		.loc 1 1149 0
 2665 0160 80E0      		ldi r24,lo8(g_rom_settings+13)
 2666 0162 90E0      		ldi r25,hi8(g_rom_settings+13)
 2667 0164 0E94 0000 		call __eerd_word_m1284p
 2668               	.LVL37:
 2669 0168 2091 0000 		lds r18,g_settings+13
 2670 016c 3091 0000 		lds r19,g_settings+13+1
 2671 0170 8217      		cp r24,r18
 2672 0172 9307      		cpc r25,r19
 2673 0174 01F0      		breq .L240
1150:easyrider.c   ****     g_settings.alarm_thres_max = eeprom_read_word(&g_rom_settings.alarm_thres_max);
 2674               		.loc 1 1150 0
 2675 0176 9093 0000 		sts g_settings+13+1,r25
 2676 017a 8093 0000 		sts g_settings+13,r24
 2677               	.L240:
1152:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.backpedal) != g_settings.backpedal) {
 2678               		.loc 1 1152 0
 2679 017e 80E0      		ldi r24,lo8(g_rom_settings+15)
 2680 0180 90E0      		ldi r25,hi8(g_rom_settings+15)
 2681 0182 0E94 0000 		call __eerd_byte_m1284p
 2682               	.LVL38:
 2683 0186 9091 0000 		lds r25,g_settings+15
 2684 018a 8913      		cpse r24,r25
1153:easyrider.c   ****     g_settings.backpedal = eeprom_read_byte(&g_rom_settings.backpedal);
 2685               		.loc 1 1153 0
 2686 018c 8093 0000 		sts g_settings+15,r24
 2687               	.L241:
1155:easyrider.c   ****   if (eeprom_read_word(&g_rom_settings.backpedal_thres_min) != g_settings.backpedal_thres_min) {
 2688               		.loc 1 1155 0
 2689 0190 80E0      		ldi r24,lo8(g_rom_settings+16)
 2690 0192 90E0      		ldi r25,hi8(g_rom_settings+16)
 2691 0194 0E94 0000 		call __eerd_word_m1284p
 2692               	.LVL39:
 2693 0198 2091 0000 		lds r18,g_settings+16
 2694 019c 3091 0000 		lds r19,g_settings+16+1
 2695 01a0 8217      		cp r24,r18
 2696 01a2 9307      		cpc r25,r19
 2697 01a4 01F0      		breq .L242
1156:easyrider.c   ****     g_settings.backpedal_thres_min = eeprom_read_word(&g_rom_settings.backpedal_thres_min);
 2698               		.loc 1 1156 0
 2699 01a6 9093 0000 		sts g_settings+16+1,r25
 2700 01aa 8093 0000 		sts g_settings+16,r24
 2701               	.L242:
1158:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.startup_sound) != g_settings.startup_sound) {
 2702               		.loc 1 1158 0
 2703 01ae 80E0      		ldi r24,lo8(g_rom_settings+18)
 2704 01b0 90E0      		ldi r25,hi8(g_rom_settings+18)
 2705 01b2 0E94 0000 		call __eerd_byte_m1284p
 2706               	.LVL40:
 2707 01b6 9091 0000 		lds r25,g_settings+18
 2708 01ba 8913      		cpse r24,r25
1159:easyrider.c   ****     g_settings.startup_sound = eeprom_read_byte(&g_rom_settings.startup_sound);
 2709               		.loc 1 1159 0
 2710 01bc 8093 0000 		sts g_settings+18,r24
 2711               	.L243:
1161:easyrider.c   ****   if (eeprom_read_byte(&g_rom_settings.alarm_sound) != g_settings.alarm_sound) {
 2712               		.loc 1 1161 0
 2713 01c0 80E0      		ldi r24,lo8(g_rom_settings+19)
 2714 01c2 90E0      		ldi r25,hi8(g_rom_settings+19)
 2715 01c4 0E94 0000 		call __eerd_byte_m1284p
 2716               	.LVL41:
 2717 01c8 9091 0000 		lds r25,g_settings+19
 2718 01cc 8913      		cpse r24,r25
1162:easyrider.c   ****     g_settings.alarm_sound = eeprom_read_byte(&g_rom_settings.alarm_sound);
 2719               		.loc 1 1162 0
 2720 01ce 8093 0000 		sts g_settings+19,r24
 2721               	.L244:
1165:easyrider.c   ****   eeprom_read_block((void*)passwd, (const void*)g_rom_settings.passwd, 32);
 2722               		.loc 1 1165 0
 2723 01d2 40E2      		ldi r20,lo8(32)
 2724 01d4 50E0      		ldi r21,0
 2725 01d6 60E0      		ldi r22,lo8(g_rom_settings+20)
 2726 01d8 70E0      		ldi r23,hi8(g_rom_settings+20)
 2727 01da CE01      		movw r24,r28
 2728 01dc 0196      		adiw r24,1
 2729 01de 0E94 0000 		call __eerd_block_m1284p
 2730               	.LVL42:
1166:easyrider.c   ****   if (strcmp(passwd, g_settings.passwd) != 0) {
 2731               		.loc 1 1166 0
 2732 01e2 60E0      		ldi r22,lo8(g_settings+20)
 2733 01e4 70E0      		ldi r23,hi8(g_settings+20)
 2734 01e6 CE01      		movw r24,r28
 2735 01e8 0196      		adiw r24,1
 2736 01ea 0E94 0000 		call strcmp
 2737               	.LVL43:
 2738 01ee 892B      		or r24,r25
 2739 01f0 01F0      		breq .L245
1167:easyrider.c   ****     strcpy(g_settings.passwd, passwd);
 2740               		.loc 1 1167 0
 2741 01f2 BE01      		movw r22,r28
 2742 01f4 6F5F      		subi r22,-1
 2743 01f6 7F4F      		sbci r23,-1
 2744 01f8 80E0      		ldi r24,lo8(g_settings+20)
 2745 01fa 90E0      		ldi r25,hi8(g_settings+20)
 2746 01fc 0E94 0000 		call strcpy
 2747               	.LVL44:
 2748               	.L245:
1169:easyrider.c   ****   g_sleep_counter = g_settings.deep_sleep_counter;
 2749               		.loc 1 1169 0
 2750 0200 8091 0000 		lds r24,g_settings
 2751 0204 9091 0000 		lds r25,g_settings+1
 2752 0208 9093 0000 		sts g_sleep_counter+1,r25
 2753 020c 8093 0000 		sts g_sleep_counter,r24
1170:easyrider.c   ****   reset_ports();
 2754               		.loc 1 1170 0
 2755 0210 0E94 0000 		call reset_ports
 2756               	.LVL45:
 2757               	.LBB428:
 2758               	.LBB429:
 992:easyrider.c   ****   TCCR0B |= (1 << WGM02); // CTC Mode
 2759               		.loc 1 992 0
 2760 0214 85B5      		in r24,0x25
 2761 0216 8860      		ori r24,lo8(8)
 2762 0218 85BD      		out 0x25,r24
 993:easyrider.c   ****   TCCR0A |= (1 << WGM01) | (0 << WGM00); // CTC Mode
 2763               		.loc 1 993 0
 2764 021a 84B5      		in r24,0x24
 2765 021c 8260      		ori r24,lo8(2)
 2766 021e 84BD      		out 0x24,r24
 994:easyrider.c   ****   TCCR0B |= ((1 << CS00) | (1 << CS02)); // prescale 1024
 2767               		.loc 1 994 0
 2768 0220 85B5      		in r24,0x25
 2769 0222 8560      		ori r24,lo8(5)
 2770 0224 85BD      		out 0x25,r24
 995:easyrider.c   ****   TCCR0B &= ~(1 << CS01); // prescale 1024
 2771               		.loc 1 995 0
 2772 0226 85B5      		in r24,0x25
 2773 0228 8D7F      		andi r24,lo8(-3)
 2774 022a 85BD      		out 0x25,r24
 996:easyrider.c   ****   TIMSK0 |= (1 << OCIE0A); // Enable CTC interrupt
 2775               		.loc 1 996 0
 2776 022c 8091 6E00 		lds r24,110
 2777 0230 8260      		ori r24,lo8(2)
 2778 0232 8093 6E00 		sts 110,r24
 997:easyrider.c   ****   OCR0A = 97; // Set CTC compare value, approx. 5 ms -> 200 times/sec
 2779               		.loc 1 997 0
 2780 0236 81E6      		ldi r24,lo8(97)
 2781 0238 87BD      		out 0x27,r24
 2782               	.LBE429:
 2783               	.LBE428:
 2784               	.LBB430:
 2785               	.LBB431:
1003:easyrider.c   ****   TCCR1A &= ~((1 << WGM11) | (1 << WGM10)); // CTC Mode
 2786               		.loc 1 1003 0
 2787 023a 8091 8000 		lds r24,128
 2788 023e 8C7F      		andi r24,lo8(-4)
 2789 0240 8093 8000 		sts 128,r24
1004:easyrider.c   ****   TCCR1B |= (1 << WGM12); // CTC Mode
 2790               		.loc 1 1004 0
 2791 0244 8091 8100 		lds r24,129
 2792 0248 8860      		ori r24,lo8(8)
 2793 024a 8093 8100 		sts 129,r24
1005:easyrider.c   ****   TCCR1B |= ((1 << CS10) | (1 << CS12)); // prescale 1024
 2794               		.loc 1 1005 0
 2795 024e 8091 8100 		lds r24,129
 2796 0252 8560      		ori r24,lo8(5)
 2797 0254 8093 8100 		sts 129,r24
1006:easyrider.c   ****   TCCR1B &= ~(1 << CS11); // prescale 1024
 2798               		.loc 1 1006 0
 2799 0258 8091 8100 		lds r24,129
 2800 025c 8D7F      		andi r24,lo8(-3)
 2801 025e 8093 8100 		sts 129,r24
1007:easyrider.c   ****   TIMSK1 |= (1 << OCIE1A); // Enable Compare A interrupt
 2802               		.loc 1 1007 0
 2803 0262 8091 6F00 		lds r24,111
 2804 0266 8260      		ori r24,lo8(2)
 2805 0268 8093 6F00 		sts 111,r24
1008:easyrider.c   ****   OCR1A = g_settings.blink_speed; // Set CTC compare value, default approx. 0.5 secs
 2806               		.loc 1 1008 0
 2807 026c 8091 0000 		lds r24,g_settings+7
 2808 0270 9091 0000 		lds r25,g_settings+7+1
 2809 0274 9093 8900 		sts 136+1,r25
 2810 0278 8093 8800 		sts 136,r24
 2811               	.LVL46:
 2812               	.LBE431:
 2813               	.LBE430:
 2814               	.LBB432:
 2815               	.LBB433:
1013:easyrider.c   ****   TCCR3A &= ~((1 << WGM31) | (1 << WGM30)); // CTC Mode
 2816               		.loc 1 1013 0
 2817 027c 8091 9000 		lds r24,144
 2818 0280 8C7F      		andi r24,lo8(-4)
 2819 0282 8093 9000 		sts 144,r24
1014:easyrider.c   ****   TCCR3B |= (1 << WGM32); // CTC Mode
 2820               		.loc 1 1014 0
 2821 0286 8091 9100 		lds r24,145
 2822 028a 8860      		ori r24,lo8(8)
 2823 028c 8093 9100 		sts 145,r24
1015:easyrider.c   ****   TCCR3B |= ((1 << CS31) | (1 << CS30)); // prescale 64
 2824               		.loc 1 1015 0
 2825 0290 8091 9100 		lds r24,145
 2826 0294 8360      		ori r24,lo8(3)
 2827 0296 8093 9100 		sts 145,r24
1016:easyrider.c   ****   TCCR3B &= ~(1 << CS32); // prescale 64
 2828               		.loc 1 1016 0
 2829 029a 8091 9100 		lds r24,145
 2830 029e 8B7F      		andi r24,lo8(-5)
 2831 02a0 8093 9100 		sts 145,r24
1020:easyrider.c   ****   OCR3A = 68; // Set CTC compare value, approx. 4600hz: with a square wave that is a 2400hz tone
 2832               		.loc 1 1020 0
 2833 02a4 84E4      		ldi r24,lo8(68)
 2834 02a6 90E0      		ldi r25,0
 2835 02a8 9093 9900 		sts 152+1,r25
 2836 02ac 8093 9800 		sts 152,r24
 2837               	.LBE433:
 2838               	.LBE432:
1174:easyrider.c   ****   uart_init();
 2839               		.loc 1 1174 0
 2840 02b0 0E94 0000 		call uart_init
 2841               	.LVL47:
1175:easyrider.c   ****   command_init(command_usart_input, command_usart_output);
 2842               		.loc 1 1175 0
 2843 02b4 60E0      		ldi r22,lo8(gs(command_usart_output))
 2844 02b6 70E0      		ldi r23,hi8(gs(command_usart_output))
 2845 02b8 80E0      		ldi r24,lo8(gs(command_usart_input))
 2846 02ba 90E0      		ldi r25,hi8(gs(command_usart_input))
 2847 02bc 0E94 0000 		call command_init
 2848               	.LVL48:
1176:easyrider.c   ****   register_commands();
 2849               		.loc 1 1176 0
 2850 02c0 0E94 0000 		call register_commands
 2851               	.LVL49:
 2852               	.LBE425:
 2853               	.LBE424:
 2854               	.LBB434:
 2855               	.LBB435:
 2856               	.LBB436:
 2857               	.LBB437:
 2858               	.LBB438:
 2859               	.LBB439:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 2860               		.loc 1 553 0
 2861 02c4 69E0      		ldi r22,lo8(9)
 2862 02c6 C62E      		mov r12,r22
 2863               	.LBE439:
 2864               	.LBE438:
 2865               	.LBB442:
 2866               	.LBB443:
 2867 02c8 78E0      		ldi r23,lo8(8)
 2868 02ca D72E      		mov r13,r23
 2869               	.LBE443:
 2870               	.LBE442:
 2871               	.LBE437:
 2872               	.LBE436:
 2873               	.LBB464:
 2874               	.LBB465:
 2875               	.LBB466:
 418:easyrider.c   ****         song_idx = 2 + (uint8_t)(rand() / (RAND_MAX / 5));
 2876               		.loc 1 418 0
 2877 02cc E9E9      		ldi r30,lo8(-103)
 2878 02ce 8E2E      		mov r8,r30
 2879 02d0 E9E1      		ldi r30,lo8(25)
 2880 02d2 9E2E      		mov r9,r30
 2881               	.LBE466:
 2882               	.LBE465:
 2883               	.LBE464:
 2884               	.LBB471:
 2885               	.LBB472:
 2886               	.LBB473:
 2887               	.LBB474:
1183:easyrider.c   ****   return 200*60/g_music_tempo*g_music_denominator/length;
 2888               		.loc 1 1183 0
 2889 02d4 F0EE      		ldi r31,lo8(-32)
 2890 02d6 2F2E      		mov r2,r31
 2891 02d8 FEE2      		ldi r31,lo8(46)
 2892 02da 3F2E      		mov r3,r31
 2893               	.LBE474:
 2894               	.LBE473:
 2895               	.LBE472:
 2896               	.LBE471:
 2897               	.LBB485:
 2898               	.LBB486:
 2899               	.LBB487:
 449:easyrider.c   ****         song_idx = 1 + (uint8_t)(rand() / (RAND_MAX / 6));
 2900               		.loc 1 449 0
 2901 02dc A5E5      		ldi r26,lo8(85)
 2902 02de 4A2E      		mov r4,r26
 2903 02e0 A5E1      		ldi r26,lo8(21)
 2904 02e2 5A2E      		mov r5,r26
 2905               	.LBE487:
 2906               	.LBE486:
 2907               	.LBE485:
 2908               	.LBB495:
 2909               	.LBB496:
 515:easyrider.c   ****           g_state = ST_ALARM_SETTLE; // go back to new alarm settle mode
 2910               		.loc 1 515 0
 2911 02e4 612C      		mov r6,__zero_reg__
 2912 02e6 7724      		clr r7
 2913 02e8 7394      		inc r7
 2914               	.L246:
 2915               	.LBE496:
 2916               	.LBE495:
 2917               	.LBE435:
 2918               	.LBE434:
1187:easyrider.c   ****   initialize();
1188:easyrider.c   ****   while(1) {
1189:easyrider.c   ****     command_process();
 2919               		.loc 1 1189 0
 2920 02ea 0E94 0000 		call command_process
 2921               	.LVL50:
 2922               	.LBB778:
 2923               	.LBB776:
 2924               	.LBB505:
 2925               	.LBB458:
 297:easyrider.c   ****   if ((g_senses & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
 2926               		.loc 1 297 0
 2927 02ee 8091 0000 		lds r24,g_senses
 2928 02f2 9091 0000 		lds r25,g_senses+1
 2929 02f6 84FF      		sbrs r24,4
 2930 02f8 00C0      		rjmp .L248
 298:easyrider.c   ****     if (~STATUS_C90_SENSE_BRAKE) {
 2931               		.loc 1 298 0
 2932 02fa 189B      		sbis 0x3,0
 2933 02fc 00C0      		rjmp .L569
 2934               	.L250:
 301:easyrider.c   ****     if (STATUS_C90_SENSE_BRAKE) {
 2935               		.loc 1 301 0
 2936 02fe 1899      		sbic 0x3,0
 2937 0300 00C0      		rjmp .L570
 2938               	.L248:
 306:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
 2939               		.loc 1 306 0
 2940 0302 8091 0000 		lds r24,g_dyn_senses
 2941 0306 9091 0000 		lds r25,g_dyn_senses+1
 2942 030a 84FF      		sbrs r24,4
 2943 030c 00C0      		rjmp .L258
 307:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
 2944               		.loc 1 307 0
 2945 030e 8091 0000 		lds r24,g_dyn_senses_status
 2946 0312 9091 0000 		lds r25,g_dyn_senses_status+1
 2947               	.LBB446:
 2948               	.LBB447:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 2949               		.loc 1 553 0
 2950 0316 E091 0000 		lds r30,g_buffer_head
 2951 031a F0E0      		ldi r31,0
 2952 031c E050      		subi r30,lo8(-(g_event_buffer))
 2953 031e F040      		sbci r31,hi8(-(g_event_buffer))
 2954               	.LBE447:
 2955               	.LBE446:
 307:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
 2956               		.loc 1 307 0
 2957 0320 84FD      		sbrc r24,4
 2958 0322 00C0      		rjmp .L571
 2959               	.LVL51:
 2960               	.LBB449:
 2961               	.LBB450:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 2962               		.loc 1 553 0
 2963 0324 D082      		st Z,r13
 2964               	.LVL52:
 2965               	.L552:
 554:easyrider.c   ****   g_buffer_head++; // advance head
 2966               		.loc 1 554 0
 2967 0326 8091 0000 		lds r24,g_buffer_head
 2968 032a 8F5F      		subi r24,lo8(-(1))
 2969 032c 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 2970               		.loc 1 555 0
 2971 0330 8091 0000 		lds r24,g_buffer_head
 2972 0334 8034      		cpi r24,lo8(64)
 2973 0336 00F0      		brlo .L263
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 2974               		.loc 1 556 0
 2975 0338 1092 0000 		sts g_buffer_head,__zero_reg__
 2976               	.L263:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 2977               		.loc 1 558 0
 2978 033c 9091 0000 		lds r25,g_buffer_head
 2979 0340 8091 0000 		lds r24,g_buffer_tail
 2980 0344 9817      		cp r25,r24
 2981 0346 01F4      		brne .+2
 2982 0348 00C0      		rjmp .L572
 2983               	.L264:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 2984               		.loc 1 561 0
 2985 034a 8091 0000 		lds r24,g_buffer_tail
 2986 034e 8034      		cpi r24,lo8(64)
 2987 0350 00F0      		brlo .L258
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 2988               		.loc 1 562 0
 2989 0352 1092 0000 		sts g_buffer_tail,__zero_reg__
 2990               	.L258:
 2991               	.LBE450:
 2992               	.LBE449:
 2993               	.LBE458:
 2994               	.LBE505:
 2995               	.LBB506:
 2996               	.LBB507:
 237:easyrider.c   ****   if ((g_senses & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
 2997               		.loc 1 237 0
 2998 0356 8091 0000 		lds r24,g_senses
 2999 035a 9091 0000 		lds r25,g_senses+1
 3000 035e 87FF      		sbrs r24,7
 3001 0360 00C0      		rjmp .L266
 238:easyrider.c   ****     if (~STATUS_C90_SENSE_CLAXON) {
 3002               		.loc 1 238 0
 3003 0362 1B9B      		sbis 0x3,3
 3004 0364 00C0      		rjmp .L573
 3005               	.L268:
 241:easyrider.c   ****     if (STATUS_C90_SENSE_CLAXON) {
 3006               		.loc 1 241 0
 3007 0366 1B99      		sbic 0x3,3
 3008 0368 00C0      		rjmp .L574
 3009               	.L266:
 246:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
 3010               		.loc 1 246 0
 3011 036a 8091 0000 		lds r24,g_dyn_senses
 3012 036e 9091 0000 		lds r25,g_dyn_senses+1
 3013 0372 87FF      		sbrs r24,7
 3014 0374 00C0      		rjmp .L276
 247:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
 3015               		.loc 1 247 0
 3016 0376 8091 0000 		lds r24,g_dyn_senses_status
 3017 037a 9091 0000 		lds r25,g_dyn_senses_status+1
 3018               	.LBB508:
 3019               	.LBB509:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3020               		.loc 1 553 0
 3021 037e E091 0000 		lds r30,g_buffer_head
 3022 0382 F0E0      		ldi r31,0
 3023 0384 E050      		subi r30,lo8(-(g_event_buffer))
 3024 0386 F040      		sbci r31,hi8(-(g_event_buffer))
 3025               	.LBE509:
 3026               	.LBE508:
 247:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
 3027               		.loc 1 247 0
 3028 0388 87FD      		sbrc r24,7
 3029 038a 00C0      		rjmp .L575
 3030               	.LVL53:
 3031               	.LBB511:
 3032               	.LBB512:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3033               		.loc 1 553 0
 3034 038c 86E0      		ldi r24,lo8(6)
 3035               	.LVL54:
 3036               	.L554:
 3037 038e 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3038               		.loc 1 554 0
 3039 0390 8091 0000 		lds r24,g_buffer_head
 3040 0394 8F5F      		subi r24,lo8(-(1))
 3041 0396 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3042               		.loc 1 555 0
 3043 039a 8091 0000 		lds r24,g_buffer_head
 3044 039e 8034      		cpi r24,lo8(64)
 3045 03a0 00F0      		brlo .L281
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3046               		.loc 1 556 0
 3047 03a2 1092 0000 		sts g_buffer_head,__zero_reg__
 3048               	.L281:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3049               		.loc 1 558 0
 3050 03a6 9091 0000 		lds r25,g_buffer_head
 3051 03aa 8091 0000 		lds r24,g_buffer_tail
 3052 03ae 9817      		cp r25,r24
 3053 03b0 01F4      		brne .+2
 3054 03b2 00C0      		rjmp .L576
 3055               	.L282:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3056               		.loc 1 561 0
 3057 03b4 8091 0000 		lds r24,g_buffer_tail
 3058 03b8 8034      		cpi r24,lo8(64)
 3059 03ba 00F0      		brlo .L276
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3060               		.loc 1 562 0
 3061 03bc 1092 0000 		sts g_buffer_tail,__zero_reg__
 3062               	.L276:
 3063               	.LBE512:
 3064               	.LBE511:
 3065               	.LBE507:
 3066               	.LBE506:
 3067               	.LBB528:
 3068               	.LBB529:
 197:easyrider.c   ****   if ((g_senses & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) {
 3069               		.loc 1 197 0
 3070 03c0 8091 0000 		lds r24,g_senses
 3071 03c4 9091 0000 		lds r25,g_senses+1
 3072 03c8 80FF      		sbrs r24,0
 3073 03ca 00C0      		rjmp .L284
 198:easyrider.c   ****     if (~STATUS_C90_SENSE_LIGHT_RI) { // low, RI on
 3074               		.loc 1 198 0
 3075 03cc 049B      		sbis 0,4
 3076 03ce 00C0      		rjmp .L577
 3077               	.L286:
 201:easyrider.c   ****     if (STATUS_C90_SENSE_LIGHT_RI) { // RI off
 3078               		.loc 1 201 0
 3079 03d0 0499      		sbic 0,4
 3080 03d2 00C0      		rjmp .L578
 3081               	.L284:
 206:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) {
 3082               		.loc 1 206 0
 3083 03d4 8091 0000 		lds r24,g_dyn_senses
 3084 03d8 9091 0000 		lds r25,g_dyn_senses+1
 3085 03dc 80FF      		sbrs r24,0
 3086 03de 00C0      		rjmp .L294
 207:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) { // high, RI off
 3087               		.loc 1 207 0
 3088 03e0 8091 0000 		lds r24,g_dyn_senses_status
 3089 03e4 9091 0000 		lds r25,g_dyn_senses_status+1
 3090               	.LBB530:
 3091               	.LBB531:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3092               		.loc 1 553 0
 3093 03e8 E091 0000 		lds r30,g_buffer_head
 3094 03ec F0E0      		ldi r31,0
 3095 03ee E050      		subi r30,lo8(-(g_event_buffer))
 3096 03f0 F040      		sbci r31,hi8(-(g_event_buffer))
 3097               	.LBE531:
 3098               	.LBE530:
 207:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) { // high, RI off
 3099               		.loc 1 207 0
 3100 03f2 80FD      		sbrc r24,0
 3101 03f4 00C0      		rjmp .L579
 3102               	.LVL55:
 3103               	.LBB533:
 3104               	.LBB534:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3105               		.loc 1 553 0
 3106 03f6 82E0      		ldi r24,lo8(2)
 3107               	.LVL56:
 3108               	.L556:
 3109 03f8 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3110               		.loc 1 554 0
 3111 03fa 8091 0000 		lds r24,g_buffer_head
 3112 03fe 8F5F      		subi r24,lo8(-(1))
 3113 0400 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3114               		.loc 1 555 0
 3115 0404 8091 0000 		lds r24,g_buffer_head
 3116 0408 8034      		cpi r24,lo8(64)
 3117 040a 00F0      		brlo .L299
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3118               		.loc 1 556 0
 3119 040c 1092 0000 		sts g_buffer_head,__zero_reg__
 3120               	.L299:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3121               		.loc 1 558 0
 3122 0410 9091 0000 		lds r25,g_buffer_head
 3123 0414 8091 0000 		lds r24,g_buffer_tail
 3124 0418 9817      		cp r25,r24
 3125 041a 01F4      		brne .+2
 3126 041c 00C0      		rjmp .L580
 3127               	.L300:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3128               		.loc 1 561 0
 3129 041e 8091 0000 		lds r24,g_buffer_tail
 3130 0422 8034      		cpi r24,lo8(64)
 3131 0424 00F0      		brlo .L294
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3132               		.loc 1 562 0
 3133 0426 1092 0000 		sts g_buffer_tail,__zero_reg__
 3134               	.L294:
 3135               	.LBE534:
 3136               	.LBE533:
 3137               	.LBE529:
 3138               	.LBE528:
 3139               	.LBB552:
 3140               	.LBB553:
 217:easyrider.c   ****   if ((g_senses & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) {
 3141               		.loc 1 217 0
 3142 042a 8091 0000 		lds r24,g_senses
 3143 042e 9091 0000 		lds r25,g_senses+1
 3144 0432 81FF      		sbrs r24,1
 3145 0434 00C0      		rjmp .L302
 218:easyrider.c   ****     if (~STATUS_C90_SENSE_LIGHT_LI) { // low, LI on
 3146               		.loc 1 218 0
 3147 0436 059B      		sbis 0,5
 3148 0438 00C0      		rjmp .L581
 3149               	.L304:
 221:easyrider.c   ****     if (STATUS_C90_SENSE_LIGHT_LI) { // LI off
 3150               		.loc 1 221 0
 3151 043a 0599      		sbic 0,5
 3152 043c 00C0      		rjmp .L582
 3153               	.L302:
 226:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) {
 3154               		.loc 1 226 0
 3155 043e 8091 0000 		lds r24,g_dyn_senses
 3156 0442 9091 0000 		lds r25,g_dyn_senses+1
 3157 0446 81FF      		sbrs r24,1
 3158 0448 00C0      		rjmp .L312
 227:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) { // high, LI off
 3159               		.loc 1 227 0
 3160 044a 8091 0000 		lds r24,g_dyn_senses_status
 3161 044e 9091 0000 		lds r25,g_dyn_senses_status+1
 3162               	.LBB554:
 3163               	.LBB555:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3164               		.loc 1 553 0
 3165 0452 E091 0000 		lds r30,g_buffer_head
 3166 0456 F0E0      		ldi r31,0
 3167 0458 E050      		subi r30,lo8(-(g_event_buffer))
 3168 045a F040      		sbci r31,hi8(-(g_event_buffer))
 3169               	.LBE555:
 3170               	.LBE554:
 227:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) { // high, LI off
 3171               		.loc 1 227 0
 3172 045c 81FD      		sbrc r24,1
 3173 045e 00C0      		rjmp .L583
 3174               	.LVL57:
 3175               	.LBB557:
 3176               	.LBB558:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3177               		.loc 1 553 0
 3178 0460 83E0      		ldi r24,lo8(3)
 3179               	.LVL58:
 3180               	.L558:
 3181 0462 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3182               		.loc 1 554 0
 3183 0464 8091 0000 		lds r24,g_buffer_head
 3184 0468 8F5F      		subi r24,lo8(-(1))
 3185 046a 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3186               		.loc 1 555 0
 3187 046e 8091 0000 		lds r24,g_buffer_head
 3188 0472 8034      		cpi r24,lo8(64)
 3189 0474 00F0      		brlo .L317
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3190               		.loc 1 556 0
 3191 0476 1092 0000 		sts g_buffer_head,__zero_reg__
 3192               	.L317:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3193               		.loc 1 558 0
 3194 047a 9091 0000 		lds r25,g_buffer_head
 3195 047e 8091 0000 		lds r24,g_buffer_tail
 3196 0482 9817      		cp r25,r24
 3197 0484 01F4      		brne .+2
 3198 0486 00C0      		rjmp .L584
 3199               	.L318:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3200               		.loc 1 561 0
 3201 0488 8091 0000 		lds r24,g_buffer_tail
 3202 048c 8034      		cpi r24,lo8(64)
 3203 048e 00F0      		brlo .L312
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3204               		.loc 1 562 0
 3205 0490 1092 0000 		sts g_buffer_tail,__zero_reg__
 3206               	.L312:
 3207               	.LBE558:
 3208               	.LBE557:
 3209               	.LBE553:
 3210               	.LBE552:
 3211               	.LBB576:
 3212               	.LBB577:
 277:easyrider.c   ****   if ((g_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
 3213               		.loc 1 277 0
 3214 0494 8091 0000 		lds r24,g_senses
 3215 0498 9091 0000 		lds r25,g_senses+1
 3216 049c 83FF      		sbrs r24,3
 3217 049e 00C0      		rjmp .L320
 278:easyrider.c   ****     if (~STATUS_C90_SENSE_LIGHT) {
 3218               		.loc 1 278 0
 3219 04a0 0799      		sbic 0,7
 3220 04a2 00C0      		rjmp .L322
 3221               	.LVL59:
 3222               	.LBB578:
 3223               	.LBB579:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3224               		.loc 1 553 0
 3225 04a4 E091 0000 		lds r30,g_buffer_head
 3226 04a8 F0E0      		ldi r31,0
 3227 04aa E050      		subi r30,lo8(-(g_event_buffer))
 3228 04ac F040      		sbci r31,hi8(-(g_event_buffer))
 3229 04ae 8CE0      		ldi r24,lo8(12)
 3230 04b0 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3231               		.loc 1 554 0
 3232 04b2 8091 0000 		lds r24,g_buffer_head
 3233 04b6 8F5F      		subi r24,lo8(-(1))
 3234 04b8 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3235               		.loc 1 555 0
 3236 04bc 8091 0000 		lds r24,g_buffer_head
 3237 04c0 8034      		cpi r24,lo8(64)
 3238 04c2 00F0      		brlo .L323
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3239               		.loc 1 556 0
 3240 04c4 1092 0000 		sts g_buffer_head,__zero_reg__
 3241               	.L323:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3242               		.loc 1 558 0
 3243 04c8 9091 0000 		lds r25,g_buffer_head
 3244 04cc 8091 0000 		lds r24,g_buffer_tail
 3245 04d0 9817      		cp r25,r24
 3246 04d2 01F4      		brne .+2
 3247 04d4 00C0      		rjmp .L585
 3248               	.L324:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3249               		.loc 1 561 0
 3250 04d6 8091 0000 		lds r24,g_buffer_tail
 3251 04da 8034      		cpi r24,lo8(64)
 3252 04dc 00F0      		brlo .L322
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3253               		.loc 1 562 0
 3254 04de 1092 0000 		sts g_buffer_tail,__zero_reg__
 3255               	.LVL60:
 3256               	.L322:
 3257               	.LBE579:
 3258               	.LBE578:
 281:easyrider.c   ****     if (STATUS_C90_SENSE_LIGHT) {
 3259               		.loc 1 281 0
 3260 04e2 0799      		sbic 0,7
 3261 04e4 00C0      		rjmp .L586
 3262               	.L320:
 286:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
 3263               		.loc 1 286 0
 3264 04e6 8091 0000 		lds r24,g_dyn_senses
 3265 04ea 9091 0000 		lds r25,g_dyn_senses+1
 3266 04ee 83FF      		sbrs r24,3
 3267 04f0 00C0      		rjmp .L330
 287:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
 3268               		.loc 1 287 0
 3269 04f2 8091 0000 		lds r24,g_dyn_senses_status
 3270 04f6 9091 0000 		lds r25,g_dyn_senses_status+1
 3271               	.LBB581:
 3272               	.LBB582:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3273               		.loc 1 553 0
 3274 04fa E091 0000 		lds r30,g_buffer_head
 3275 04fe F0E0      		ldi r31,0
 3276 0500 E050      		subi r30,lo8(-(g_event_buffer))
 3277 0502 F040      		sbci r31,hi8(-(g_event_buffer))
 3278               	.LBE582:
 3279               	.LBE581:
 287:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
 3280               		.loc 1 287 0
 3281 0504 83FD      		sbrc r24,3
 3282 0506 00C0      		rjmp .L587
 3283               	.LVL61:
 3284               	.LBB584:
 3285               	.LBB585:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3286               		.loc 1 553 0
 3287 0508 8CE0      		ldi r24,lo8(12)
 3288               	.LVL62:
 3289               	.L560:
 3290 050a 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3291               		.loc 1 554 0
 3292 050c 8091 0000 		lds r24,g_buffer_head
 3293 0510 8F5F      		subi r24,lo8(-(1))
 3294 0512 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3295               		.loc 1 555 0
 3296 0516 8091 0000 		lds r24,g_buffer_head
 3297 051a 8034      		cpi r24,lo8(64)
 3298 051c 00F0      		brlo .L335
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3299               		.loc 1 556 0
 3300 051e 1092 0000 		sts g_buffer_head,__zero_reg__
 3301               	.L335:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3302               		.loc 1 558 0
 3303 0522 9091 0000 		lds r25,g_buffer_head
 3304 0526 8091 0000 		lds r24,g_buffer_tail
 3305 052a 9817      		cp r25,r24
 3306 052c 01F4      		brne .+2
 3307 052e 00C0      		rjmp .L588
 3308               	.L336:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3309               		.loc 1 561 0
 3310 0530 8091 0000 		lds r24,g_buffer_tail
 3311 0534 8034      		cpi r24,lo8(64)
 3312 0536 00F0      		brlo .L330
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3313               		.loc 1 562 0
 3314 0538 1092 0000 		sts g_buffer_tail,__zero_reg__
 3315               	.L330:
 3316               	.LBE585:
 3317               	.LBE584:
 3318               	.LBE577:
 3319               	.LBE576:
 3320               	.LBB596:
 3321               	.LBB597:
 257:easyrider.c   ****   if ((g_senses & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
 3322               		.loc 1 257 0
 3323 053c 8091 0000 		lds r24,g_senses
 3324 0540 9091 0000 		lds r25,g_senses+1
 3325 0544 82FF      		sbrs r24,2
 3326 0546 00C0      		rjmp .L338
 258:easyrider.c   ****     if (~STATUS_C90_SENSE_PILOT) {
 3327               		.loc 1 258 0
 3328 0548 069B      		sbis 0,6
 3329 054a 00C0      		rjmp .L589
 3330               	.L340:
 261:easyrider.c   ****     if (STATUS_C90_SENSE_PILOT) {
 3331               		.loc 1 261 0
 3332 054c 0699      		sbic 0,6
 3333 054e 00C0      		rjmp .L590
 3334               	.L338:
 266:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
 3335               		.loc 1 266 0
 3336 0550 8091 0000 		lds r24,g_dyn_senses
 3337 0554 9091 0000 		lds r25,g_dyn_senses+1
 3338 0558 82FF      		sbrs r24,2
 3339 055a 00C0      		rjmp .L348
 267:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
 3340               		.loc 1 267 0
 3341 055c 8091 0000 		lds r24,g_dyn_senses_status
 3342 0560 9091 0000 		lds r25,g_dyn_senses_status+1
 3343               	.LBB598:
 3344               	.LBB599:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3345               		.loc 1 553 0
 3346 0564 E091 0000 		lds r30,g_buffer_head
 3347 0568 F0E0      		ldi r31,0
 3348 056a E050      		subi r30,lo8(-(g_event_buffer))
 3349 056c F040      		sbci r31,hi8(-(g_event_buffer))
 3350               	.LBE599:
 3351               	.LBE598:
 267:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
 3352               		.loc 1 267 0
 3353 056e 82FD      		sbrc r24,2
 3354 0570 00C0      		rjmp .L591
 3355               	.LVL63:
 3356               	.LBB601:
 3357               	.LBB602:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3358               		.loc 1 553 0
 3359 0572 8AE0      		ldi r24,lo8(10)
 3360               	.LVL64:
 3361               	.L562:
 3362 0574 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3363               		.loc 1 554 0
 3364 0576 8091 0000 		lds r24,g_buffer_head
 3365 057a 8F5F      		subi r24,lo8(-(1))
 3366 057c 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3367               		.loc 1 555 0
 3368 0580 8091 0000 		lds r24,g_buffer_head
 3369 0584 8034      		cpi r24,lo8(64)
 3370 0586 00F0      		brlo .L353
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3371               		.loc 1 556 0
 3372 0588 1092 0000 		sts g_buffer_head,__zero_reg__
 3373               	.L353:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3374               		.loc 1 558 0
 3375 058c 9091 0000 		lds r25,g_buffer_head
 3376 0590 8091 0000 		lds r24,g_buffer_tail
 3377 0594 9817      		cp r25,r24
 3378 0596 01F4      		brne .+2
 3379 0598 00C0      		rjmp .L592
 3380               	.L354:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3381               		.loc 1 561 0
 3382 059a 8091 0000 		lds r24,g_buffer_tail
 3383 059e 8034      		cpi r24,lo8(64)
 3384 05a0 00F0      		brlo .L348
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3385               		.loc 1 562 0
 3386 05a2 1092 0000 		sts g_buffer_tail,__zero_reg__
 3387               	.L348:
 3388               	.LBE602:
 3389               	.LBE601:
 3390               	.LBE597:
 3391               	.LBE596:
 3392               	.LBB618:
 3393               	.LBB619:
 317:easyrider.c   ****   if ((g_senses & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
 3394               		.loc 1 317 0
 3395 05a6 8091 0000 		lds r24,g_senses
 3396 05aa 9091 0000 		lds r25,g_senses+1
 3397 05ae 86FF      		sbrs r24,6
 3398 05b0 00C0      		rjmp .L356
 318:easyrider.c   ****     if (~STATUS_C90_SENSE_IGN) {
 3399               		.loc 1 318 0
 3400 05b2 1A9B      		sbis 0x3,2
 3401 05b4 00C0      		rjmp .L593
 3402               	.L358:
 321:easyrider.c   ****     if (STATUS_C90_SENSE_IGN) {
 3403               		.loc 1 321 0
 3404 05b6 1A99      		sbic 0x3,2
 3405 05b8 00C0      		rjmp .L594
 3406               	.L356:
 326:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
 3407               		.loc 1 326 0
 3408 05ba 8091 0000 		lds r24,g_dyn_senses
 3409 05be 9091 0000 		lds r25,g_dyn_senses+1
 3410 05c2 86FF      		sbrs r24,6
 3411 05c4 00C0      		rjmp .L366
 327:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
 3412               		.loc 1 327 0
 3413 05c6 8091 0000 		lds r24,g_dyn_senses_status
 3414 05ca 9091 0000 		lds r25,g_dyn_senses_status+1
 3415               	.LBB620:
 3416               	.LBB621:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3417               		.loc 1 553 0
 3418 05ce E091 0000 		lds r30,g_buffer_head
 3419 05d2 F0E0      		ldi r31,0
 3420 05d4 E050      		subi r30,lo8(-(g_event_buffer))
 3421 05d6 F040      		sbci r31,hi8(-(g_event_buffer))
 3422               	.LBE621:
 3423               	.LBE620:
 327:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
 3424               		.loc 1 327 0
 3425 05d8 86FD      		sbrc r24,6
 3426 05da 00C0      		rjmp .L595
 3427               	.LVL65:
 3428               	.LBB623:
 3429               	.LBB624:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3430               		.loc 1 553 0
 3431 05dc 82E1      		ldi r24,lo8(18)
 3432               	.LVL66:
 3433               	.L564:
 3434 05de 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3435               		.loc 1 554 0
 3436 05e0 8091 0000 		lds r24,g_buffer_head
 3437 05e4 8F5F      		subi r24,lo8(-(1))
 3438 05e6 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3439               		.loc 1 555 0
 3440 05ea 8091 0000 		lds r24,g_buffer_head
 3441 05ee 8034      		cpi r24,lo8(64)
 3442 05f0 00F0      		brlo .L371
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3443               		.loc 1 556 0
 3444 05f2 1092 0000 		sts g_buffer_head,__zero_reg__
 3445               	.L371:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3446               		.loc 1 558 0
 3447 05f6 9091 0000 		lds r25,g_buffer_head
 3448 05fa 8091 0000 		lds r24,g_buffer_tail
 3449 05fe 9817      		cp r25,r24
 3450 0600 01F4      		brne .+2
 3451 0602 00C0      		rjmp .L596
 3452               	.L372:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3453               		.loc 1 561 0
 3454 0604 8091 0000 		lds r24,g_buffer_tail
 3455 0608 8034      		cpi r24,lo8(64)
 3456 060a 00F0      		brlo .L366
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3457               		.loc 1 562 0
 3458 060c 1092 0000 		sts g_buffer_tail,__zero_reg__
 3459               	.L366:
 3460               	.LBE624:
 3461               	.LBE623:
 3462               	.LBE619:
 3463               	.LBE618:
 3464               	.LBB642:
 3465               	.LBB469:
 398:easyrider.c   ****   if (g_state == ST_SETTLE) {
 3466               		.loc 1 398 0
 3467 0610 8091 0000 		lds r24,g_state
 3468 0614 9091 0000 		lds r25,g_state+1
 3469 0618 8115      		cp r24,__zero_reg__
 3470 061a 9440      		sbci r25,4
 3471 061c 01F4      		brne .+2
 3472 061e 00C0      		rjmp .L597
 3473               	.L374:
 3474               	.LBE469:
 3475               	.LBE642:
 3476               	.LBB643:
 3477               	.LBB481:
1073:easyrider.c   ****   if (FLAG_MUSIC) {
 3478               		.loc 1 1073 0
 3479 0620 8091 0000 		lds r24,FLAG_MUSIC
 3480 0624 8823      		tst r24
 3481 0626 01F4      		brne .+2
 3482 0628 00C0      		rjmp .L378
1074:easyrider.c   ****     if (!g_music_duration) {
 3483               		.loc 1 1074 0
 3484 062a 8091 0000 		lds r24,g_music_duration
 3485 062e 9091 0000 		lds r25,g_music_duration+1
 3486 0632 892B      		or r24,r25
 3487 0634 01F0      		breq .+2
 3488 0636 00C0      		rjmp .L378
 3489               	.LBB476:
1075:easyrider.c   ****       if (pgm_read_word(g_current_music)) { // get note data until MUSIC_END
 3490               		.loc 1 1075 0
 3491 0638 8091 0000 		lds r24,g_current_music
 3492 063c 9091 0000 		lds r25,g_current_music+1
 3493               	.LVL67:
 3494 0640 FC01      		movw r30,r24
 3495               	/* #APP */
 3496               	 ;  1075 "easyrider.c" 1
 3497 0642 2591      		lpm r18, Z+
 3498 0644 3491      		lpm r19, Z
 3499               		
 3500               	 ;  0 "" 2
 3501               	.LVL68:
 3502               	/* #NOAPP */
 3503               	.LBE476:
 3504 0646 2115      		cp r18,__zero_reg__
 3505 0648 3105      		cpc r19,__zero_reg__
 3506 064a 01F4      		brne .+2
 3507 064c 00C0      		rjmp .L379
1076:easyrider.c   ****         if (g_current_music == g_selected_music) { // still at start: first byte is the tempo
 3508               		.loc 1 1076 0
 3509 064e 4091 0000 		lds r20,g_selected_music
 3510 0652 5091 0000 		lds r21,g_selected_music+1
 3511 0656 8417      		cp r24,r20
 3512 0658 9507      		cpc r25,r21
 3513 065a 01F4      		brne .+2
 3514 065c 00C0      		rjmp .L380
 3515 065e 6091 0000 		lds r22,g_music_tempo
 3516 0662 9C01      		movw r18,r24
 3517               	.LVL69:
 3518               	.L381:
 3519               	.LBB477:
1080:easyrider.c   ****         g_music_duration = calc_note_duration(pgm_read_word(g_current_music));
 3520               		.loc 1 1080 0
 3521 0664 FC01      		movw r30,r24
 3522               	/* #APP */
 3523               	 ;  1080 "easyrider.c" 1
 3524 0666 E590      		lpm r14, Z+
 3525 0668 F490      		lpm r15, Z
 3526               		
 3527               	 ;  0 "" 2
 3528               	.LVL70:
 3529               	/* #NOAPP */
 3530               	.LBE477:
 3531               	.LBB478:
 3532               	.LBB475:
1183:easyrider.c   ****   return 200*60/g_music_tempo*g_music_denominator/length;
 3533               		.loc 1 1183 0
 3534 066a 70E0      		ldi r23,0
 3535 066c C101      		movw r24,r2
 3536 066e 0E94 0000 		call __divmodhi4
 3537 0672 CB01      		movw r24,r22
 3538 0674 880F      		lsl r24
 3539 0676 991F      		rol r25
 3540 0678 880F      		lsl r24
 3541 067a 991F      		rol r25
 3542 067c B701      		movw r22,r14
 3543 067e 0E94 0000 		call __udivmodhi4
 3544               	.LBE475:
 3545               	.LBE478:
1080:easyrider.c   ****         g_music_duration = calc_note_duration(pgm_read_word(g_current_music));
 3546               		.loc 1 1080 0
 3547 0682 7093 0000 		sts g_music_duration+1,r23
 3548 0686 6093 0000 		sts g_music_duration,r22
1081:easyrider.c   ****         g_current_music++;
 3549               		.loc 1 1081 0
 3550 068a 2E5F      		subi r18,-2
 3551 068c 3F4F      		sbci r19,-1
 3552 068e 3093 0000 		sts g_current_music+1,r19
 3553 0692 2093 0000 		sts g_current_music,r18
 3554               	.LVL71:
 3555               	.LBB479:
1082:easyrider.c   ****         if (pgm_read_word(g_current_music) == MUSIC_P) { // pause check (silence for a certain time
 3556               		.loc 1 1082 0
 3557 0696 F901      		movw r30,r18
 3558               	/* #APP */
 3559               	 ;  1082 "easyrider.c" 1
 3560 0698 8591      		lpm r24, Z+
 3561 069a 9491      		lpm r25, Z
 3562               		
 3563               	 ;  0 "" 2
 3564               	.LVL72:
 3565               	/* #NOAPP */
 3566               	.LBE479:
 3567 069c 0197      		sbiw r24,1
 3568 069e 01F4      		brne .+2
 3569 06a0 00C0      		rjmp .L598
1086:easyrider.c   ****           TIMSK3 |= (1 << OCIE3A); // enable interrupt
 3570               		.loc 1 1086 0
 3571 06a2 8091 7100 		lds r24,113
 3572               	.LVL73:
 3573 06a6 8260      		ori r24,lo8(2)
 3574 06a8 8093 7100 		sts 113,r24
 3575               	.L383:
 3576               	.LBB480:
1088:easyrider.c   ****         OCR3A = pgm_read_word(g_current_music);
 3577               		.loc 1 1088 0
 3578 06ac 8091 0000 		lds r24,g_current_music
 3579 06b0 9091 0000 		lds r25,g_current_music+1
 3580               	.LVL74:
 3581 06b4 FC01      		movw r30,r24
 3582               	/* #APP */
 3583               	 ;  1088 "easyrider.c" 1
 3584 06b6 2591      		lpm r18, Z+
 3585 06b8 3491      		lpm r19, Z
 3586               		
 3587               	 ;  0 "" 2
 3588               	.LVL75:
 3589               	/* #NOAPP */
 3590               	.LBE480:
 3591 06ba 3093 9900 		sts 152+1,r19
 3592 06be 2093 9800 		sts 152,r18
1089:easyrider.c   ****         TCNT3 = 0;
 3593               		.loc 1 1089 0
 3594 06c2 1092 9500 		sts 148+1,__zero_reg__
 3595 06c6 1092 9400 		sts 148,__zero_reg__
1090:easyrider.c   ****         g_current_music++;
 3596               		.loc 1 1090 0
 3597 06ca 0296      		adiw r24,2
 3598 06cc 9093 0000 		sts g_current_music+1,r25
 3599 06d0 8093 0000 		sts g_current_music,r24
 3600               	.LVL76:
 3601               	.L378:
 3602               	.LBE481:
 3603               	.LBE643:
 3604               	.LBB644:
 3605               	.LBB645:
 337:easyrider.c   ****   if ((g_senses & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
 3606               		.loc 1 337 0
 3607 06d4 8091 0000 		lds r24,g_senses
 3608 06d8 9091 0000 		lds r25,g_senses+1
 3609 06dc 85FF      		sbrs r24,5
 3610 06de 00C0      		rjmp .L385
 338:easyrider.c   ****     if (~STATUS_C90_SENSE_ALARM) {
 3611               		.loc 1 338 0
 3612 06e0 199B      		sbis 0x3,1
 3613 06e2 00C0      		rjmp .L599
 3614               	.L387:
 341:easyrider.c   ****     if (STATUS_C90_SENSE_ALARM) {
 3615               		.loc 1 341 0
 3616 06e4 1999      		sbic 0x3,1
 3617 06e6 00C0      		rjmp .L600
 3618               	.L385:
 346:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
 3619               		.loc 1 346 0
 3620 06e8 8091 0000 		lds r24,g_dyn_senses
 3621 06ec 9091 0000 		lds r25,g_dyn_senses+1
 3622 06f0 85FF      		sbrs r24,5
 3623 06f2 00C0      		rjmp .L395
 347:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
 3624               		.loc 1 347 0
 3625 06f4 8091 0000 		lds r24,g_dyn_senses_status
 3626 06f8 9091 0000 		lds r25,g_dyn_senses_status+1
 3627               	.LBB646:
 3628               	.LBB647:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3629               		.loc 1 553 0
 3630 06fc E091 0000 		lds r30,g_buffer_head
 3631 0700 F0E0      		ldi r31,0
 3632 0702 E050      		subi r30,lo8(-(g_event_buffer))
 3633 0704 F040      		sbci r31,hi8(-(g_event_buffer))
 3634               	.LBE647:
 3635               	.LBE646:
 347:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
 3636               		.loc 1 347 0
 3637 0706 85FD      		sbrc r24,5
 3638 0708 00C0      		rjmp .L601
 3639               	.LVL77:
 3640               	.LBB649:
 3641               	.LBB650:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3642               		.loc 1 553 0
 3643 070a 8EE0      		ldi r24,lo8(14)
 3644               	.LVL78:
 3645               	.L566:
 3646 070c 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3647               		.loc 1 554 0
 3648 070e 8091 0000 		lds r24,g_buffer_head
 3649 0712 8F5F      		subi r24,lo8(-(1))
 3650 0714 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3651               		.loc 1 555 0
 3652 0718 8091 0000 		lds r24,g_buffer_head
 3653 071c 8034      		cpi r24,lo8(64)
 3654 071e 00F0      		brlo .L400
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3655               		.loc 1 556 0
 3656 0720 1092 0000 		sts g_buffer_head,__zero_reg__
 3657               	.L400:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3658               		.loc 1 558 0
 3659 0724 9091 0000 		lds r25,g_buffer_head
 3660 0728 8091 0000 		lds r24,g_buffer_tail
 3661 072c 9817      		cp r25,r24
 3662 072e 01F4      		brne .+2
 3663 0730 00C0      		rjmp .L602
 3664               	.L401:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3665               		.loc 1 561 0
 3666 0732 8091 0000 		lds r24,g_buffer_tail
 3667 0736 8034      		cpi r24,lo8(64)
 3668 0738 00F0      		brlo .L395
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3669               		.loc 1 562 0
 3670 073a 1092 0000 		sts g_buffer_tail,__zero_reg__
 3671               	.L395:
 3672               	.LBE650:
 3673               	.LBE649:
 3674               	.LBE645:
 3675               	.LBE644:
 3676               	.LBB668:
 3677               	.LBB492:
 443:easyrider.c   ****   if (g_state == ST_ALARM_SETTLE) {
 3678               		.loc 1 443 0
 3679 073e 8091 0000 		lds r24,g_state
 3680 0742 9091 0000 		lds r25,g_state+1
 3681 0746 8115      		cp r24,__zero_reg__
 3682 0748 9140      		sbci r25,1
 3683 074a 01F4      		brne .+2
 3684 074c 00C0      		rjmp .L603
 3685               	.L403:
 3686               	.LBE492:
 3687               	.LBE668:
 3688               	.LBB669:
 3689               	.LBB499:
 501:easyrider.c   ****   if (g_state == ST_ALARM) {
 3690               		.loc 1 501 0
 3691 074e 8091 0000 		lds r24,g_state
 3692 0752 9091 0000 		lds r25,g_state+1
 3693 0756 8034      		cpi r24,64
 3694 0758 9105      		cpc r25,__zero_reg__
 3695 075a 01F4      		brne .+2
 3696 075c 00C0      		rjmp .L604
 3697               	.L414:
 3698               	.LBE499:
 3699               	.LBE669:
 3700               	.LBB670:
 3701               	.LBB671:
 3702               	.LBB672:
 3703               	.LBB673:
 104:easyrider.c   ****   return ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state);
 3704               		.loc 1 104 0
 3705 075e 8091 0000 		lds r24,g_state
 3706 0762 9091 0000 		lds r25,g_state+1
 3707 0766 2091 0000 		lds r18,g_state
 3708 076a 3091 0000 		lds r19,g_state+1
 3709 076e 8F7B      		andi r24,191
 3710 0770 987F      		andi r25,248
 3711               	.LBE673:
 3712               	.LBE672:
 356:easyrider.c   ****   if (check_battery_read()) {
 3713               		.loc 1 356 0
 3714 0772 8217      		cp r24,r18
 3715 0774 9307      		cpc r25,r19
 3716 0776 01F4      		brne .+2
 3717 0778 00C0      		rjmp .L605
 3718               	.L424:
 3719               	.LBE671:
 3720               	.LBE670:
 3721               	.LBB677:
 3722               	.LBB678:
 379:easyrider.c   ****   if ((g_senses & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
 3723               		.loc 1 379 0
 3724 077a 8091 0000 		lds r24,g_senses
 3725 077e 9091 0000 		lds r25,g_senses+1
 3726 0782 90FF      		sbrs r25,0
 3727 0784 00C0      		rjmp .L429
 380:easyrider.c   ****     if (~STATUS_C90_SENSE_WARNING) {
 3728               		.loc 1 380 0
 3729 0786 489B      		sbis 0x9,0
 3730 0788 00C0      		rjmp .L606
 3731               	.L431:
 383:easyrider.c   ****     if (STATUS_C90_SENSE_WARNING) {
 3732               		.loc 1 383 0
 3733 078a 4899      		sbic 0x9,0
 3734 078c 00C0      		rjmp .L607
 3735               	.L429:
 388:easyrider.c   ****   if ((g_dyn_senses & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
 3736               		.loc 1 388 0
 3737 078e 8091 0000 		lds r24,g_dyn_senses
 3738 0792 9091 0000 		lds r25,g_dyn_senses+1
 3739 0796 90FF      		sbrs r25,0
 3740 0798 00C0      		rjmp .L439
 389:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
 3741               		.loc 1 389 0
 3742 079a 8091 0000 		lds r24,g_dyn_senses_status
 3743 079e 9091 0000 		lds r25,g_dyn_senses_status+1
 3744               	.LBB679:
 3745               	.LBB680:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3746               		.loc 1 553 0
 3747 07a2 E091 0000 		lds r30,g_buffer_head
 3748 07a6 F0E0      		ldi r31,0
 3749 07a8 E050      		subi r30,lo8(-(g_event_buffer))
 3750 07aa F040      		sbci r31,hi8(-(g_event_buffer))
 3751               	.LBE680:
 3752               	.LBE679:
 389:easyrider.c   ****     if ((g_dyn_senses_status & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
 3753               		.loc 1 389 0
 3754 07ac 90FD      		sbrc r25,0
 3755 07ae 00C0      		rjmp .L608
 3756               	.LVL79:
 3757               	.LBB682:
 3758               	.LBB683:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3759               		.loc 1 553 0
 3760 07b0 84E1      		ldi r24,lo8(20)
 3761               	.LVL80:
 3762               	.L568:
 3763 07b2 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3764               		.loc 1 554 0
 3765 07b4 8091 0000 		lds r24,g_buffer_head
 3766 07b8 8F5F      		subi r24,lo8(-(1))
 3767 07ba 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3768               		.loc 1 555 0
 3769 07be 8091 0000 		lds r24,g_buffer_head
 3770 07c2 8034      		cpi r24,lo8(64)
 3771 07c4 00F0      		brlo .L444
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3772               		.loc 1 556 0
 3773 07c6 1092 0000 		sts g_buffer_head,__zero_reg__
 3774               	.L444:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3775               		.loc 1 558 0
 3776 07ca 9091 0000 		lds r25,g_buffer_head
 3777 07ce 8091 0000 		lds r24,g_buffer_tail
 3778 07d2 9817      		cp r25,r24
 3779 07d4 01F4      		brne .+2
 3780 07d6 00C0      		rjmp .L609
 3781               	.L445:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3782               		.loc 1 561 0
 3783 07d8 8091 0000 		lds r24,g_buffer_tail
 3784 07dc 8034      		cpi r24,lo8(64)
 3785 07de 00F0      		brlo .L439
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3786               		.loc 1 562 0
 3787 07e0 1092 0000 		sts g_buffer_tail,__zero_reg__
 3788               	.L439:
 3789               	.LBE683:
 3790               	.LBE682:
 3791               	.LBE678:
 3792               	.LBE677:
 3793               	.LBB700:
 3794               	.LBB701:
 362:easyrider.c   ****   if (g_state == ST_SLEEP) {
 3795               		.loc 1 362 0
 3796 07e4 8091 0000 		lds r24,g_state
 3797 07e8 9091 0000 		lds r25,g_state+1
 3798 07ec 8115      		cp r24,__zero_reg__
 3799 07ee 9240      		sbci r25,2
 3800 07f0 01F4      		brne .+2
 3801 07f2 00C0      		rjmp .L610
 367:easyrider.c   ****     g_sleep_counter = g_settings.deep_sleep_counter;
 3802               		.loc 1 367 0
 3803 07f4 8091 0000 		lds r24,g_settings
 3804 07f8 9091 0000 		lds r25,g_settings+1
 3805 07fc 9093 0000 		sts g_sleep_counter+1,r25
 3806 0800 8093 0000 		sts g_sleep_counter,r24
 3807               	.L447:
 3808               	.LBE701:
 3809               	.LBE700:
  98:easyrider.c   ****   if (g_settings.backpedal) {
 3810               		.loc 1 98 0
 3811 0804 8091 0000 		lds r24,g_settings+15
 3812 0808 8111      		cpse r24,__zero_reg__
 3813 080a 00C0      		rjmp .L611
 3814               	.L456:
 3815               	.LBE776:
 3816               	.LBE778:
 3817               	.LBB779:
 3818               	.LBB780:
 540:easyrider.c   ****   if (g_buffer_tail != g_buffer_head) { // not empty
 3819               		.loc 1 540 0 discriminator 1
 3820 080c 9091 0000 		lds r25,g_buffer_tail
 3821 0810 8091 0000 		lds r24,g_buffer_head
 3822 0814 9817      		cp r25,r24
 3823 0816 01F4      		brne .+2
 3824 0818 00C0      		rjmp .L457
 3825               	.L612:
 541:easyrider.c   ****     ev = g_event_buffer[g_buffer_tail];
 3826               		.loc 1 541 0
 3827 081a E091 0000 		lds r30,g_buffer_tail
 3828 081e F0E0      		ldi r31,0
 3829 0820 E050      		subi r30,lo8(-(g_event_buffer))
 3830 0822 F040      		sbci r31,hi8(-(g_event_buffer))
 3831 0824 9081      		ld r25,Z
 3832               	.LVL81:
 542:easyrider.c   ****     g_buffer_tail++;
 3833               		.loc 1 542 0
 3834 0826 8091 0000 		lds r24,g_buffer_tail
 3835 082a 8F5F      		subi r24,lo8(-(1))
 3836 082c 8093 0000 		sts g_buffer_tail,r24
 543:easyrider.c   ****     if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3837               		.loc 1 543 0
 3838 0830 8091 0000 		lds r24,g_buffer_tail
 3839 0834 8034      		cpi r24,lo8(64)
 3840 0836 00F0      		brlo .L458
 544:easyrider.c   ****       g_buffer_tail = 0;
 3841               		.loc 1 544 0
 3842 0838 1092 0000 		sts g_buffer_tail,__zero_reg__
 3843               	.L458:
 3844               	.LBE780:
 3845               	.LBE779:
1190:easyrider.c   ****     dispatch_events();
1191:easyrider.c   ****     while ((g_event = get_event()) != EV_VOID) { // handle the complete event queue in one go
 3846               		.loc 1 1191 0
 3847 083c 9093 0000 		sts g_event,r25
 3848 0840 9923      		tst r25
 3849 0842 01F0      		breq .L459
 3850 0844 00E0      		ldi r16,lo8(g_trans+2)
 3851 0846 10E0      		ldi r17,hi8(g_trans+2)
 3852 0848 A12C      		mov r10,__zero_reg__
 3853 084a B12C      		mov r11,__zero_reg__
 3854 084c 00C0      		rjmp .L460
 3855               	.LVL82:
 3856               	.L454:
 3857 084e FFEF      		ldi r31,-1
 3858 0850 AF1A      		sub r10,r31
 3859 0852 BF0A      		sbc r11,r31
 3860               	.LVL83:
 3861 0854 0B5F      		subi r16,-5
 3862 0856 1F4F      		sbci r17,-1
 3863               	.LBB782:
1192:easyrider.c   ****       for (uint8_t i=0; i<TR_CNT; i++) {
 3864               		.loc 1 1192 0
 3865 0858 24E1      		ldi r18,20
 3866 085a A216      		cp r10,r18
 3867 085c B104      		cpc r11,__zero_reg__
 3868 085e 01F0      		breq .L456
 3869               	.LVL84:
 3870               	.L460:
 3871 0860 F801      		movw r30,r16
 3872 0862 3297      		sbiw r30,2
1193:easyrider.c   ****         if (g_trans[i].check_func()) { // check if state matches
 3873               		.loc 1 1193 0
 3874 0864 0190      		ld __tmp_reg__,Z+
 3875 0866 F081      		ld r31,Z
 3876 0868 E02D      		mov r30,__tmp_reg__
 3877 086a 0995      		icall
 3878               	.LVL85:
 3879 086c 8823      		tst r24
 3880 086e 01F0      		breq .L454
1194:easyrider.c   ****           if (g_event == g_trans[i].event) { // check if event matches
 3881               		.loc 1 1194 0
 3882 0870 8091 0000 		lds r24,g_event
 3883 0874 F801      		movw r30,r16
 3884 0876 9081      		ld r25,Z
 3885 0878 9813      		cpse r25,r24
 3886 087a 00C0      		rjmp .L454
1195:easyrider.c   ****             g_trans[i].process_func(); // call event handler
 3887               		.loc 1 1195 0
 3888 087c F501      		movw r30,r10
 3889 087e EE0F      		lsl r30
 3890 0880 FF1F      		rol r31
 3891 0882 EE0F      		lsl r30
 3892 0884 FF1F      		rol r31
 3893 0886 EA0D      		add r30,r10
 3894 0888 FB1D      		adc r31,r11
 3895 088a E050      		subi r30,lo8(-(g_trans))
 3896 088c F040      		sbci r31,hi8(-(g_trans))
 3897 088e 0380      		ldd __tmp_reg__,Z+3
 3898 0890 F481      		ldd r31,Z+4
 3899 0892 E02D      		mov r30,__tmp_reg__
 3900 0894 0995      		icall
 3901               	.LVL86:
 3902               	.LBE782:
 3903               	.LBB783:
 3904               	.LBB781:
 540:easyrider.c   ****   if (g_buffer_tail != g_buffer_head) { // not empty
 3905               		.loc 1 540 0
 3906 0896 9091 0000 		lds r25,g_buffer_tail
 3907 089a 8091 0000 		lds r24,g_buffer_head
 3908 089e 9813      		cpse r25,r24
 3909 08a0 00C0      		rjmp .L612
 3910               	.LVL87:
 3911               	.L457:
 3912               	.LBE781:
 3913               	.LBE783:
1191:easyrider.c   ****     while ((g_event = get_event()) != EV_VOID) { // handle the complete event queue in one go
 3914               		.loc 1 1191 0
 3915 08a2 1092 0000 		sts g_event,__zero_reg__
 3916               	.L459:
1196:easyrider.c   ****             break;
1197:easyrider.c   ****           }
1198:easyrider.c   ****         }
1199:easyrider.c   ****       }
1200:easyrider.c   ****     }
1201:easyrider.c   ****     if (!g_mcu_reset) { 
 3917               		.loc 1 1201 0
 3918 08a6 8091 0000 		lds r24,g_mcu_reset
 3919 08aa 8111      		cpse r24,__zero_reg__
 3920 08ac 00C0      		rjmp .L246
1202:easyrider.c   ****       wdt_reset(); // reset the watchdog, i.e. don't reset the mcu
 3921               		.loc 1 1202 0
 3922               	/* #APP */
 3923               	 ;  1202 "easyrider.c" 1
 3924 08ae A895      		wdr
 3925               	 ;  0 "" 2
 3926               	/* #NOAPP */
 3927 08b0 00C0      		rjmp .L246
 3928               	.L611:
 3929               	.LBB784:
 3930               	.LBB777:
 3931               	.LBB709:
 3932               	.LBB710:
 3933               	.LBB711:
 139:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
 3934               		.loc 1 139 0
 3935 08b2 8091 0000 		lds r24,g_state
 3936 08b6 9091 0000 		lds r25,g_state+1
 3937 08ba 2091 0000 		lds r18,g_state
 3938 08be 3091 0000 		lds r19,g_state+1
 3939 08c2 897B      		andi r24,185
 3940 08c4 9927      		clr r25
 3941 08c6 8217      		cp r24,r18
 3942 08c8 9307      		cpc r25,r19
 3943 08ca 01F0      		breq .+2
 3944 08cc 00C0      		rjmp .L456
 140:easyrider.c   ****         ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEE
 3945               		.loc 1 140 0
 3946 08ce 8091 0000 		lds r24,g_state
 3947 08d2 9091 0000 		lds r25,g_state+1
 3948 08d6 2091 0000 		lds r18,g_state
 3949 08da 3091 0000 		lds r19,g_state+1
 3950 08de 897B      		andi r24,185
 3951 08e0 907F      		andi r25,240
 139:easyrider.c   ****   return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
 3952               		.loc 1 139 0
 3953 08e2 8217      		cp r24,r18
 3954 08e4 9307      		cpc r25,r19
 3955 08e6 01F0      		breq .+2
 3956 08e8 00C0      		rjmp .L456
 3957               	.LVL88:
 3958               	.LBE711:
 3959               	.LBE710:
 3960               	.LBB712:
 3961               	.LBB713:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 3962               		.loc 1 553 0
 3963 08ea E091 0000 		lds r30,g_buffer_head
 3964 08ee F0E0      		ldi r31,0
 3965 08f0 E050      		subi r30,lo8(-(g_event_buffer))
 3966 08f2 F040      		sbci r31,hi8(-(g_event_buffer))
 3967 08f4 86E1      		ldi r24,lo8(22)
 3968 08f6 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 3969               		.loc 1 554 0
 3970 08f8 8091 0000 		lds r24,g_buffer_head
 3971 08fc 8F5F      		subi r24,lo8(-(1))
 3972 08fe 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 3973               		.loc 1 555 0
 3974 0902 8091 0000 		lds r24,g_buffer_head
 3975 0906 8034      		cpi r24,lo8(64)
 3976 0908 00F0      		brlo .L463
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 3977               		.loc 1 556 0
 3978 090a 1092 0000 		sts g_buffer_head,__zero_reg__
 3979               	.L463:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 3980               		.loc 1 558 0
 3981 090e 9091 0000 		lds r25,g_buffer_head
 3982 0912 8091 0000 		lds r24,g_buffer_tail
 3983 0916 9817      		cp r25,r24
 3984 0918 01F4      		brne .+2
 3985 091a 00C0      		rjmp .L613
 3986               	.L452:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 3987               		.loc 1 561 0
 3988 091c 8091 0000 		lds r24,g_buffer_tail
 3989 0920 8034      		cpi r24,lo8(64)
 3990 0922 00F4      		brsh .+2
 3991 0924 00C0      		rjmp .L456
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 3992               		.loc 1 562 0
 3993 0926 1092 0000 		sts g_buffer_tail,__zero_reg__
 3994 092a 00C0      		rjmp .L456
 3995               	.LVL89:
 3996               	.L604:
 3997               	.LBE713:
 3998               	.LBE712:
 3999               	.LBE709:
 4000               	.LBB716:
 4001               	.LBB500:
 502:easyrider.c   ****     if (FLAG_ALARM_TRIGGER) {
 4002               		.loc 1 502 0
 4003 092c 8091 0000 		lds r24,FLAG_ALARM_TRIGGER
 4004 0930 8823      		tst r24
 4005 0932 01F4      		brne .+2
 4006 0934 00C0      		rjmp .L415
 503:easyrider.c   ****       if (FLAG_ALARM_BLINK) {
 4007               		.loc 1 503 0
 4008 0936 8091 0000 		lds r24,FLAG_ALARM_BLINK
 4009 093a 8823      		tst r24
 4010 093c 01F4      		brne .+2
 4011 093e 00C0      		rjmp .L414
 504:easyrider.c   ****         FLAG_ALARM_BLINK = 0;
 4012               		.loc 1 504 0
 4013 0940 1092 0000 		sts FLAG_ALARM_BLINK,__zero_reg__
 505:easyrider.c   ****         PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
 4014               		.loc 1 505 0
 4015 0944 88B1      		in r24,0x8
 4016 0946 91E0      		ldi r25,lo8(1)
 4017 0948 8927      		eor r24,r25
 4018 094a 88B9      		out 0x8,r24
 506:easyrider.c   ****         PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
 4019               		.loc 1 506 0
 4020 094c 88B1      		in r24,0x8
 4021 094e 8D25      		eor r24,r13
 4022 0950 88B9      		out 0x8,r24
 507:easyrider.c   ****         PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
 4023               		.loc 1 507 0
 4024 0952 88B1      		in r24,0x8
 4025 0954 92E0      		ldi r25,lo8(2)
 4026 0956 8927      		eor r24,r25
 4027 0958 88B9      		out 0x8,r24
 508:easyrider.c   ****         PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
 4028               		.loc 1 508 0
 4029 095a 88B1      		in r24,0x8
 4030 095c 90E1      		ldi r25,lo8(16)
 4031 095e 8927      		eor r24,r25
 4032 0960 88B9      		out 0x8,r24
 509:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 4033               		.loc 1 509 0
 4034 0962 88B1      		in r24,0x8
 4035 0964 94E0      		ldi r25,lo8(4)
 4036 0966 8927      		eor r24,r25
 4037 0968 88B9      		out 0x8,r24
 510:easyrider.c   ****         PORT_C90_CLAXON ^= (1 << PIN_C90_CLAXON);
 4038               		.loc 1 510 0
 4039 096a 8BB1      		in r24,0xb
 4040 096c 90E4      		ldi r25,lo8(64)
 4041 096e 8927      		eor r24,r25
 4042 0970 8BB9      		out 0xb,r24
 511:easyrider.c   ****         g_alarm_counter--;
 4043               		.loc 1 511 0
 4044 0972 8091 0000 		lds r24,g_alarm_counter
 4045 0976 8150      		subi r24,lo8(-(-1))
 4046 0978 8093 0000 		sts g_alarm_counter,r24
 512:easyrider.c   ****         if (!g_alarm_counter) {
 4047               		.loc 1 512 0
 4048 097c 8091 0000 		lds r24,g_alarm_counter
 4049 0980 8111      		cpse r24,__zero_reg__
 4050 0982 00C0      		rjmp .L414
 4051               	.LBB497:
 4052               	.LBB498:
 885:easyrider.c   ****   PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 4053               		.loc 1 885 0
 4054 0984 4298      		cbi 0x8,2
 886:easyrider.c   ****   PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 4055               		.loc 1 886 0
 4056 0986 4598      		cbi 0x8,5
 887:easyrider.c   ****   PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 4057               		.loc 1 887 0
 4058 0988 4098      		cbi 0x8,0
 888:easyrider.c   ****   PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 4059               		.loc 1 888 0
 4060 098a 4398      		cbi 0x8,3
 889:easyrider.c   ****   PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 4061               		.loc 1 889 0
 4062 098c 4198      		cbi 0x8,1
 890:easyrider.c   ****   PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 4063               		.loc 1 890 0
 4064 098e 4498      		cbi 0x8,4
 891:easyrider.c   ****   PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 4065               		.loc 1 891 0
 4066 0990 4798      		cbi 0x8,7
 892:easyrider.c   ****   PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 4067               		.loc 1 892 0
 4068 0992 5F98      		cbi 0xb,7
 893:easyrider.c   ****   PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 4069               		.loc 1 893 0
 4070 0994 4698      		cbi 0x8,6
 894:easyrider.c   ****   PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
 4071               		.loc 1 894 0
 4072 0996 5E98      		cbi 0xb,6
 4073               	.LBE498:
 4074               	.LBE497:
 514:easyrider.c   ****           FLAG_ALARM_TRIGGER = 0; // reset alarm trigger
 4075               		.loc 1 514 0
 4076 0998 1092 0000 		sts FLAG_ALARM_TRIGGER,__zero_reg__
 515:easyrider.c   ****           g_state = ST_ALARM_SETTLE; // go back to new alarm settle mode
 4077               		.loc 1 515 0
 4078 099c 7092 0000 		sts g_state+1,r7
 4079 09a0 6092 0000 		sts g_state,r6
 516:easyrider.c   ****           FLAG_ALARM_SETTLE = 0; // reset alarm settle
 4080               		.loc 1 516 0
 4081 09a4 1092 0000 		sts FLAG_ALARM_SETTLE,__zero_reg__
 4082 09a8 00C0      		rjmp .L414
 4083               	.L603:
 4084               	.LBE500:
 4085               	.LBE716:
 4086               	.LBB717:
 4087               	.LBB493:
 444:easyrider.c   ****     if (!FLAG_ALARM_SETTLE) { // first time in alarm settle mode
 4088               		.loc 1 444 0
 4089 09aa 8091 0000 		lds r24,FLAG_ALARM_SETTLE
 4090 09ae 8111      		cpse r24,__zero_reg__
 4091 09b0 00C0      		rjmp .L404
 4092               	.LBB489:
 445:easyrider.c   ****       uint8_t song_idx = g_settings.alarm_sound;
 4093               		.loc 1 445 0
 4094 09b2 8091 0000 		lds r24,g_settings+19
 4095               	.LVL90:
 447:easyrider.c   ****       if (song_idx == 0) {
 4096               		.loc 1 447 0
 4097 09b6 8111      		cpse r24,__zero_reg__
 4098 09b8 00C0      		rjmp .L405
 448:easyrider.c   ****         srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda 
 4099               		.loc 1 448 0
 4100 09ba 6091 0000 		lds r22,g_adc_voltage
 4101 09be 7091 0000 		lds r23,g_adc_voltage+1
 4102 09c2 8091 0000 		lds r24,g_adc_voltage+2
 4103 09c6 9091 0000 		lds r25,g_adc_voltage+2+1
 4104               	.LVL91:
 4105 09ca 4091 0000 		lds r20,g_adc_voltage+4
 4106 09ce 5091 0000 		lds r21,g_adc_voltage+4+1
 4107 09d2 2091 0000 		lds r18,g_adc_voltage+6
 4108 09d6 3091 0000 		lds r19,g_adc_voltage+6+1
 4109 09da 860F      		add r24,r22
 4110 09dc 971F      		adc r25,r23
 4111 09de 840F      		add r24,r20
 4112 09e0 951F      		adc r25,r21
 4113 09e2 820F      		add r24,r18
 4114 09e4 931F      		adc r25,r19
 4115 09e6 0E94 0000 		call srand
 4116               	.LVL92:
 449:easyrider.c   ****         song_idx = 1 + (uint8_t)(rand() / (RAND_MAX / 6));
 4117               		.loc 1 449 0
 4118 09ea 0E94 0000 		call rand
 4119               	.LVL93:
 4120 09ee B201      		movw r22,r4
 4121 09f0 0E94 0000 		call __divmodhi4
 4122 09f4 81E0      		ldi r24,lo8(1)
 4123 09f6 860F      		add r24,r22
 4124               	.LVL94:
 4125               	.L405:
 451:easyrider.c   ****       FLAG_ALARM_SETTLE = 1;
 4126               		.loc 1 451 0
 4127 09f8 21E0      		ldi r18,lo8(1)
 4128 09fa 2093 0000 		sts FLAG_ALARM_SETTLE,r18
 453:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 4129               		.loc 1 453 0
 4130 09fe 429A      		sbi 0x8,2
 454:easyrider.c   ****       PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
 4131               		.loc 1 454 0
 4132 0a00 409A      		sbi 0x8,0
 455:easyrider.c   ****       PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
 4133               		.loc 1 455 0
 4134 0a02 439A      		sbi 0x8,3
 456:easyrider.c   ****       PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
 4135               		.loc 1 456 0
 4136 0a04 419A      		sbi 0x8,1
 457:easyrider.c   ****       PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
 4137               		.loc 1 457 0
 4138 0a06 449A      		sbi 0x8,4
 458:easyrider.c   ****       g_music_duration = 0;
 4139               		.loc 1 458 0
 4140 0a08 1092 0000 		sts g_music_duration+1,__zero_reg__
 4141 0a0c 1092 0000 		sts g_music_duration,__zero_reg__
 4142               	.LBB488:
 459:easyrider.c   ****       g_current_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 4143               		.loc 1 459 0
 4144 0a10 90E0      		ldi r25,0
 4145 0a12 880F      		lsl r24
 4146 0a14 991F      		rol r25
 4147               	.LVL95:
 4148 0a16 8050      		subi r24,lo8(-(g_music-2))
 4149 0a18 9040      		sbci r25,hi8(-(g_music-2))
 4150               	.LVL96:
 4151 0a1a FC01      		movw r30,r24
 4152               	/* #APP */
 4153               	 ;  459 "easyrider.c" 1
 4154 0a1c 8591      		lpm r24, Z+
 4155 0a1e 9491      		lpm r25, Z
 4156               		
 4157               	 ;  0 "" 2
 4158               	.LVL97:
 4159               	/* #NOAPP */
 4160               	.LBE488:
 4161 0a20 9093 0000 		sts g_current_music+1,r25
 4162 0a24 8093 0000 		sts g_current_music,r24
 4163               	.LVL98:
 460:easyrider.c   ****       g_selected_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 4164               		.loc 1 460 0
 4165 0a28 9093 0000 		sts g_selected_music+1,r25
 4166 0a2c 8093 0000 		sts g_selected_music,r24
 461:easyrider.c   ****       FLAG_MUSIC = 1;
 4167               		.loc 1 461 0
 4168 0a30 2093 0000 		sts FLAG_MUSIC,r18
 462:easyrider.c   ****       g_current_alarm_settle_time = g_settings.alarm_settle_time;
 4169               		.loc 1 462 0
 4170 0a34 8091 0000 		lds r24,g_settings+4
 4171 0a38 9091 0000 		lds r25,g_settings+4+1
 4172               	.LVL99:
 4173 0a3c 9093 0000 		sts g_current_alarm_settle_time+1,r25
 4174 0a40 8093 0000 		sts g_current_alarm_settle_time,r24
 463:easyrider.c   ****       g_alarm_snapshot[0] = 0;
 4175               		.loc 1 463 0
 4176 0a44 1092 0000 		sts g_alarm_snapshot+1,__zero_reg__
 4177 0a48 1092 0000 		sts g_alarm_snapshot,__zero_reg__
 464:easyrider.c   ****       g_alarm_snapshot[1] = 0;
 4178               		.loc 1 464 0
 4179 0a4c 1092 0000 		sts g_alarm_snapshot+2+1,__zero_reg__
 4180 0a50 1092 0000 		sts g_alarm_snapshot+2,__zero_reg__
 465:easyrider.c   ****       g_alarm_snapshot[2] = 0;
 4181               		.loc 1 465 0
 4182 0a54 1092 0000 		sts g_alarm_snapshot+4+1,__zero_reg__
 4183 0a58 1092 0000 		sts g_alarm_snapshot+4,__zero_reg__
 4184               	.LVL100:
 4185               	.L404:
 4186               	.LBE489:
 468:easyrider.c   ****     if (g_alarm_snapshot[0]) {
 4187               		.loc 1 468 0
 4188 0a5c 8091 0000 		lds r24,g_alarm_snapshot
 4189 0a60 9091 0000 		lds r25,g_alarm_snapshot+1
 4190 0a64 892B      		or r24,r25
 4191 0a66 01F4      		brne .+2
 4192 0a68 00C0      		rjmp .L406
 469:easyrider.c   ****       g_alarm_snapshot[0] = ((g_alarm_snapshot[0] + g_adc_voltage[1])/2);
 4193               		.loc 1 469 0
 4194 0a6a 2091 0000 		lds r18,g_alarm_snapshot
 4195 0a6e 3091 0000 		lds r19,g_alarm_snapshot+1
 4196 0a72 8091 0000 		lds r24,g_adc_voltage+2
 4197 0a76 9091 0000 		lds r25,g_adc_voltage+2+1
 4198 0a7a 820F      		add r24,r18
 4199 0a7c 931F      		adc r25,r19
 4200 0a7e 9695      		lsr r25
 4201 0a80 8795      		ror r24
 4202 0a82 9093 0000 		sts g_alarm_snapshot+1,r25
 4203 0a86 8093 0000 		sts g_alarm_snapshot,r24
 4204               	.L407:
 473:easyrider.c   ****     if (g_alarm_snapshot[1]) {
 4205               		.loc 1 473 0
 4206 0a8a 8091 0000 		lds r24,g_alarm_snapshot+2
 4207 0a8e 9091 0000 		lds r25,g_alarm_snapshot+2+1
 4208 0a92 892B      		or r24,r25
 4209 0a94 01F4      		brne .+2
 4210 0a96 00C0      		rjmp .L408
 474:easyrider.c   ****       g_alarm_snapshot[1] = ((g_alarm_snapshot[1] + g_adc_voltage[2])/2);
 4211               		.loc 1 474 0
 4212 0a98 2091 0000 		lds r18,g_alarm_snapshot+2
 4213 0a9c 3091 0000 		lds r19,g_alarm_snapshot+2+1
 4214 0aa0 8091 0000 		lds r24,g_adc_voltage+4
 4215 0aa4 9091 0000 		lds r25,g_adc_voltage+4+1
 4216 0aa8 820F      		add r24,r18
 4217 0aaa 931F      		adc r25,r19
 4218 0aac 9695      		lsr r25
 4219 0aae 8795      		ror r24
 4220 0ab0 9093 0000 		sts g_alarm_snapshot+2+1,r25
 4221 0ab4 8093 0000 		sts g_alarm_snapshot+2,r24
 4222               	.L409:
 478:easyrider.c   ****     if (g_alarm_snapshot[2]) {
 4223               		.loc 1 478 0
 4224 0ab8 8091 0000 		lds r24,g_alarm_snapshot+4
 4225 0abc 9091 0000 		lds r25,g_alarm_snapshot+4+1
 4226 0ac0 892B      		or r24,r25
 4227 0ac2 01F4      		brne .+2
 4228 0ac4 00C0      		rjmp .L410
 479:easyrider.c   ****       g_alarm_snapshot[2] = ((g_alarm_snapshot[2] + g_adc_voltage[3])/2);
 4229               		.loc 1 479 0
 4230 0ac6 2091 0000 		lds r18,g_alarm_snapshot+4
 4231 0aca 3091 0000 		lds r19,g_alarm_snapshot+4+1
 4232 0ace 8091 0000 		lds r24,g_adc_voltage+6
 4233 0ad2 9091 0000 		lds r25,g_adc_voltage+6+1
 4234 0ad6 820F      		add r24,r18
 4235 0ad8 931F      		adc r25,r19
 4236 0ada 9695      		lsr r25
 4237 0adc 8795      		ror r24
 4238 0ade 9093 0000 		sts g_alarm_snapshot+4+1,r25
 4239 0ae2 8093 0000 		sts g_alarm_snapshot+4,r24
 4240               	.L411:
 484:easyrider.c   ****     if ((!g_current_alarm_settle_time) && ((g_alarm_snapshot[0] > g_settings.alarm_thres_min) && (g
 4241               		.loc 1 484 0
 4242 0ae6 8091 0000 		lds r24,g_current_alarm_settle_time
 4243 0aea 9091 0000 		lds r25,g_current_alarm_settle_time+1
 4244 0aee 892B      		or r24,r25
 4245 0af0 01F0      		breq .+2
 4246 0af2 00C0      		rjmp .L403
 4247 0af4 8091 0000 		lds r24,g_alarm_snapshot
 4248 0af8 9091 0000 		lds r25,g_alarm_snapshot+1
 4249 0afc 2091 0000 		lds r18,g_settings+12
 4250 0b00 30E0      		ldi r19,0
 4251 0b02 2817      		cp r18,r24
 4252 0b04 3907      		cpc r19,r25
 4253 0b06 00F0      		brlo .+2
 4254 0b08 00C0      		rjmp .L403
 4255 0b0a 4091 0000 		lds r20,g_alarm_snapshot
 4256 0b0e 5091 0000 		lds r21,g_alarm_snapshot+1
 4257 0b12 8091 0000 		lds r24,g_settings+13
 4258 0b16 9091 0000 		lds r25,g_settings+13+1
 4259 0b1a 4817      		cp r20,r24
 4260 0b1c 5907      		cpc r21,r25
 4261 0b1e 00F0      		brlo .+2
 4262 0b20 00C0      		rjmp .L403
 485:easyrider.c   ****        ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.ala
 4263               		.loc 1 485 0
 4264 0b22 4091 0000 		lds r20,g_alarm_snapshot+2
 4265 0b26 5091 0000 		lds r21,g_alarm_snapshot+2+1
 484:easyrider.c   ****     if ((!g_current_alarm_settle_time) && ((g_alarm_snapshot[0] > g_settings.alarm_thres_min) && (g
 4266               		.loc 1 484 0
 4267 0b2a 2417      		cp r18,r20
 4268 0b2c 3507      		cpc r19,r21
 4269 0b2e 00F0      		brlo .+2
 4270 0b30 00C0      		rjmp .L403
 485:easyrider.c   ****        ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.ala
 4271               		.loc 1 485 0
 4272 0b32 4091 0000 		lds r20,g_alarm_snapshot+2
 4273 0b36 5091 0000 		lds r21,g_alarm_snapshot+2+1
 4274 0b3a 4817      		cp r20,r24
 4275 0b3c 5907      		cpc r21,r25
 4276 0b3e 00F0      		brlo .+2
 4277 0b40 00C0      		rjmp .L403
 486:easyrider.c   ****        ((g_alarm_snapshot[2] > g_settings.alarm_thres_min) && (g_alarm_snapshot[2] < g_settings.ala
 4278               		.loc 1 486 0
 4279 0b42 4091 0000 		lds r20,g_alarm_snapshot+4
 4280 0b46 5091 0000 		lds r21,g_alarm_snapshot+4+1
 485:easyrider.c   ****        ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.ala
 4281               		.loc 1 485 0
 4282 0b4a 2417      		cp r18,r20
 4283 0b4c 3507      		cpc r19,r21
 4284 0b4e 00F0      		brlo .+2
 4285 0b50 00C0      		rjmp .L403
 486:easyrider.c   ****        ((g_alarm_snapshot[2] > g_settings.alarm_thres_min) && (g_alarm_snapshot[2] < g_settings.ala
 4286               		.loc 1 486 0
 4287 0b52 2091 0000 		lds r18,g_alarm_snapshot+4
 4288 0b56 3091 0000 		lds r19,g_alarm_snapshot+4+1
 4289 0b5a 2817      		cp r18,r24
 4290 0b5c 3907      		cpc r19,r25
 4291 0b5e 00F0      		brlo .+2
 4292 0b60 00C0      		rjmp .L403
 488:easyrider.c   ****       FLAG_ALARM_SETTLE = 0;
 4293               		.loc 1 488 0
 4294 0b62 1092 0000 		sts FLAG_ALARM_SETTLE,__zero_reg__
 4295               	.LBB490:
 4296               	.LBB491:
 885:easyrider.c   ****   PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 4297               		.loc 1 885 0
 4298 0b66 4298      		cbi 0x8,2
 886:easyrider.c   ****   PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 4299               		.loc 1 886 0
 4300 0b68 4598      		cbi 0x8,5
 887:easyrider.c   ****   PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 4301               		.loc 1 887 0
 4302 0b6a 4098      		cbi 0x8,0
 888:easyrider.c   ****   PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 4303               		.loc 1 888 0
 4304 0b6c 4398      		cbi 0x8,3
 889:easyrider.c   ****   PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 4305               		.loc 1 889 0
 4306 0b6e 4198      		cbi 0x8,1
 890:easyrider.c   ****   PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 4307               		.loc 1 890 0
 4308 0b70 4498      		cbi 0x8,4
 891:easyrider.c   ****   PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 4309               		.loc 1 891 0
 4310 0b72 4798      		cbi 0x8,7
 892:easyrider.c   ****   PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 4311               		.loc 1 892 0
 4312 0b74 5F98      		cbi 0xb,7
 893:easyrider.c   ****   PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 4313               		.loc 1 893 0
 4314 0b76 4698      		cbi 0x8,6
 894:easyrider.c   ****   PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
 4315               		.loc 1 894 0
 4316 0b78 5E98      		cbi 0xb,6
 4317               	.LBE491:
 4318               	.LBE490:
 490:easyrider.c   ****       g_alarm_counter = g_settings.alarm_counter;
 4319               		.loc 1 490 0
 4320 0b7a 8091 0000 		lds r24,g_settings+9
 4321 0b7e 8093 0000 		sts g_alarm_counter,r24
 491:easyrider.c   ****       g_trigger_counter = 0;
 4322               		.loc 1 491 0
 4323 0b82 1092 0000 		sts g_trigger_counter,__zero_reg__
 492:easyrider.c   ****       g_state = ST_ALARM;
 4324               		.loc 1 492 0
 4325 0b86 80E4      		ldi r24,lo8(64)
 4326 0b88 90E0      		ldi r25,0
 4327 0b8a 9093 0000 		sts g_state+1,r25
 4328 0b8e 8093 0000 		sts g_state,r24
 4329 0b92 00C0      		rjmp .L403
 4330               	.L597:
 4331               	.LBE493:
 4332               	.LBE717:
 4333               	.LBB718:
 4334               	.LBB470:
 399:easyrider.c   ****     if (!FLAG_SETTLE) { // first time in settle mode
 4335               		.loc 1 399 0
 4336 0b94 8091 0000 		lds r24,FLAG_SETTLE
 4337 0b98 8111      		cpse r24,__zero_reg__
 4338 0b9a 00C0      		rjmp .L375
 4339               	.LBB468:
 400:easyrider.c   ****       uint8_t song_idx = g_settings.startup_sound;
 4340               		.loc 1 400 0
 4341 0b9c 8091 0000 		lds r24,g_settings+18
 4342               	.LVL101:
 401:easyrider.c   ****       FLAG_SETTLE = 1;
 4343               		.loc 1 401 0
 4344 0ba0 91E0      		ldi r25,lo8(1)
 4345 0ba2 9093 0000 		sts FLAG_SETTLE,r25
 403:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 4346               		.loc 1 403 0
 4347 0ba6 429A      		sbi 0x8,2
 404:easyrider.c   ****       PORT_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 4348               		.loc 1 404 0
 4349 0ba8 459A      		sbi 0x8,5
 405:easyrider.c   ****       PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
 4350               		.loc 1 405 0
 4351 0baa 409A      		sbi 0x8,0
 406:easyrider.c   ****       PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
 4352               		.loc 1 406 0
 4353 0bac 439A      		sbi 0x8,3
 407:easyrider.c   ****       PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
 4354               		.loc 1 407 0
 4355 0bae 419A      		sbi 0x8,1
 408:easyrider.c   ****       PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
 4356               		.loc 1 408 0
 4357 0bb0 449A      		sbi 0x8,4
 409:easyrider.c   ****       PORT_C90_BRAKE |= (1 << PIN_C90_BRAKE);
 4358               		.loc 1 409 0
 4359 0bb2 479A      		sbi 0x8,7
 410:easyrider.c   ****       PORT_C90_PILOT |= (1 << PIN_C90_PILOT);
 4360               		.loc 1 410 0
 4361 0bb4 5F9A      		sbi 0xb,7
 411:easyrider.c   ****       PORT_C90_LIGHT |= (1 << PIN_C90_LIGHT);
 4362               		.loc 1 411 0
 4363 0bb6 469A      		sbi 0x8,6
 412:easyrider.c   ****       PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // silence a possible claxon from the alarm
 4364               		.loc 1 412 0
 4365 0bb8 5E98      		cbi 0xb,6
 414:easyrider.c   ****       g_music_duration = 0;
 4366               		.loc 1 414 0
 4367 0bba 1092 0000 		sts g_music_duration+1,__zero_reg__
 4368 0bbe 1092 0000 		sts g_music_duration,__zero_reg__
 416:easyrider.c   ****       if (song_idx == 0) {
 4369               		.loc 1 416 0
 4370 0bc2 8111      		cpse r24,__zero_reg__
 4371 0bc4 00C0      		rjmp .L376
 417:easyrider.c   ****         srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda 
 4372               		.loc 1 417 0
 4373 0bc6 6091 0000 		lds r22,g_adc_voltage
 4374 0bca 7091 0000 		lds r23,g_adc_voltage+1
 4375 0bce 8091 0000 		lds r24,g_adc_voltage+2
 4376 0bd2 9091 0000 		lds r25,g_adc_voltage+2+1
 4377               	.LVL102:
 4378 0bd6 4091 0000 		lds r20,g_adc_voltage+4
 4379 0bda 5091 0000 		lds r21,g_adc_voltage+4+1
 4380 0bde 2091 0000 		lds r18,g_adc_voltage+6
 4381 0be2 3091 0000 		lds r19,g_adc_voltage+6+1
 4382 0be6 860F      		add r24,r22
 4383 0be8 971F      		adc r25,r23
 4384 0bea 840F      		add r24,r20
 4385 0bec 951F      		adc r25,r21
 4386 0bee 820F      		add r24,r18
 4387 0bf0 931F      		adc r25,r19
 4388 0bf2 0E94 0000 		call srand
 4389               	.LVL103:
 418:easyrider.c   ****         song_idx = 2 + (uint8_t)(rand() / (RAND_MAX / 5));
 4390               		.loc 1 418 0
 4391 0bf6 0E94 0000 		call rand
 4392               	.LVL104:
 4393 0bfa B401      		movw r22,r8
 4394 0bfc 0E94 0000 		call __divmodhi4
 4395 0c00 82E0      		ldi r24,lo8(2)
 4396 0c02 860F      		add r24,r22
 4397               	.LVL105:
 4398               	.L376:
 4399               	.LBB467:
 420:easyrider.c   ****       g_current_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 4400               		.loc 1 420 0
 4401 0c04 90E0      		ldi r25,0
 4402 0c06 880F      		lsl r24
 4403 0c08 991F      		rol r25
 4404               	.LVL106:
 4405 0c0a 8050      		subi r24,lo8(-(g_music-2))
 4406 0c0c 9040      		sbci r25,hi8(-(g_music-2))
 4407               	.LVL107:
 4408 0c0e FC01      		movw r30,r24
 4409               	/* #APP */
 4410               	 ;  420 "easyrider.c" 1
 4411 0c10 8591      		lpm r24, Z+
 4412 0c12 9491      		lpm r25, Z
 4413               		
 4414               	 ;  0 "" 2
 4415               	.LVL108:
 4416               	/* #NOAPP */
 4417               	.LBE467:
 4418 0c14 9093 0000 		sts g_current_music+1,r25
 4419 0c18 8093 0000 		sts g_current_music,r24
 4420               	.LVL109:
 421:easyrider.c   ****       g_selected_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
 4421               		.loc 1 421 0
 4422 0c1c 9093 0000 		sts g_selected_music+1,r25
 4423 0c20 8093 0000 		sts g_selected_music,r24
 422:easyrider.c   ****       FLAG_MUSIC = 1;
 4424               		.loc 1 422 0
 4425 0c24 81E0      		ldi r24,lo8(1)
 4426               	.LVL110:
 4427 0c26 8093 0000 		sts FLAG_MUSIC,r24
 423:easyrider.c   ****       g_current_settle_time = g_settings.settle_time;
 4428               		.loc 1 423 0
 4429 0c2a 8091 0000 		lds r24,g_settings+2
 4430 0c2e 9091 0000 		lds r25,g_settings+2+1
 4431 0c32 9093 0000 		sts g_current_settle_time+1,r25
 4432 0c36 8093 0000 		sts g_current_settle_time,r24
 4433               	.LVL111:
 4434               	.L375:
 4435               	.LBE468:
 425:easyrider.c   ****     if (!g_current_settle_time) { // settle time is over
 4436               		.loc 1 425 0
 4437 0c3a 8091 0000 		lds r24,g_current_settle_time
 4438 0c3e 9091 0000 		lds r25,g_current_settle_time+1
 4439 0c42 892B      		or r24,r25
 4440 0c44 01F0      		breq .+2
 4441 0c46 00C0      		rjmp .L374
 426:easyrider.c   ****       FLAG_SETTLE = 0; // reset settle
 4442               		.loc 1 426 0
 4443 0c48 1092 0000 		sts FLAG_SETTLE,__zero_reg__
 427:easyrider.c   ****       g_state = ST_NORMAL;
 4444               		.loc 1 427 0
 4445 0c4c 81E0      		ldi r24,lo8(1)
 4446 0c4e 90E0      		ldi r25,0
 4447 0c50 9093 0000 		sts g_state+1,r25
 4448 0c54 8093 0000 		sts g_state,r24
 428:easyrider.c   ****       PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 4449               		.loc 1 428 0
 4450 0c58 4298      		cbi 0x8,2
 429:easyrider.c   ****       PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
 4451               		.loc 1 429 0
 4452 0c5a 4598      		cbi 0x8,5
 430:easyrider.c   ****       PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
 4453               		.loc 1 430 0
 4454 0c5c 4098      		cbi 0x8,0
 431:easyrider.c   ****       PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
 4455               		.loc 1 431 0
 4456 0c5e 4398      		cbi 0x8,3
 432:easyrider.c   ****       PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
 4457               		.loc 1 432 0
 4458 0c60 4198      		cbi 0x8,1
 433:easyrider.c   ****       PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
 4459               		.loc 1 433 0
 4460 0c62 4498      		cbi 0x8,4
 434:easyrider.c   ****       PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
 4461               		.loc 1 434 0
 4462 0c64 5E98      		cbi 0xb,6
 435:easyrider.c   ****       PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
 4463               		.loc 1 435 0
 4464 0c66 4798      		cbi 0x8,7
 436:easyrider.c   ****       PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
 4465               		.loc 1 436 0
 4466 0c68 5F98      		cbi 0xb,7
 437:easyrider.c   ****       PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
 4467               		.loc 1 437 0
 4468 0c6a 4698      		cbi 0x8,6
 4469 0c6c 00C0      		rjmp .L374
 4470               	.L610:
 4471               	.LBE470:
 4472               	.LBE718:
 4473               	.LBB719:
 4474               	.LBB708:
 363:easyrider.c   ****     if (g_sleep_counter == 0) {
 4475               		.loc 1 363 0
 4476 0c6e 8091 0000 		lds r24,g_sleep_counter
 4477 0c72 9091 0000 		lds r25,g_sleep_counter+1
 4478 0c76 892B      		or r24,r25
 4479 0c78 01F0      		breq .+2
 4480 0c7a 00C0      		rjmp .L447
 4481               	.LBB702:
 4482               	.LBB703:
1101:easyrider.c   ****   reset_ports();
 4483               		.loc 1 1101 0
 4484 0c7c 0E94 0000 		call reset_ports
 4485               	.LVL112:
 4486               	.LBB704:
 4487               	.LBB705:
 973:easyrider.c   ****   ADCSRA &= ~(1 << ADEN);
 4488               		.loc 1 973 0
 4489 0c80 8091 7A00 		lds r24,122
 4490 0c84 8F77      		andi r24,lo8(127)
 4491 0c86 8093 7A00 		sts 122,r24
 4492               	.LBE705:
 4493               	.LBE704:
1103:easyrider.c   ****   DDRA = 0;
 4494               		.loc 1 1103 0
 4495 0c8a 11B8      		out 0x1,__zero_reg__
1104:easyrider.c   ****   PORTA = 0xff;
 4496               		.loc 1 1104 0
 4497 0c8c 8FEF      		ldi r24,lo8(-1)
 4498 0c8e 82B9      		out 0x2,r24
1105:easyrider.c   ****   wdt_disable();
 4499               		.loc 1 1105 0
 4500 0c90 88E1      		ldi r24,lo8(24)
 4501               	/* #APP */
 4502               	 ;  1105 "easyrider.c" 1
 4503 0c92 0FB6      		in __tmp_reg__, __SREG__
 4504 0c94 F894      		cli
 4505 0c96 8093 6000 		sts 96, r24
 4506 0c9a 1092 6000 		sts 96, __zero_reg__
 4507 0c9e 0FBE      		out __SREG__,__tmp_reg__
 4508               		
 4509               	 ;  0 "" 2
1106:easyrider.c   ****   PORT_C90_HEARTBEAT_LED &= ~(1 << PIN_C90_HEARTBEAT_LED); // low
 4510               		.loc 1 1106 0
 4511               	/* #NOAPP */
 4512 0ca0 5C98      		cbi 0xb,4
 4513               	.LBB706:
 4514               	.LBB707:
 958:easyrider.c   ****   g_senses = 0;
 4515               		.loc 1 958 0
 4516 0ca2 1092 0000 		sts g_senses+1,__zero_reg__
 4517 0ca6 1092 0000 		sts g_senses,__zero_reg__
 4518               	.LBE707:
 4519               	.LBE706:
1108:easyrider.c   ****   power_all_disable();
 4520               		.loc 1 1108 0
 4521 0caa 8091 6400 		lds r24,100
 4522 0cae 8FEF      		ldi r24,lo8(-1)
 4523 0cb0 8093 6400 		sts 100,r24
 4524 0cb4 8091 6500 		lds r24,101
 4525 0cb8 8160      		ori r24,lo8(1)
 4526 0cba 8093 6500 		sts 101,r24
1109:easyrider.c   ****   set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 4527               		.loc 1 1109 0
 4528 0cbe 83B7      		in r24,0x33
 4529 0cc0 817F      		andi r24,lo8(-15)
 4530 0cc2 8460      		ori r24,lo8(4)
 4531 0cc4 83BF      		out 0x33,r24
1110:easyrider.c   ****   sleep_mode();         
 4532               		.loc 1 1110 0
 4533 0cc6 83B7      		in r24,0x33
 4534 0cc8 8160      		ori r24,lo8(1)
 4535 0cca 83BF      		out 0x33,r24
 4536               	/* #APP */
 4537               	 ;  1110 "easyrider.c" 1
 4538 0ccc 8895      		sleep
 4539               		
 4540               	 ;  0 "" 2
 4541               	/* #NOAPP */
 4542 0cce 83B7      		in r24,0x33
 4543 0cd0 8E7F      		andi r24,lo8(-2)
 4544 0cd2 83BF      		out 0x33,r24
 4545 0cd4 00C0      		rjmp .L447
 4546               	.L608:
 4547               	.LVL113:
 4548               	.LBE703:
 4549               	.LBE702:
 4550               	.LBE708:
 4551               	.LBE719:
 4552               	.LBB720:
 4553               	.LBB695:
 4554               	.LBB685:
 4555               	.LBB681:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 4556               		.loc 1 553 0
 4557 0cd6 85E1      		ldi r24,lo8(21)
 4558 0cd8 00C0      		rjmp .L568
 4559               	.LVL114:
 4560               	.L601:
 4561               	.LBE681:
 4562               	.LBE685:
 4563               	.LBE695:
 4564               	.LBE720:
 4565               	.LBB721:
 4566               	.LBB662:
 4567               	.LBB652:
 4568               	.LBB648:
 4569 0cda 8FE0      		ldi r24,lo8(15)
 4570 0cdc 00C0      		rjmp .L566
 4571               	.LVL115:
 4572               	.L571:
 4573               	.LBE648:
 4574               	.LBE652:
 4575               	.LBE662:
 4576               	.LBE721:
 4577               	.LBB722:
 4578               	.LBB459:
 4579               	.LBB452:
 4580               	.LBB448:
 4581 0cde C082      		st Z,r12
 4582 0ce0 00C0      		rjmp .L552
 4583               	.LVL116:
 4584               	.L575:
 4585               	.LBE448:
 4586               	.LBE452:
 4587               	.LBE459:
 4588               	.LBE722:
 4589               	.LBB723:
 4590               	.LBB524:
 4591               	.LBB514:
 4592               	.LBB510:
 4593 0ce2 87E0      		ldi r24,lo8(7)
 4594 0ce4 00C0      		rjmp .L554
 4595               	.LVL117:
 4596               	.L579:
 4597               	.LBE510:
 4598               	.LBE514:
 4599               	.LBE524:
 4600               	.LBE723:
 4601               	.LBB724:
 4602               	.LBB546:
 4603               	.LBB536:
 4604               	.LBB532:
 4605 0ce6 84E0      		ldi r24,lo8(4)
 4606 0ce8 00C0      		rjmp .L556
 4607               	.LVL118:
 4608               	.L583:
 4609               	.LBE532:
 4610               	.LBE536:
 4611               	.LBE546:
 4612               	.LBE724:
 4613               	.LBB725:
 4614               	.LBB570:
 4615               	.LBB560:
 4616               	.LBB556:
 4617 0cea 85E0      		ldi r24,lo8(5)
 4618 0cec 00C0      		rjmp .L558
 4619               	.LVL119:
 4620               	.L587:
 4621               	.LBE556:
 4622               	.LBE560:
 4623               	.LBE570:
 4624               	.LBE725:
 4625               	.LBB726:
 4626               	.LBB592:
 4627               	.LBB587:
 4628               	.LBB583:
 4629 0cee 8DE0      		ldi r24,lo8(13)
 4630 0cf0 00C0      		rjmp .L560
 4631               	.LVL120:
 4632               	.L591:
 4633               	.LBE583:
 4634               	.LBE587:
 4635               	.LBE592:
 4636               	.LBE726:
 4637               	.LBB727:
 4638               	.LBB614:
 4639               	.LBB604:
 4640               	.LBB600:
 4641 0cf2 8BE0      		ldi r24,lo8(11)
 4642 0cf4 00C0      		rjmp .L562
 4643               	.LVL121:
 4644               	.L595:
 4645               	.LBE600:
 4646               	.LBE604:
 4647               	.LBE614:
 4648               	.LBE727:
 4649               	.LBB728:
 4650               	.LBB636:
 4651               	.LBB626:
 4652               	.LBB622:
 4653 0cf6 83E1      		ldi r24,lo8(19)
 4654 0cf8 00C0      		rjmp .L564
 4655               	.LVL122:
 4656               	.L410:
 4657               	.LBE622:
 4658               	.LBE626:
 4659               	.LBE636:
 4660               	.LBE728:
 4661               	.LBB729:
 4662               	.LBB494:
 481:easyrider.c   ****       g_alarm_snapshot[2] = g_adc_voltage[3];
 4663               		.loc 1 481 0
 4664 0cfa 8091 0000 		lds r24,g_adc_voltage+6
 4665 0cfe 9091 0000 		lds r25,g_adc_voltage+6+1
 4666 0d02 9093 0000 		sts g_alarm_snapshot+4+1,r25
 4667 0d06 8093 0000 		sts g_alarm_snapshot+4,r24
 4668 0d0a 00C0      		rjmp .L411
 4669               	.L408:
 476:easyrider.c   ****       g_alarm_snapshot[1] = g_adc_voltage[2];
 4670               		.loc 1 476 0
 4671 0d0c 8091 0000 		lds r24,g_adc_voltage+4
 4672 0d10 9091 0000 		lds r25,g_adc_voltage+4+1
 4673 0d14 9093 0000 		sts g_alarm_snapshot+2+1,r25
 4674 0d18 8093 0000 		sts g_alarm_snapshot+2,r24
 4675 0d1c 00C0      		rjmp .L409
 4676               	.L406:
 471:easyrider.c   ****       g_alarm_snapshot[0] = g_adc_voltage[1];
 4677               		.loc 1 471 0
 4678 0d1e 8091 0000 		lds r24,g_adc_voltage+2
 4679 0d22 9091 0000 		lds r25,g_adc_voltage+2+1
 4680 0d26 9093 0000 		sts g_alarm_snapshot+1,r25
 4681 0d2a 8093 0000 		sts g_alarm_snapshot,r24
 4682 0d2e 00C0      		rjmp .L407
 4683               	.L415:
 4684               	.LBE494:
 4685               	.LBE729:
 4686               	.LBB730:
 4687               	.LBB501:
 519:easyrider.c   ****     } else if (FLAG_ALARM_BLINK) {
 4688               		.loc 1 519 0
 4689 0d30 8091 0000 		lds r24,FLAG_ALARM_BLINK
 4690 0d34 8823      		tst r24
 4691 0d36 01F4      		brne .+2
 4692 0d38 00C0      		rjmp .L414
 520:easyrider.c   ****       FLAG_ALARM_BLINK = 0;
 4693               		.loc 1 520 0
 4694 0d3a 1092 0000 		sts FLAG_ALARM_BLINK,__zero_reg__
 521:easyrider.c   ****       if (g_alarm_blink_counter % 4 == 0) { // blink for 1 tick every timer1 4 counts
 4695               		.loc 1 521 0
 4696 0d3e 8091 0000 		lds r24,g_alarm_blink_counter
 4697 0d42 8370      		andi r24,lo8(3)
 4698 0d44 01F0      		breq .+2
 4699 0d46 00C0      		rjmp .L417
 522:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 4700               		.loc 1 522 0
 4701 0d48 429A      		sbi 0x8,2
 4702               	.L418:
 526:easyrider.c   ****       if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
 4703               		.loc 1 526 0
 4704 0d4a 8091 0000 		lds r24,g_adc_voltage+2
 4705 0d4e 9091 0000 		lds r25,g_adc_voltage+2+1
 4706 0d52 4091 0000 		lds r20,g_alarm_snapshot
 4707 0d56 5091 0000 		lds r21,g_alarm_snapshot+1
 4708 0d5a 2091 0000 		lds r18,g_settings+10
 4709 0d5e 30E0      		ldi r19,0
 4710 0d60 841B      		sub r24,r20
 4711 0d62 950B      		sbc r25,r21
 4712 0d64 97FD      		sbrc r25,7
 4713 0d66 00C0      		rjmp .L614
 4714               	.L420:
 4715 0d68 2817      		cp r18,r24
 4716 0d6a 3907      		cpc r19,r25
 4717 0d6c 04F0      		brlt .L419
 527:easyrider.c   ****        (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
 4718               		.loc 1 527 0
 4719 0d6e 8091 0000 		lds r24,g_adc_voltage+4
 4720 0d72 9091 0000 		lds r25,g_adc_voltage+4+1
 4721 0d76 4091 0000 		lds r20,g_alarm_snapshot+2
 4722 0d7a 5091 0000 		lds r21,g_alarm_snapshot+2+1
 4723 0d7e 841B      		sub r24,r20
 4724 0d80 950B      		sbc r25,r21
 4725 0d82 97FD      		sbrc r25,7
 4726 0d84 00C0      		rjmp .L615
 4727               	.L421:
 526:easyrider.c   ****       if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
 4728               		.loc 1 526 0
 4729 0d86 2817      		cp r18,r24
 4730 0d88 3907      		cpc r19,r25
 4731 0d8a 04F0      		brlt .L419
 528:easyrider.c   ****        (abs(g_adc_voltage[3] - g_alarm_snapshot[2]) > g_settings.alarm_trigger)) {
 4732               		.loc 1 528 0
 4733 0d8c 8091 0000 		lds r24,g_adc_voltage+6
 4734 0d90 9091 0000 		lds r25,g_adc_voltage+6+1
 4735 0d94 4091 0000 		lds r20,g_alarm_snapshot+4
 4736 0d98 5091 0000 		lds r21,g_alarm_snapshot+4+1
 4737 0d9c 841B      		sub r24,r20
 4738 0d9e 950B      		sbc r25,r21
 4739 0da0 97FD      		sbrc r25,7
 4740 0da2 00C0      		rjmp .L616
 4741               	.L422:
 527:easyrider.c   ****        (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
 4742               		.loc 1 527 0
 4743 0da4 2817      		cp r18,r24
 4744 0da6 3907      		cpc r19,r25
 4745 0da8 04F0      		brlt .+2
 4746 0daa 00C0      		rjmp .L414
 4747               	.L419:
 529:easyrider.c   ****         g_trigger_counter++;
 4748               		.loc 1 529 0
 4749 0dac 8091 0000 		lds r24,g_trigger_counter
 4750 0db0 8F5F      		subi r24,lo8(-(1))
 4751 0db2 8093 0000 		sts g_trigger_counter,r24
 530:easyrider.c   ****         if (g_trigger_counter >= g_settings.alarm_trigger_counter) {
 4752               		.loc 1 530 0
 4753 0db6 8091 0000 		lds r24,g_trigger_counter
 4754 0dba 9091 0000 		lds r25,g_settings+11
 4755 0dbe 8917      		cp r24,r25
 4756 0dc0 00F4      		brsh .+2
 4757 0dc2 00C0      		rjmp .L414
 531:easyrider.c   ****           FLAG_ALARM_TRIGGER = 1;
 4758               		.loc 1 531 0
 4759 0dc4 81E0      		ldi r24,lo8(1)
 4760 0dc6 8093 0000 		sts FLAG_ALARM_TRIGGER,r24
 4761 0dca 00C0      		rjmp .L414
 4762               	.LVL123:
 4763               	.L379:
 4764               	.LBE501:
 4765               	.LBE730:
 4766               	.LBB731:
 4767               	.LBB482:
1092:easyrider.c   ****         FLAG_MUSIC = 0;
 4768               		.loc 1 1092 0
 4769 0dcc 1092 0000 		sts FLAG_MUSIC,__zero_reg__
1093:easyrider.c   ****         TIMSK3 &= ~(1 << OCIE3A); // disable interrupt
 4770               		.loc 1 1093 0
 4771 0dd0 8091 7100 		lds r24,113
 4772 0dd4 8D7F      		andi r24,lo8(-3)
 4773 0dd6 8093 7100 		sts 113,r24
1094:easyrider.c   ****         PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 4774               		.loc 1 1094 0
 4775 0dda 5D98      		cbi 0xb,5
 4776 0ddc 00C0      		rjmp .L378
 4777               	.LVL124:
 4778               	.L605:
 4779               	.LBE482:
 4780               	.LBE731:
 4781               	.LBB732:
 4782               	.LBB676:
 4783               	.LBB674:
 4784               	.LBB675:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 4785               		.loc 1 553 0
 4786 0dde E091 0000 		lds r30,g_buffer_head
 4787 0de2 F0E0      		ldi r31,0
 4788 0de4 E050      		subi r30,lo8(-(g_event_buffer))
 4789 0de6 F040      		sbci r31,hi8(-(g_event_buffer))
 4790 0de8 80E1      		ldi r24,lo8(16)
 4791 0dea 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 4792               		.loc 1 554 0
 4793 0dec 8091 0000 		lds r24,g_buffer_head
 4794 0df0 8F5F      		subi r24,lo8(-(1))
 4795 0df2 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 4796               		.loc 1 555 0
 4797 0df6 8091 0000 		lds r24,g_buffer_head
 4798 0dfa 8034      		cpi r24,lo8(64)
 4799 0dfc 00F0      		brlo .L425
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 4800               		.loc 1 556 0
 4801 0dfe 1092 0000 		sts g_buffer_head,__zero_reg__
 4802               	.L425:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 4803               		.loc 1 558 0
 4804 0e02 9091 0000 		lds r25,g_buffer_head
 4805 0e06 8091 0000 		lds r24,g_buffer_tail
 4806 0e0a 9813      		cpse r25,r24
 4807 0e0c 00C0      		rjmp .L426
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 4808               		.loc 1 559 0
 4809 0e0e 8091 0000 		lds r24,g_buffer_tail
 4810 0e12 8F5F      		subi r24,lo8(-(1))
 4811 0e14 8093 0000 		sts g_buffer_tail,r24
 4812               	.L426:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 4813               		.loc 1 561 0
 4814 0e18 8091 0000 		lds r24,g_buffer_tail
 4815 0e1c 8034      		cpi r24,lo8(64)
 4816 0e1e 00F4      		brsh .+2
 4817 0e20 00C0      		rjmp .L424
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 4818               		.loc 1 562 0
 4819 0e22 1092 0000 		sts g_buffer_tail,__zero_reg__
 4820 0e26 00C0      		rjmp .L424
 4821               	.LVL125:
 4822               	.L609:
 4823               	.LBE675:
 4824               	.LBE674:
 4825               	.LBE676:
 4826               	.LBE732:
 4827               	.LBB733:
 4828               	.LBB696:
 4829               	.LBB686:
 4830               	.LBB684:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 4831               		.loc 1 559 0
 4832 0e28 8091 0000 		lds r24,g_buffer_tail
 4833 0e2c 8F5F      		subi r24,lo8(-(1))
 4834 0e2e 8093 0000 		sts g_buffer_tail,r24
 4835 0e32 00C0      		rjmp .L445
 4836               	.L572:
 4837               	.LBE684:
 4838               	.LBE686:
 4839               	.LBE696:
 4840               	.LBE733:
 4841               	.LBB734:
 4842               	.LBB460:
 4843               	.LBB453:
 4844               	.LBB451:
 4845 0e34 8091 0000 		lds r24,g_buffer_tail
 4846 0e38 8F5F      		subi r24,lo8(-(1))
 4847 0e3a 8093 0000 		sts g_buffer_tail,r24
 4848 0e3e 00C0      		rjmp .L264
 4849               	.L576:
 4850               	.LBE451:
 4851               	.LBE453:
 4852               	.LBE460:
 4853               	.LBE734:
 4854               	.LBB735:
 4855               	.LBB525:
 4856               	.LBB515:
 4857               	.LBB513:
 4858 0e40 8091 0000 		lds r24,g_buffer_tail
 4859 0e44 8F5F      		subi r24,lo8(-(1))
 4860 0e46 8093 0000 		sts g_buffer_tail,r24
 4861 0e4a 00C0      		rjmp .L282
 4862               	.L574:
 4863               	.LVL126:
 4864               	.LBE513:
 4865               	.LBE515:
 4866               	.LBB516:
 4867               	.LBB517:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 4868               		.loc 1 553 0
 4869 0e4c E091 0000 		lds r30,g_buffer_head
 4870 0e50 F0E0      		ldi r31,0
 4871 0e52 E050      		subi r30,lo8(-(g_event_buffer))
 4872 0e54 F040      		sbci r31,hi8(-(g_event_buffer))
 4873 0e56 27E0      		ldi r18,lo8(7)
 4874 0e58 2083      		st Z,r18
 554:easyrider.c   ****   g_buffer_head++; // advance head
 4875               		.loc 1 554 0
 4876 0e5a 8091 0000 		lds r24,g_buffer_head
 4877 0e5e 8F5F      		subi r24,lo8(-(1))
 4878 0e60 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 4879               		.loc 1 555 0
 4880 0e64 8091 0000 		lds r24,g_buffer_head
 4881 0e68 8034      		cpi r24,lo8(64)
 4882 0e6a 00F0      		brlo .L273
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 4883               		.loc 1 556 0
 4884 0e6c 1092 0000 		sts g_buffer_head,__zero_reg__
 4885               	.L273:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 4886               		.loc 1 558 0
 4887 0e70 9091 0000 		lds r25,g_buffer_head
 4888 0e74 8091 0000 		lds r24,g_buffer_tail
 4889 0e78 9817      		cp r25,r24
 4890 0e7a 01F4      		brne .+2
 4891 0e7c 00C0      		rjmp .L617
 4892               	.L274:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 4893               		.loc 1 561 0
 4894 0e7e 8091 0000 		lds r24,g_buffer_tail
 4895 0e82 8034      		cpi r24,lo8(64)
 4896 0e84 00F4      		brsh .+2
 4897 0e86 00C0      		rjmp .L266
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 4898               		.loc 1 562 0
 4899 0e88 1092 0000 		sts g_buffer_tail,__zero_reg__
 4900 0e8c 00C0      		rjmp .L266
 4901               	.LVL127:
 4902               	.L573:
 4903               	.LBE517:
 4904               	.LBE516:
 4905               	.LBB519:
 4906               	.LBB520:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 4907               		.loc 1 553 0
 4908 0e8e E091 0000 		lds r30,g_buffer_head
 4909 0e92 F0E0      		ldi r31,0
 4910 0e94 E050      		subi r30,lo8(-(g_event_buffer))
 4911 0e96 F040      		sbci r31,hi8(-(g_event_buffer))
 4912 0e98 86E0      		ldi r24,lo8(6)
 4913 0e9a 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 4914               		.loc 1 554 0
 4915 0e9c 8091 0000 		lds r24,g_buffer_head
 4916 0ea0 8F5F      		subi r24,lo8(-(1))
 4917 0ea2 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 4918               		.loc 1 555 0
 4919 0ea6 8091 0000 		lds r24,g_buffer_head
 4920 0eaa 8034      		cpi r24,lo8(64)
 4921 0eac 00F0      		brlo .L269
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 4922               		.loc 1 556 0
 4923 0eae 1092 0000 		sts g_buffer_head,__zero_reg__
 4924               	.L269:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 4925               		.loc 1 558 0
 4926 0eb2 9091 0000 		lds r25,g_buffer_head
 4927 0eb6 8091 0000 		lds r24,g_buffer_tail
 4928 0eba 9817      		cp r25,r24
 4929 0ebc 01F4      		brne .+2
 4930 0ebe 00C0      		rjmp .L618
 4931               	.L270:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 4932               		.loc 1 561 0
 4933 0ec0 8091 0000 		lds r24,g_buffer_tail
 4934 0ec4 8034      		cpi r24,lo8(64)
 4935 0ec6 00F4      		brsh .+2
 4936 0ec8 00C0      		rjmp .L268
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 4937               		.loc 1 562 0
 4938 0eca 1092 0000 		sts g_buffer_tail,__zero_reg__
 4939 0ece 00C0      		rjmp .L268
 4940               	.LVL128:
 4941               	.L580:
 4942               	.LBE520:
 4943               	.LBE519:
 4944               	.LBE525:
 4945               	.LBE735:
 4946               	.LBB736:
 4947               	.LBB547:
 4948               	.LBB537:
 4949               	.LBB535:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 4950               		.loc 1 559 0
 4951 0ed0 8091 0000 		lds r24,g_buffer_tail
 4952 0ed4 8F5F      		subi r24,lo8(-(1))
 4953 0ed6 8093 0000 		sts g_buffer_tail,r24
 4954 0eda 00C0      		rjmp .L300
 4955               	.L570:
 4956               	.LVL129:
 4957               	.LBE535:
 4958               	.LBE537:
 4959               	.LBE547:
 4960               	.LBE736:
 4961               	.LBB737:
 4962               	.LBB461:
 4963               	.LBB454:
 4964               	.LBB440:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 4965               		.loc 1 553 0
 4966 0edc E091 0000 		lds r30,g_buffer_head
 4967 0ee0 F0E0      		ldi r31,0
 4968 0ee2 E050      		subi r30,lo8(-(g_event_buffer))
 4969 0ee4 F040      		sbci r31,hi8(-(g_event_buffer))
 4970 0ee6 C082      		st Z,r12
 554:easyrider.c   ****   g_buffer_head++; // advance head
 4971               		.loc 1 554 0
 4972 0ee8 8091 0000 		lds r24,g_buffer_head
 4973 0eec 8F5F      		subi r24,lo8(-(1))
 4974 0eee 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 4975               		.loc 1 555 0
 4976 0ef2 8091 0000 		lds r24,g_buffer_head
 4977 0ef6 8034      		cpi r24,lo8(64)
 4978 0ef8 00F0      		brlo .L255
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 4979               		.loc 1 556 0
 4980 0efa 1092 0000 		sts g_buffer_head,__zero_reg__
 4981               	.L255:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 4982               		.loc 1 558 0
 4983 0efe 9091 0000 		lds r25,g_buffer_head
 4984 0f02 8091 0000 		lds r24,g_buffer_tail
 4985 0f06 9817      		cp r25,r24
 4986 0f08 01F4      		brne .+2
 4987 0f0a 00C0      		rjmp .L619
 4988               	.L256:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 4989               		.loc 1 561 0
 4990 0f0c 8091 0000 		lds r24,g_buffer_tail
 4991 0f10 8034      		cpi r24,lo8(64)
 4992 0f12 00F4      		brsh .+2
 4993 0f14 00C0      		rjmp .L248
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 4994               		.loc 1 562 0
 4995 0f16 1092 0000 		sts g_buffer_tail,__zero_reg__
 4996 0f1a 00C0      		rjmp .L248
 4997               	.LVL130:
 4998               	.L569:
 4999               	.LBE440:
 5000               	.LBE454:
 5001               	.LBB455:
 5002               	.LBB444:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5003               		.loc 1 553 0
 5004 0f1c E091 0000 		lds r30,g_buffer_head
 5005 0f20 F0E0      		ldi r31,0
 5006 0f22 E050      		subi r30,lo8(-(g_event_buffer))
 5007 0f24 F040      		sbci r31,hi8(-(g_event_buffer))
 5008 0f26 D082      		st Z,r13
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5009               		.loc 1 554 0
 5010 0f28 8091 0000 		lds r24,g_buffer_head
 5011 0f2c 8F5F      		subi r24,lo8(-(1))
 5012 0f2e 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5013               		.loc 1 555 0
 5014 0f32 8091 0000 		lds r24,g_buffer_head
 5015 0f36 8034      		cpi r24,lo8(64)
 5016 0f38 00F0      		brlo .L251
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5017               		.loc 1 556 0
 5018 0f3a 1092 0000 		sts g_buffer_head,__zero_reg__
 5019               	.L251:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5020               		.loc 1 558 0
 5021 0f3e 9091 0000 		lds r25,g_buffer_head
 5022 0f42 8091 0000 		lds r24,g_buffer_tail
 5023 0f46 9817      		cp r25,r24
 5024 0f48 01F4      		brne .+2
 5025 0f4a 00C0      		rjmp .L620
 5026               	.L252:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5027               		.loc 1 561 0
 5028 0f4c 8091 0000 		lds r24,g_buffer_tail
 5029 0f50 8034      		cpi r24,lo8(64)
 5030 0f52 00F4      		brsh .+2
 5031 0f54 00C0      		rjmp .L250
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5032               		.loc 1 562 0
 5033 0f56 1092 0000 		sts g_buffer_tail,__zero_reg__
 5034 0f5a 00C0      		rjmp .L250
 5035               	.LVL131:
 5036               	.L582:
 5037               	.LBE444:
 5038               	.LBE455:
 5039               	.LBE461:
 5040               	.LBE737:
 5041               	.LBB738:
 5042               	.LBB571:
 5043               	.LBB561:
 5044               	.LBB562:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5045               		.loc 1 553 0
 5046 0f5c E091 0000 		lds r30,g_buffer_head
 5047 0f60 F0E0      		ldi r31,0
 5048 0f62 E050      		subi r30,lo8(-(g_event_buffer))
 5049 0f64 F040      		sbci r31,hi8(-(g_event_buffer))
 5050 0f66 85E0      		ldi r24,lo8(5)
 5051 0f68 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5052               		.loc 1 554 0
 5053 0f6a 8091 0000 		lds r24,g_buffer_head
 5054 0f6e 8F5F      		subi r24,lo8(-(1))
 5055 0f70 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5056               		.loc 1 555 0
 5057 0f74 8091 0000 		lds r24,g_buffer_head
 5058 0f78 8034      		cpi r24,lo8(64)
 5059 0f7a 00F0      		brlo .L309
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5060               		.loc 1 556 0
 5061 0f7c 1092 0000 		sts g_buffer_head,__zero_reg__
 5062               	.L309:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5063               		.loc 1 558 0
 5064 0f80 9091 0000 		lds r25,g_buffer_head
 5065 0f84 8091 0000 		lds r24,g_buffer_tail
 5066 0f88 9817      		cp r25,r24
 5067 0f8a 01F4      		brne .+2
 5068 0f8c 00C0      		rjmp .L621
 5069               	.L310:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5070               		.loc 1 561 0
 5071 0f8e 8091 0000 		lds r24,g_buffer_tail
 5072 0f92 8034      		cpi r24,lo8(64)
 5073 0f94 00F4      		brsh .+2
 5074 0f96 00C0      		rjmp .L302
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5075               		.loc 1 562 0
 5076 0f98 1092 0000 		sts g_buffer_tail,__zero_reg__
 5077 0f9c 00C0      		rjmp .L302
 5078               	.LVL132:
 5079               	.L578:
 5080               	.LBE562:
 5081               	.LBE561:
 5082               	.LBE571:
 5083               	.LBE738:
 5084               	.LBB739:
 5085               	.LBB548:
 5086               	.LBB538:
 5087               	.LBB539:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5088               		.loc 1 553 0
 5089 0f9e E091 0000 		lds r30,g_buffer_head
 5090 0fa2 F0E0      		ldi r31,0
 5091 0fa4 E050      		subi r30,lo8(-(g_event_buffer))
 5092 0fa6 F040      		sbci r31,hi8(-(g_event_buffer))
 5093 0fa8 84E0      		ldi r24,lo8(4)
 5094 0faa 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5095               		.loc 1 554 0
 5096 0fac 8091 0000 		lds r24,g_buffer_head
 5097 0fb0 8F5F      		subi r24,lo8(-(1))
 5098 0fb2 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5099               		.loc 1 555 0
 5100 0fb6 8091 0000 		lds r24,g_buffer_head
 5101 0fba 8034      		cpi r24,lo8(64)
 5102 0fbc 00F0      		brlo .L291
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5103               		.loc 1 556 0
 5104 0fbe 1092 0000 		sts g_buffer_head,__zero_reg__
 5105               	.L291:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5106               		.loc 1 558 0
 5107 0fc2 9091 0000 		lds r25,g_buffer_head
 5108 0fc6 8091 0000 		lds r24,g_buffer_tail
 5109 0fca 9817      		cp r25,r24
 5110 0fcc 01F4      		brne .+2
 5111 0fce 00C0      		rjmp .L622
 5112               	.L292:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5113               		.loc 1 561 0
 5114 0fd0 8091 0000 		lds r24,g_buffer_tail
 5115 0fd4 8034      		cpi r24,lo8(64)
 5116 0fd6 00F4      		brsh .+2
 5117 0fd8 00C0      		rjmp .L284
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5118               		.loc 1 562 0
 5119 0fda 1092 0000 		sts g_buffer_tail,__zero_reg__
 5120 0fde 00C0      		rjmp .L284
 5121               	.LVL133:
 5122               	.L584:
 5123               	.LBE539:
 5124               	.LBE538:
 5125               	.LBE548:
 5126               	.LBE739:
 5127               	.LBB740:
 5128               	.LBB572:
 5129               	.LBB564:
 5130               	.LBB559:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 5131               		.loc 1 559 0
 5132 0fe0 8091 0000 		lds r24,g_buffer_tail
 5133 0fe4 8F5F      		subi r24,lo8(-(1))
 5134 0fe6 8093 0000 		sts g_buffer_tail,r24
 5135 0fea 00C0      		rjmp .L318
 5136               	.L577:
 5137               	.LVL134:
 5138               	.LBE559:
 5139               	.LBE564:
 5140               	.LBE572:
 5141               	.LBE740:
 5142               	.LBB741:
 5143               	.LBB549:
 5144               	.LBB541:
 5145               	.LBB542:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5146               		.loc 1 553 0
 5147 0fec E091 0000 		lds r30,g_buffer_head
 5148 0ff0 F0E0      		ldi r31,0
 5149 0ff2 E050      		subi r30,lo8(-(g_event_buffer))
 5150 0ff4 F040      		sbci r31,hi8(-(g_event_buffer))
 5151 0ff6 82E0      		ldi r24,lo8(2)
 5152 0ff8 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5153               		.loc 1 554 0
 5154 0ffa 8091 0000 		lds r24,g_buffer_head
 5155 0ffe 8F5F      		subi r24,lo8(-(1))
 5156 1000 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5157               		.loc 1 555 0
 5158 1004 8091 0000 		lds r24,g_buffer_head
 5159 1008 8034      		cpi r24,lo8(64)
 5160 100a 00F0      		brlo .L287
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5161               		.loc 1 556 0
 5162 100c 1092 0000 		sts g_buffer_head,__zero_reg__
 5163               	.L287:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5164               		.loc 1 558 0
 5165 1010 9091 0000 		lds r25,g_buffer_head
 5166 1014 8091 0000 		lds r24,g_buffer_tail
 5167 1018 9817      		cp r25,r24
 5168 101a 01F4      		brne .+2
 5169 101c 00C0      		rjmp .L623
 5170               	.L288:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5171               		.loc 1 561 0
 5172 101e 8091 0000 		lds r24,g_buffer_tail
 5173 1022 8034      		cpi r24,lo8(64)
 5174 1024 00F4      		brsh .+2
 5175 1026 00C0      		rjmp .L286
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5176               		.loc 1 562 0
 5177 1028 1092 0000 		sts g_buffer_tail,__zero_reg__
 5178 102c 00C0      		rjmp .L286
 5179               	.LVL135:
 5180               	.L581:
 5181               	.LBE542:
 5182               	.LBE541:
 5183               	.LBE549:
 5184               	.LBE741:
 5185               	.LBB742:
 5186               	.LBB573:
 5187               	.LBB565:
 5188               	.LBB566:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5189               		.loc 1 553 0
 5190 102e E091 0000 		lds r30,g_buffer_head
 5191 1032 F0E0      		ldi r31,0
 5192 1034 E050      		subi r30,lo8(-(g_event_buffer))
 5193 1036 F040      		sbci r31,hi8(-(g_event_buffer))
 5194 1038 83E0      		ldi r24,lo8(3)
 5195 103a 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5196               		.loc 1 554 0
 5197 103c 8091 0000 		lds r24,g_buffer_head
 5198 1040 8F5F      		subi r24,lo8(-(1))
 5199 1042 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5200               		.loc 1 555 0
 5201 1046 8091 0000 		lds r24,g_buffer_head
 5202 104a 8034      		cpi r24,lo8(64)
 5203 104c 00F0      		brlo .L305
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5204               		.loc 1 556 0
 5205 104e 1092 0000 		sts g_buffer_head,__zero_reg__
 5206               	.L305:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5207               		.loc 1 558 0
 5208 1052 9091 0000 		lds r25,g_buffer_head
 5209 1056 8091 0000 		lds r24,g_buffer_tail
 5210 105a 9817      		cp r25,r24
 5211 105c 01F4      		brne .+2
 5212 105e 00C0      		rjmp .L624
 5213               	.L306:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5214               		.loc 1 561 0
 5215 1060 8091 0000 		lds r24,g_buffer_tail
 5216 1064 8034      		cpi r24,lo8(64)
 5217 1066 00F4      		brsh .+2
 5218 1068 00C0      		rjmp .L304
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5219               		.loc 1 562 0
 5220 106a 1092 0000 		sts g_buffer_tail,__zero_reg__
 5221 106e 00C0      		rjmp .L304
 5222               	.LVL136:
 5223               	.L596:
 5224               	.LBE566:
 5225               	.LBE565:
 5226               	.LBE573:
 5227               	.LBE742:
 5228               	.LBB743:
 5229               	.LBB637:
 5230               	.LBB627:
 5231               	.LBB625:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 5232               		.loc 1 559 0
 5233 1070 8091 0000 		lds r24,g_buffer_tail
 5234 1074 8F5F      		subi r24,lo8(-(1))
 5235 1076 8093 0000 		sts g_buffer_tail,r24
 5236 107a 00C0      		rjmp .L372
 5237               	.L588:
 5238               	.LBE625:
 5239               	.LBE627:
 5240               	.LBE637:
 5241               	.LBE743:
 5242               	.LBB744:
 5243               	.LBB593:
 5244               	.LBB588:
 5245               	.LBB586:
 5246 107c 8091 0000 		lds r24,g_buffer_tail
 5247 1080 8F5F      		subi r24,lo8(-(1))
 5248 1082 8093 0000 		sts g_buffer_tail,r24
 5249 1086 00C0      		rjmp .L336
 5250               	.L592:
 5251               	.LBE586:
 5252               	.LBE588:
 5253               	.LBE593:
 5254               	.LBE744:
 5255               	.LBB745:
 5256               	.LBB615:
 5257               	.LBB605:
 5258               	.LBB603:
 5259 1088 8091 0000 		lds r24,g_buffer_tail
 5260 108c 8F5F      		subi r24,lo8(-(1))
 5261 108e 8093 0000 		sts g_buffer_tail,r24
 5262 1092 00C0      		rjmp .L354
 5263               	.L590:
 5264               	.LVL137:
 5265               	.LBE603:
 5266               	.LBE605:
 5267               	.LBB606:
 5268               	.LBB607:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5269               		.loc 1 553 0
 5270 1094 E091 0000 		lds r30,g_buffer_head
 5271 1098 F0E0      		ldi r31,0
 5272 109a E050      		subi r30,lo8(-(g_event_buffer))
 5273 109c F040      		sbci r31,hi8(-(g_event_buffer))
 5274 109e 8BE0      		ldi r24,lo8(11)
 5275 10a0 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5276               		.loc 1 554 0
 5277 10a2 8091 0000 		lds r24,g_buffer_head
 5278 10a6 8F5F      		subi r24,lo8(-(1))
 5279 10a8 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5280               		.loc 1 555 0
 5281 10ac 8091 0000 		lds r24,g_buffer_head
 5282 10b0 8034      		cpi r24,lo8(64)
 5283 10b2 00F0      		brlo .L345
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5284               		.loc 1 556 0
 5285 10b4 1092 0000 		sts g_buffer_head,__zero_reg__
 5286               	.L345:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5287               		.loc 1 558 0
 5288 10b8 9091 0000 		lds r25,g_buffer_head
 5289 10bc 8091 0000 		lds r24,g_buffer_tail
 5290 10c0 9817      		cp r25,r24
 5291 10c2 01F4      		brne .+2
 5292 10c4 00C0      		rjmp .L625
 5293               	.L346:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5294               		.loc 1 561 0
 5295 10c6 8091 0000 		lds r24,g_buffer_tail
 5296 10ca 8034      		cpi r24,lo8(64)
 5297 10cc 00F4      		brsh .+2
 5298 10ce 00C0      		rjmp .L338
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5299               		.loc 1 562 0
 5300 10d0 1092 0000 		sts g_buffer_tail,__zero_reg__
 5301 10d4 00C0      		rjmp .L338
 5302               	.LVL138:
 5303               	.L589:
 5304               	.LBE607:
 5305               	.LBE606:
 5306               	.LBB609:
 5307               	.LBB610:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5308               		.loc 1 553 0
 5309 10d6 E091 0000 		lds r30,g_buffer_head
 5310 10da F0E0      		ldi r31,0
 5311 10dc E050      		subi r30,lo8(-(g_event_buffer))
 5312 10de F040      		sbci r31,hi8(-(g_event_buffer))
 5313 10e0 8AE0      		ldi r24,lo8(10)
 5314 10e2 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5315               		.loc 1 554 0
 5316 10e4 8091 0000 		lds r24,g_buffer_head
 5317 10e8 8F5F      		subi r24,lo8(-(1))
 5318 10ea 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5319               		.loc 1 555 0
 5320 10ee 8091 0000 		lds r24,g_buffer_head
 5321 10f2 8034      		cpi r24,lo8(64)
 5322 10f4 00F0      		brlo .L341
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5323               		.loc 1 556 0
 5324 10f6 1092 0000 		sts g_buffer_head,__zero_reg__
 5325               	.L341:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5326               		.loc 1 558 0
 5327 10fa 9091 0000 		lds r25,g_buffer_head
 5328 10fe 8091 0000 		lds r24,g_buffer_tail
 5329 1102 9817      		cp r25,r24
 5330 1104 01F4      		brne .+2
 5331 1106 00C0      		rjmp .L626
 5332               	.L342:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5333               		.loc 1 561 0
 5334 1108 8091 0000 		lds r24,g_buffer_tail
 5335 110c 8034      		cpi r24,lo8(64)
 5336 110e 00F4      		brsh .+2
 5337 1110 00C0      		rjmp .L340
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5338               		.loc 1 562 0
 5339 1112 1092 0000 		sts g_buffer_tail,__zero_reg__
 5340 1116 00C0      		rjmp .L340
 5341               	.LVL139:
 5342               	.L594:
 5343               	.LBE610:
 5344               	.LBE609:
 5345               	.LBE615:
 5346               	.LBE745:
 5347               	.LBB746:
 5348               	.LBB638:
 5349               	.LBB628:
 5350               	.LBB629:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5351               		.loc 1 553 0
 5352 1118 E091 0000 		lds r30,g_buffer_head
 5353 111c F0E0      		ldi r31,0
 5354 111e E050      		subi r30,lo8(-(g_event_buffer))
 5355 1120 F040      		sbci r31,hi8(-(g_event_buffer))
 5356 1122 83E1      		ldi r24,lo8(19)
 5357 1124 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5358               		.loc 1 554 0
 5359 1126 8091 0000 		lds r24,g_buffer_head
 5360 112a 8F5F      		subi r24,lo8(-(1))
 5361 112c 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5362               		.loc 1 555 0
 5363 1130 8091 0000 		lds r24,g_buffer_head
 5364 1134 8034      		cpi r24,lo8(64)
 5365 1136 00F0      		brlo .L363
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5366               		.loc 1 556 0
 5367 1138 1092 0000 		sts g_buffer_head,__zero_reg__
 5368               	.L363:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5369               		.loc 1 558 0
 5370 113c 9091 0000 		lds r25,g_buffer_head
 5371 1140 8091 0000 		lds r24,g_buffer_tail
 5372 1144 9817      		cp r25,r24
 5373 1146 01F4      		brne .+2
 5374 1148 00C0      		rjmp .L627
 5375               	.L364:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5376               		.loc 1 561 0
 5377 114a 8091 0000 		lds r24,g_buffer_tail
 5378 114e 8034      		cpi r24,lo8(64)
 5379 1150 00F4      		brsh .+2
 5380 1152 00C0      		rjmp .L356
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5381               		.loc 1 562 0
 5382 1154 1092 0000 		sts g_buffer_tail,__zero_reg__
 5383 1158 00C0      		rjmp .L356
 5384               	.LVL140:
 5385               	.L602:
 5386               	.LBE629:
 5387               	.LBE628:
 5388               	.LBE638:
 5389               	.LBE746:
 5390               	.LBB747:
 5391               	.LBB663:
 5392               	.LBB653:
 5393               	.LBB651:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 5394               		.loc 1 559 0
 5395 115a 8091 0000 		lds r24,g_buffer_tail
 5396 115e 8F5F      		subi r24,lo8(-(1))
 5397 1160 8093 0000 		sts g_buffer_tail,r24
 5398 1164 00C0      		rjmp .L401
 5399               	.L593:
 5400               	.LVL141:
 5401               	.LBE651:
 5402               	.LBE653:
 5403               	.LBE663:
 5404               	.LBE747:
 5405               	.LBB748:
 5406               	.LBB639:
 5407               	.LBB631:
 5408               	.LBB632:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5409               		.loc 1 553 0
 5410 1166 E091 0000 		lds r30,g_buffer_head
 5411 116a F0E0      		ldi r31,0
 5412 116c E050      		subi r30,lo8(-(g_event_buffer))
 5413 116e F040      		sbci r31,hi8(-(g_event_buffer))
 5414 1170 82E1      		ldi r24,lo8(18)
 5415 1172 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5416               		.loc 1 554 0
 5417 1174 8091 0000 		lds r24,g_buffer_head
 5418 1178 8F5F      		subi r24,lo8(-(1))
 5419 117a 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5420               		.loc 1 555 0
 5421 117e 8091 0000 		lds r24,g_buffer_head
 5422 1182 8034      		cpi r24,lo8(64)
 5423 1184 00F0      		brlo .L359
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5424               		.loc 1 556 0
 5425 1186 1092 0000 		sts g_buffer_head,__zero_reg__
 5426               	.L359:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5427               		.loc 1 558 0
 5428 118a 9091 0000 		lds r25,g_buffer_head
 5429 118e 8091 0000 		lds r24,g_buffer_tail
 5430 1192 9817      		cp r25,r24
 5431 1194 01F4      		brne .+2
 5432 1196 00C0      		rjmp .L628
 5433               	.L360:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5434               		.loc 1 561 0
 5435 1198 8091 0000 		lds r24,g_buffer_tail
 5436 119c 8034      		cpi r24,lo8(64)
 5437 119e 00F4      		brsh .+2
 5438 11a0 00C0      		rjmp .L358
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5439               		.loc 1 562 0
 5440 11a2 1092 0000 		sts g_buffer_tail,__zero_reg__
 5441 11a6 00C0      		rjmp .L358
 5442               	.LVL142:
 5443               	.L607:
 5444               	.LBE632:
 5445               	.LBE631:
 5446               	.LBE639:
 5447               	.LBE748:
 5448               	.LBB749:
 5449               	.LBB697:
 5450               	.LBB687:
 5451               	.LBB688:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5452               		.loc 1 553 0
 5453 11a8 E091 0000 		lds r30,g_buffer_head
 5454 11ac F0E0      		ldi r31,0
 5455 11ae E050      		subi r30,lo8(-(g_event_buffer))
 5456 11b0 F040      		sbci r31,hi8(-(g_event_buffer))
 5457 11b2 85E1      		ldi r24,lo8(21)
 5458 11b4 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5459               		.loc 1 554 0
 5460 11b6 8091 0000 		lds r24,g_buffer_head
 5461 11ba 8F5F      		subi r24,lo8(-(1))
 5462 11bc 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5463               		.loc 1 555 0
 5464 11c0 8091 0000 		lds r24,g_buffer_head
 5465 11c4 8034      		cpi r24,lo8(64)
 5466 11c6 00F0      		brlo .L436
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5467               		.loc 1 556 0
 5468 11c8 1092 0000 		sts g_buffer_head,__zero_reg__
 5469               	.L436:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5470               		.loc 1 558 0
 5471 11cc 9091 0000 		lds r25,g_buffer_head
 5472 11d0 8091 0000 		lds r24,g_buffer_tail
 5473 11d4 9817      		cp r25,r24
 5474 11d6 01F4      		brne .+2
 5475 11d8 00C0      		rjmp .L629
 5476               	.L437:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5477               		.loc 1 561 0
 5478 11da 8091 0000 		lds r24,g_buffer_tail
 5479 11de 8034      		cpi r24,lo8(64)
 5480 11e0 00F4      		brsh .+2
 5481 11e2 00C0      		rjmp .L429
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5482               		.loc 1 562 0
 5483 11e4 1092 0000 		sts g_buffer_tail,__zero_reg__
 5484 11e8 00C0      		rjmp .L429
 5485               	.LVL143:
 5486               	.L600:
 5487               	.LBE688:
 5488               	.LBE687:
 5489               	.LBE697:
 5490               	.LBE749:
 5491               	.LBB750:
 5492               	.LBB664:
 5493               	.LBB654:
 5494               	.LBB655:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5495               		.loc 1 553 0
 5496 11ea E091 0000 		lds r30,g_buffer_head
 5497 11ee F0E0      		ldi r31,0
 5498 11f0 E050      		subi r30,lo8(-(g_event_buffer))
 5499 11f2 F040      		sbci r31,hi8(-(g_event_buffer))
 5500 11f4 8FE0      		ldi r24,lo8(15)
 5501 11f6 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5502               		.loc 1 554 0
 5503 11f8 8091 0000 		lds r24,g_buffer_head
 5504 11fc 8F5F      		subi r24,lo8(-(1))
 5505 11fe 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5506               		.loc 1 555 0
 5507 1202 8091 0000 		lds r24,g_buffer_head
 5508 1206 8034      		cpi r24,lo8(64)
 5509 1208 00F0      		brlo .L392
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5510               		.loc 1 556 0
 5511 120a 1092 0000 		sts g_buffer_head,__zero_reg__
 5512               	.L392:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5513               		.loc 1 558 0
 5514 120e 9091 0000 		lds r25,g_buffer_head
 5515 1212 8091 0000 		lds r24,g_buffer_tail
 5516 1216 9817      		cp r25,r24
 5517 1218 01F4      		brne .+2
 5518 121a 00C0      		rjmp .L630
 5519               	.L393:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5520               		.loc 1 561 0
 5521 121c 8091 0000 		lds r24,g_buffer_tail
 5522 1220 8034      		cpi r24,lo8(64)
 5523 1222 00F4      		brsh .+2
 5524 1224 00C0      		rjmp .L385
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5525               		.loc 1 562 0
 5526 1226 1092 0000 		sts g_buffer_tail,__zero_reg__
 5527 122a 00C0      		rjmp .L385
 5528               	.LVL144:
 5529               	.L606:
 5530               	.LBE655:
 5531               	.LBE654:
 5532               	.LBE664:
 5533               	.LBE750:
 5534               	.LBB751:
 5535               	.LBB698:
 5536               	.LBB690:
 5537               	.LBB691:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5538               		.loc 1 553 0
 5539 122c E091 0000 		lds r30,g_buffer_head
 5540 1230 F0E0      		ldi r31,0
 5541 1232 E050      		subi r30,lo8(-(g_event_buffer))
 5542 1234 F040      		sbci r31,hi8(-(g_event_buffer))
 5543 1236 84E1      		ldi r24,lo8(20)
 5544 1238 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5545               		.loc 1 554 0
 5546 123a 8091 0000 		lds r24,g_buffer_head
 5547 123e 8F5F      		subi r24,lo8(-(1))
 5548 1240 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5549               		.loc 1 555 0
 5550 1244 8091 0000 		lds r24,g_buffer_head
 5551 1248 8034      		cpi r24,lo8(64)
 5552 124a 00F0      		brlo .L432
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5553               		.loc 1 556 0
 5554 124c 1092 0000 		sts g_buffer_head,__zero_reg__
 5555               	.L432:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5556               		.loc 1 558 0
 5557 1250 9091 0000 		lds r25,g_buffer_head
 5558 1254 8091 0000 		lds r24,g_buffer_tail
 5559 1258 9817      		cp r25,r24
 5560 125a 01F4      		brne .+2
 5561 125c 00C0      		rjmp .L631
 5562               	.L433:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5563               		.loc 1 561 0
 5564 125e 8091 0000 		lds r24,g_buffer_tail
 5565 1262 8034      		cpi r24,lo8(64)
 5566 1264 00F4      		brsh .+2
 5567 1266 00C0      		rjmp .L431
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5568               		.loc 1 562 0
 5569 1268 1092 0000 		sts g_buffer_tail,__zero_reg__
 5570 126c 00C0      		rjmp .L431
 5571               	.LVL145:
 5572               	.L599:
 5573               	.LBE691:
 5574               	.LBE690:
 5575               	.LBE698:
 5576               	.LBE751:
 5577               	.LBB752:
 5578               	.LBB665:
 5579               	.LBB657:
 5580               	.LBB658:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5581               		.loc 1 553 0
 5582 126e E091 0000 		lds r30,g_buffer_head
 5583 1272 F0E0      		ldi r31,0
 5584 1274 E050      		subi r30,lo8(-(g_event_buffer))
 5585 1276 F040      		sbci r31,hi8(-(g_event_buffer))
 5586 1278 8EE0      		ldi r24,lo8(14)
 5587 127a 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5588               		.loc 1 554 0
 5589 127c 8091 0000 		lds r24,g_buffer_head
 5590 1280 8F5F      		subi r24,lo8(-(1))
 5591 1282 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5592               		.loc 1 555 0
 5593 1286 8091 0000 		lds r24,g_buffer_head
 5594 128a 8034      		cpi r24,lo8(64)
 5595 128c 00F0      		brlo .L388
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5596               		.loc 1 556 0
 5597 128e 1092 0000 		sts g_buffer_head,__zero_reg__
 5598               	.L388:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5599               		.loc 1 558 0
 5600 1292 9091 0000 		lds r25,g_buffer_head
 5601 1296 8091 0000 		lds r24,g_buffer_tail
 5602 129a 9817      		cp r25,r24
 5603 129c 01F4      		brne .+2
 5604 129e 00C0      		rjmp .L632
 5605               	.L389:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5606               		.loc 1 561 0
 5607 12a0 8091 0000 		lds r24,g_buffer_tail
 5608 12a4 8034      		cpi r24,lo8(64)
 5609 12a6 00F4      		brsh .+2
 5610 12a8 00C0      		rjmp .L387
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5611               		.loc 1 562 0
 5612 12aa 1092 0000 		sts g_buffer_tail,__zero_reg__
 5613 12ae 00C0      		rjmp .L387
 5614               	.LVL146:
 5615               	.L585:
 5616               	.LBE658:
 5617               	.LBE657:
 5618               	.LBE665:
 5619               	.LBE752:
 5620               	.LBB753:
 5621               	.LBB594:
 5622               	.LBB589:
 5623               	.LBB580:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 5624               		.loc 1 559 0
 5625 12b0 8091 0000 		lds r24,g_buffer_tail
 5626 12b4 8F5F      		subi r24,lo8(-(1))
 5627 12b6 8093 0000 		sts g_buffer_tail,r24
 5628 12ba 00C0      		rjmp .L324
 5629               	.LVL147:
 5630               	.L598:
 5631               	.LBE580:
 5632               	.LBE589:
 5633               	.LBE594:
 5634               	.LBE753:
 5635               	.LBB754:
 5636               	.LBB483:
1083:easyrider.c   ****           TIMSK3 &= ~(1 << OCIE3A); // disable interrupt
 5637               		.loc 1 1083 0
 5638 12bc 8091 7100 		lds r24,113
 5639               	.LVL148:
 5640 12c0 8D7F      		andi r24,lo8(-3)
 5641 12c2 8093 7100 		sts 113,r24
1084:easyrider.c   ****           PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
 5642               		.loc 1 1084 0
 5643 12c6 5D98      		cbi 0xb,5
 5644 12c8 00C0      		rjmp .L383
 5645               	.LVL149:
 5646               	.L417:
 5647               	.LBE483:
 5648               	.LBE754:
 5649               	.LBB755:
 5650               	.LBB502:
 524:easyrider.c   ****         PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
 5651               		.loc 1 524 0
 5652 12ca 4298      		cbi 0x8,2
 5653 12cc 00C0      		rjmp .L418
 5654               	.L586:
 5655               	.LVL150:
 5656               	.LBE502:
 5657               	.LBE755:
 5658               	.LBB756:
 5659               	.LBB595:
 5660               	.LBB590:
 5661               	.LBB591:
 553:easyrider.c   ****   g_event_buffer[g_buffer_head] = ev; // insert event at head position
 5662               		.loc 1 553 0
 5663 12ce E091 0000 		lds r30,g_buffer_head
 5664 12d2 F0E0      		ldi r31,0
 5665 12d4 E050      		subi r30,lo8(-(g_event_buffer))
 5666 12d6 F040      		sbci r31,hi8(-(g_event_buffer))
 5667 12d8 8DE0      		ldi r24,lo8(13)
 5668 12da 8083      		st Z,r24
 554:easyrider.c   ****   g_buffer_head++; // advance head
 5669               		.loc 1 554 0
 5670 12dc 8091 0000 		lds r24,g_buffer_head
 5671 12e0 8F5F      		subi r24,lo8(-(1))
 5672 12e2 8093 0000 		sts g_buffer_head,r24
 555:easyrider.c   ****   if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
 5673               		.loc 1 555 0
 5674 12e6 8091 0000 		lds r24,g_buffer_head
 5675 12ea 8034      		cpi r24,lo8(64)
 5676 12ec 00F0      		brlo .L327
 556:easyrider.c   ****     g_buffer_head = 0; // cycle back to start
 5677               		.loc 1 556 0
 5678 12ee 1092 0000 		sts g_buffer_head,__zero_reg__
 5679               	.L327:
 558:easyrider.c   ****   if (g_buffer_head == g_buffer_tail) {
 5680               		.loc 1 558 0
 5681 12f2 9091 0000 		lds r25,g_buffer_head
 5682 12f6 8091 0000 		lds r24,g_buffer_tail
 5683 12fa 9813      		cpse r25,r24
 5684 12fc 00C0      		rjmp .L328
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 5685               		.loc 1 559 0
 5686 12fe 8091 0000 		lds r24,g_buffer_tail
 5687 1302 8F5F      		subi r24,lo8(-(1))
 5688 1304 8093 0000 		sts g_buffer_tail,r24
 5689               	.L328:
 561:easyrider.c   ****   if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
 5690               		.loc 1 561 0
 5691 1308 8091 0000 		lds r24,g_buffer_tail
 5692 130c 8034      		cpi r24,lo8(64)
 5693 130e 00F4      		brsh .+2
 5694 1310 00C0      		rjmp .L320
 562:easyrider.c   ****     g_buffer_tail = 0; // cycle back to start
 5695               		.loc 1 562 0
 5696 1312 1092 0000 		sts g_buffer_tail,__zero_reg__
 5697 1316 00C0      		rjmp .L320
 5698               	.LVL151:
 5699               	.L613:
 5700               	.LBE591:
 5701               	.LBE590:
 5702               	.LBE595:
 5703               	.LBE756:
 5704               	.LBB757:
 5705               	.LBB715:
 5706               	.LBB714:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 5707               		.loc 1 559 0
 5708 1318 8091 0000 		lds r24,g_buffer_tail
 5709 131c 8F5F      		subi r24,lo8(-(1))
 5710 131e 8093 0000 		sts g_buffer_tail,r24
 5711 1322 00C0      		rjmp .L452
 5712               	.LVL152:
 5713               	.L632:
 5714               	.LBE714:
 5715               	.LBE715:
 5716               	.LBE757:
 5717               	.LBB758:
 5718               	.LBB666:
 5719               	.LBB660:
 5720               	.LBB659:
 5721 1324 8091 0000 		lds r24,g_buffer_tail
 5722 1328 8F5F      		subi r24,lo8(-(1))
 5723 132a 8093 0000 		sts g_buffer_tail,r24
 5724 132e 00C0      		rjmp .L389
 5725               	.LVL153:
 5726               	.L621:
 5727               	.LBE659:
 5728               	.LBE660:
 5729               	.LBE666:
 5730               	.LBE758:
 5731               	.LBB759:
 5732               	.LBB574:
 5733               	.LBB568:
 5734               	.LBB563:
 5735 1330 8091 0000 		lds r24,g_buffer_tail
 5736 1334 8F5F      		subi r24,lo8(-(1))
 5737 1336 8093 0000 		sts g_buffer_tail,r24
 5738 133a 00C0      		rjmp .L310
 5739               	.LVL154:
 5740               	.L625:
 5741               	.LBE563:
 5742               	.LBE568:
 5743               	.LBE574:
 5744               	.LBE759:
 5745               	.LBB760:
 5746               	.LBB616:
 5747               	.LBB612:
 5748               	.LBB608:
 5749 133c 8091 0000 		lds r24,g_buffer_tail
 5750 1340 8F5F      		subi r24,lo8(-(1))
 5751 1342 8093 0000 		sts g_buffer_tail,r24
 5752 1346 00C0      		rjmp .L346
 5753               	.LVL155:
 5754               	.L614:
 5755               	.LBE608:
 5756               	.LBE612:
 5757               	.LBE616:
 5758               	.LBE760:
 5759               	.LBB761:
 5760               	.LBB503:
 526:easyrider.c   ****       if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
 5761               		.loc 1 526 0
 5762 1348 9195      		neg r25
 5763 134a 8195      		neg r24
 5764 134c 9109      		sbc r25,__zero_reg__
 5765 134e 00C0      		rjmp .L420
 5766               	.LVL156:
 5767               	.L380:
 5768               	.LBE503:
 5769               	.LBE761:
 5770               	.LBB762:
 5771               	.LBB484:
1077:easyrider.c   ****           g_music_tempo = pgm_read_word(g_current_music);
 5772               		.loc 1 1077 0
 5773 1350 2093 0000 		sts g_music_tempo,r18
 5774 1354 0296      		adiw r24,2
1078:easyrider.c   ****           g_current_music++;
 5775               		.loc 1 1078 0
 5776 1356 622F      		mov r22,r18
 5777 1358 9C01      		movw r18,r24
 5778               	.LVL157:
 5779 135a 00C0      		rjmp .L381
 5780               	.LVL158:
 5781               	.L617:
 5782               	.LBE484:
 5783               	.LBE762:
 5784               	.LBB763:
 5785               	.LBB526:
 5786               	.LBB522:
 5787               	.LBB518:
 559:easyrider.c   ****     g_buffer_tail++; // also move tail, basically destroying an event to make space
 5788               		.loc 1 559 0
 5789 135c 8091 0000 		lds r24,g_buffer_tail
 5790 1360 8F5F      		subi r24,lo8(-(1))
 5791 1362 8093 0000 		sts g_buffer_tail,r24
 5792 1366 00C0      		rjmp .L274
 5793               	.LVL159:
 5794               	.L619:
 5795               	.LBE518:
 5796               	.LBE522:
 5797               	.LBE526:
 5798               	.LBE763:
 5799               	.LBB764:
 5800               	.LBB462:
 5801               	.LBB456:
 5802               	.LBB441:
 5803 1368 8091 0000 		lds r24,g_buffer_tail
 5804 136c 8F5F      		subi r24,lo8(-(1))
 5805 136e 8093 0000 		sts g_buffer_tail,r24
 5806 1372 00C0      		rjmp .L256
 5807               	.LVL160:
 5808               	.L618:
 5809               	.LBE441:
 5810               	.LBE456:
 5811               	.LBE462:
 5812               	.LBE764:
 5813               	.LBB765:
 5814               	.LBB527:
 5815               	.LBB523:
 5816               	.LBB521:
 5817 1374 8091 0000 		lds r24,g_buffer_tail
 5818 1378 8F5F      		subi r24,lo8(-(1))
 5819 137a 8093 0000 		sts g_buffer_tail,r24
 5820 137e 00C0      		rjmp .L270
 5821               	.LVL161:
 5822               	.L622:
 5823               	.LBE521:
 5824               	.LBE523:
 5825               	.LBE527:
 5826               	.LBE765:
 5827               	.LBB766:
 5828               	.LBB550:
 5829               	.LBB544:
 5830               	.LBB540:
 5831 1380 8091 0000 		lds r24,g_buffer_tail
 5832 1384 8F5F      		subi r24,lo8(-(1))
 5833 1386 8093 0000 		sts g_buffer_tail,r24
 5834 138a 00C0      		rjmp .L292
 5835               	.LVL162:
 5836               	.L620:
 5837               	.LBE540:
 5838               	.LBE544:
 5839               	.LBE550:
 5840               	.LBE766:
 5841               	.LBB767:
 5842               	.LBB463:
 5843               	.LBB457:
 5844               	.LBB445:
 5845 138c 8091 0000 		lds r24,g_buffer_tail
 5846 1390 8F5F      		subi r24,lo8(-(1))
 5847 1392 8093 0000 		sts g_buffer_tail,r24
 5848 1396 00C0      		rjmp .L252
 5849               	.LVL163:
 5850               	.L623:
 5851               	.LBE445:
 5852               	.LBE457:
 5853               	.LBE463:
 5854               	.LBE767:
 5855               	.LBB768:
 5856               	.LBB551:
 5857               	.LBB545:
 5858               	.LBB543:
 5859 1398 8091 0000 		lds r24,g_buffer_tail
 5860 139c 8F5F      		subi r24,lo8(-(1))
 5861 139e 8093 0000 		sts g_buffer_tail,r24
 5862 13a2 00C0      		rjmp .L288
 5863               	.LVL164:
 5864               	.L626:
 5865               	.LBE543:
 5866               	.LBE545:
 5867               	.LBE551:
 5868               	.LBE768:
 5869               	.LBB769:
 5870               	.LBB617:
 5871               	.LBB613:
 5872               	.LBB611:
 5873 13a4 8091 0000 		lds r24,g_buffer_tail
 5874 13a8 8F5F      		subi r24,lo8(-(1))
 5875 13aa 8093 0000 		sts g_buffer_tail,r24
 5876 13ae 00C0      		rjmp .L342
 5877               	.LVL165:
 5878               	.L627:
 5879               	.LBE611:
 5880               	.LBE613:
 5881               	.LBE617:
 5882               	.LBE769:
 5883               	.LBB770:
 5884               	.LBB640:
 5885               	.LBB634:
 5886               	.LBB630:
 5887 13b0 8091 0000 		lds r24,g_buffer_tail
 5888 13b4 8F5F      		subi r24,lo8(-(1))
 5889 13b6 8093 0000 		sts g_buffer_tail,r24
 5890 13ba 00C0      		rjmp .L364
 5891               	.LVL166:
 5892               	.L629:
 5893               	.LBE630:
 5894               	.LBE634:
 5895               	.LBE640:
 5896               	.LBE770:
 5897               	.LBB771:
 5898               	.LBB699:
 5899               	.LBB693:
 5900               	.LBB689:
 5901 13bc 8091 0000 		lds r24,g_buffer_tail
 5902 13c0 8F5F      		subi r24,lo8(-(1))
 5903 13c2 8093 0000 		sts g_buffer_tail,r24
 5904 13c6 00C0      		rjmp .L437
 5905               	.LVL167:
 5906               	.L631:
 5907               	.LBE689:
 5908               	.LBE693:
 5909               	.LBB694:
 5910               	.LBB692:
 5911 13c8 8091 0000 		lds r24,g_buffer_tail
 5912 13cc 8F5F      		subi r24,lo8(-(1))
 5913 13ce 8093 0000 		sts g_buffer_tail,r24
 5914 13d2 00C0      		rjmp .L433
 5915               	.LVL168:
 5916               	.L624:
 5917               	.LBE692:
 5918               	.LBE694:
 5919               	.LBE699:
 5920               	.LBE771:
 5921               	.LBB772:
 5922               	.LBB575:
 5923               	.LBB569:
 5924               	.LBB567:
 5925 13d4 8091 0000 		lds r24,g_buffer_tail
 5926 13d8 8F5F      		subi r24,lo8(-(1))
 5927 13da 8093 0000 		sts g_buffer_tail,r24
 5928 13de 00C0      		rjmp .L306
 5929               	.LVL169:
 5930               	.L628:
 5931               	.LBE567:
 5932               	.LBE569:
 5933               	.LBE575:
 5934               	.LBE772:
 5935               	.LBB773:
 5936               	.LBB641:
 5937               	.LBB635:
 5938               	.LBB633:
 5939 13e0 8091 0000 		lds r24,g_buffer_tail
 5940 13e4 8F5F      		subi r24,lo8(-(1))
 5941 13e6 8093 0000 		sts g_buffer_tail,r24
 5942 13ea 00C0      		rjmp .L360
 5943               	.LVL170:
 5944               	.L630:
 5945               	.LBE633:
 5946               	.LBE635:
 5947               	.LBE641:
 5948               	.LBE773:
 5949               	.LBB774:
 5950               	.LBB667:
 5951               	.LBB661:
 5952               	.LBB656:
 5953 13ec 8091 0000 		lds r24,g_buffer_tail
 5954 13f0 8F5F      		subi r24,lo8(-(1))
 5955 13f2 8093 0000 		sts g_buffer_tail,r24
 5956 13f6 00C0      		rjmp .L393
 5957               	.LVL171:
 5958               	.L616:
 5959               	.LBE656:
 5960               	.LBE661:
 5961               	.LBE667:
 5962               	.LBE774:
 5963               	.LBB775:
 5964               	.LBB504:
 528:easyrider.c   ****        (abs(g_adc_voltage[3] - g_alarm_snapshot[2]) > g_settings.alarm_trigger)) {
 5965               		.loc 1 528 0
 5966 13f8 9195      		neg r25
 5967 13fa 8195      		neg r24
 5968 13fc 9109      		sbc r25,__zero_reg__
 5969 13fe 00C0      		rjmp .L422
 5970               	.L615:
 527:easyrider.c   ****        (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
 5971               		.loc 1 527 0
 5972 1400 9195      		neg r25
 5973 1402 8195      		neg r24
 5974 1404 9109      		sbc r25,__zero_reg__
 5975 1406 00C0      		rjmp .L421
 5976               	.LBE504:
 5977               	.LBE775:
 5978               	.LBE777:
 5979               	.LBE784:
 5980               		.cfi_endproc
 5981               	.LFE81:
 5983               	.global	g_trans
 5984               		.data
 5987               	g_trans:
 5988 0000 0000      		.word	gs(check_claxon_on)
 5989 0002 06        		.byte	6
 5990 0003 0000      		.word	gs(process_claxon_on)
 5991 0005 0000      		.word	gs(check_claxon_off)
 5992 0007 07        		.byte	7
 5993 0008 0000      		.word	gs(process_claxon_off)
 5994 000a 0000      		.word	gs(check_ri_on)
 5995 000c 02        		.byte	2
 5996 000d 0000      		.word	gs(process_ri_on)
 5997 000f 0000      		.word	gs(check_ri_off)
 5998 0011 04        		.byte	4
 5999 0012 0000      		.word	gs(process_ri_off)
 6000 0014 0000      		.word	gs(check_li_on)
 6001 0016 03        		.byte	3
 6002 0017 0000      		.word	gs(process_li_on)
 6003 0019 0000      		.word	gs(check_li_off)
 6004 001b 05        		.byte	5
 6005 001c 0000      		.word	gs(process_li_off)
 6006 001e 0000      		.word	gs(check_ign_on)
 6007 0020 12        		.byte	18
 6008 0021 0000      		.word	gs(process_ign_on)
 6009 0023 0000      		.word	gs(check_ign_off)
 6010 0025 13        		.byte	19
 6011 0026 0000      		.word	gs(process_ign_off)
 6012 0028 0000      		.word	gs(check_alarm_on)
 6013 002a 0E        		.byte	14
 6014 002b 0000      		.word	gs(process_alarm_on)
 6015 002d 0000      		.word	gs(check_alarm_off)
 6016 002f 0F        		.byte	15
 6017 0030 0000      		.word	gs(process_alarm_off)
 6018 0032 0000      		.word	gs(check_brake_on)
 6019 0034 08        		.byte	8
 6020 0035 0000      		.word	gs(process_brake_on)
 6021 0037 0000      		.word	gs(check_brake_off)
 6022 0039 09        		.byte	9
 6023 003a 0000      		.word	gs(process_brake_off)
 6024 003c 0000      		.word	gs(check_pilot_on)
 6025 003e 0A        		.byte	10
 6026 003f 0000      		.word	gs(process_pilot_on)
 6027 0041 0000      		.word	gs(check_pilot_off)
 6028 0043 0B        		.byte	11
 6029 0044 0000      		.word	gs(process_pilot_off)
 6030 0046 0000      		.word	gs(check_light_on)
 6031 0048 0C        		.byte	12
 6032 0049 0000      		.word	gs(process_light_on)
 6033 004b 0000      		.word	gs(check_light_off)
 6034 004d 0D        		.byte	13
 6035 004e 0000      		.word	gs(process_light_off)
 6036 0050 0000      		.word	gs(check_battery_read)
 6037 0052 10        		.byte	16
 6038 0053 0000      		.word	gs(process_battery)
 6039 0055 0000      		.word	gs(check_warning_on)
 6040 0057 14        		.byte	20
 6041 0058 0000      		.word	gs(process_warning_on)
 6042 005a 0000      		.word	gs(check_warning_off)
 6043 005c 15        		.byte	21
 6044 005d 0000      		.word	gs(process_warning_off)
 6045 005f 0000      		.word	gs(check_backpedal_on)
 6046 0061 16        		.byte	22
 6047 0062 0000      		.word	gs(process_backpedal)
 6048               	.global	g_music_popcorn
 6049               		.section	.progmem.data,"a",@progbits
 6052               	g_music_popcorn:
 6053 0000 7D00      		.word	125
 6054 0002 1000      		.word	16
 6055 0004 6400      		.word	100
 6056 0006 1000      		.word	16
 6057 0008 0100      		.word	1
 6058 000a 1000      		.word	16
 6059 000c 7000      		.word	112
 6060 000e 1000      		.word	16
 6061 0010 0100      		.word	1
 6062 0012 1000      		.word	16
 6063 0014 6400      		.word	100
 6064 0016 1000      		.word	16
 6065 0018 0100      		.word	1
 6066 001a 1000      		.word	16
 6067 001c 8500      		.word	133
 6068 001e 1000      		.word	16
 6069 0020 0100      		.word	1
 6070 0022 1000      		.word	16
 6071 0024 A800      		.word	168
 6072 0026 1000      		.word	16
 6073 0028 8500      		.word	133
 6074 002a 1000      		.word	16
 6075 002c 0100      		.word	1
 6076 002e 1000      		.word	16
 6077 0030 C700      		.word	199
 6078 0032 0400      		.word	4
 6079 0034 0100      		.word	1
 6080 0036 1000      		.word	16
 6081 0038 6400      		.word	100
 6082 003a 1000      		.word	16
 6083 003c 0100      		.word	1
 6084 003e 1000      		.word	16
 6085 0040 7000      		.word	112
 6086 0042 1000      		.word	16
 6087 0044 0100      		.word	1
 6088 0046 1000      		.word	16
 6089 0048 6400      		.word	100
 6090 004a 1000      		.word	16
 6091 004c 0100      		.word	1
 6092 004e 1000      		.word	16
 6093 0050 8500      		.word	133
 6094 0052 1000      		.word	16
 6095 0054 0100      		.word	1
 6096 0056 1000      		.word	16
 6097 0058 A800      		.word	168
 6098 005a 1000      		.word	16
 6099 005c 8500      		.word	133
 6100 005e 1000      		.word	16
 6101 0060 0100      		.word	1
 6102 0062 1000      		.word	16
 6103 0064 C700      		.word	199
 6104 0066 0400      		.word	4
 6105 0068 0100      		.word	1
 6106 006a 1000      		.word	16
 6107 006c 6400      		.word	100
 6108 006e 1000      		.word	16
 6109 0070 0100      		.word	1
 6110 0072 1000      		.word	16
 6111 0074 5900      		.word	89
 6112 0076 1000      		.word	16
 6113 0078 0100      		.word	1
 6114 007a 1000      		.word	16
 6115 007c 5400      		.word	84
 6116 007e 1000      		.word	16
 6117 0080 0100      		.word	1
 6118 0082 1000      		.word	16
 6119 0084 5900      		.word	89
 6120 0086 1000      		.word	16
 6121 0088 5400      		.word	84
 6122 008a 1000      		.word	16
 6123 008c 0100      		.word	1
 6124 008e 1000      		.word	16
 6125 0090 5400      		.word	84
 6126 0092 1000      		.word	16
 6127 0094 0100      		.word	1
 6128 0096 1000      		.word	16
 6129 0098 6400      		.word	100
 6130 009a 1000      		.word	16
 6131 009c 5900      		.word	89
 6132 009e 1000      		.word	16
 6133 00a0 0100      		.word	1
 6134 00a2 1000      		.word	16
 6135 00a4 6400      		.word	100
 6136 00a6 1000      		.word	16
 6137 00a8 5900      		.word	89
 6138 00aa 1000      		.word	16
 6139 00ac 0100      		.word	1
 6140 00ae 1000      		.word	16
 6141 00b0 5900      		.word	89
 6142 00b2 1000      		.word	16
 6143 00b4 0100      		.word	1
 6144 00b6 1000      		.word	16
 6145 00b8 7000      		.word	112
 6146 00ba 1000      		.word	16
 6147 00bc 6400      		.word	100
 6148 00be 1000      		.word	16
 6149 00c0 0100      		.word	1
 6150 00c2 1000      		.word	16
 6151 00c4 7000      		.word	112
 6152 00c6 1000      		.word	16
 6153 00c8 6400      		.word	100
 6154 00ca 1000      		.word	16
 6155 00cc 0100      		.word	1
 6156 00ce 1000      		.word	16
 6157 00d0 6400      		.word	100
 6158 00d2 1000      		.word	16
 6159 00d4 0100      		.word	1
 6160 00d6 1000      		.word	16
 6161 00d8 7000      		.word	112
 6162 00da 1000      		.word	16
 6163 00dc 6400      		.word	100
 6164 00de 0400      		.word	4
 6165 00e0 0100      		.word	1
 6166 00e2 1000      		.word	16
 6167 00e4 6400      		.word	100
 6168 00e6 1000      		.word	16
 6169 00e8 0100      		.word	1
 6170 00ea 1000      		.word	16
 6171 00ec 7000      		.word	112
 6172 00ee 1000      		.word	16
 6173 00f0 0100      		.word	1
 6174 00f2 1000      		.word	16
 6175 00f4 6400      		.word	100
 6176 00f6 1000      		.word	16
 6177 00f8 0100      		.word	1
 6178 00fa 1000      		.word	16
 6179 00fc 8500      		.word	133
 6180 00fe 1000      		.word	16
 6181 0100 0100      		.word	1
 6182 0102 1000      		.word	16
 6183 0104 A800      		.word	168
 6184 0106 1000      		.word	16
 6185 0108 8500      		.word	133
 6186 010a 1000      		.word	16
 6187 010c 0100      		.word	1
 6188 010e 1000      		.word	16
 6189 0110 C700      		.word	199
 6190 0112 0400      		.word	4
 6191 0114 0100      		.word	1
 6192 0116 1000      		.word	16
 6193 0118 6400      		.word	100
 6194 011a 1000      		.word	16
 6195 011c 0100      		.word	1
 6196 011e 1000      		.word	16
 6197 0120 7000      		.word	112
 6198 0122 1000      		.word	16
 6199 0124 0100      		.word	1
 6200 0126 1000      		.word	16
 6201 0128 6400      		.word	100
 6202 012a 1000      		.word	16
 6203 012c 0100      		.word	1
 6204 012e 1000      		.word	16
 6205 0130 8500      		.word	133
 6206 0132 1000      		.word	16
 6207 0134 0100      		.word	1
 6208 0136 1000      		.word	16
 6209 0138 A800      		.word	168
 6210 013a 1000      		.word	16
 6211 013c 8500      		.word	133
 6212 013e 1000      		.word	16
 6213 0140 0100      		.word	1
 6214 0142 1000      		.word	16
 6215 0144 C700      		.word	199
 6216 0146 0400      		.word	4
 6217 0148 0100      		.word	1
 6218 014a 1000      		.word	16
 6219 014c 6400      		.word	100
 6220 014e 1000      		.word	16
 6221 0150 0100      		.word	1
 6222 0152 1000      		.word	16
 6223 0154 5900      		.word	89
 6224 0156 1000      		.word	16
 6225 0158 0100      		.word	1
 6226 015a 1000      		.word	16
 6227 015c 5400      		.word	84
 6228 015e 1000      		.word	16
 6229 0160 0100      		.word	1
 6230 0162 1000      		.word	16
 6231 0164 5900      		.word	89
 6232 0166 1000      		.word	16
 6233 0168 5400      		.word	84
 6234 016a 1000      		.word	16
 6235 016c 0100      		.word	1
 6236 016e 1000      		.word	16
 6237 0170 5400      		.word	84
 6238 0172 1000      		.word	16
 6239 0174 0100      		.word	1
 6240 0176 1000      		.word	16
 6241 0178 6400      		.word	100
 6242 017a 1000      		.word	16
 6243 017c 5900      		.word	89
 6244 017e 1000      		.word	16
 6245 0180 0100      		.word	1
 6246 0182 1000      		.word	16
 6247 0184 6400      		.word	100
 6248 0186 1000      		.word	16
 6249 0188 5900      		.word	89
 6250 018a 1000      		.word	16
 6251 018c 0100      		.word	1
 6252 018e 1000      		.word	16
 6253 0190 5900      		.word	89
 6254 0192 1000      		.word	16
 6255 0194 0100      		.word	1
 6256 0196 1000      		.word	16
 6257 0198 7000      		.word	112
 6258 019a 1000      		.word	16
 6259 019c 6400      		.word	100
 6260 019e 1000      		.word	16
 6261 01a0 0100      		.word	1
 6262 01a2 1000      		.word	16
 6263 01a4 7000      		.word	112
 6264 01a6 1000      		.word	16
 6265 01a8 6400      		.word	100
 6266 01aa 1000      		.word	16
 6267 01ac 0100      		.word	1
 6268 01ae 1000      		.word	16
 6269 01b0 6400      		.word	100
 6270 01b2 1000      		.word	16
 6271 01b4 0100      		.word	1
 6272 01b6 1000      		.word	16
 6273 01b8 5900      		.word	89
 6274 01ba 1000      		.word	16
 6275 01bc 5400      		.word	84
 6276 01be 0400      		.word	4
 6277 01c0 0100      		.word	1
 6278 01c2 1000      		.word	16
 6279 01c4 4300      		.word	67
 6280 01c6 1000      		.word	16
 6281 01c8 0100      		.word	1
 6282 01ca 1000      		.word	16
 6283 01cc 4B00      		.word	75
 6284 01ce 1000      		.word	16
 6285 01d0 0100      		.word	1
 6286 01d2 1000      		.word	16
 6287 01d4 4300      		.word	67
 6288 01d6 1000      		.word	16
 6289 01d8 0100      		.word	1
 6290 01da 1000      		.word	16
 6291 01dc 5400      		.word	84
 6292 01de 1000      		.word	16
 6293 01e0 0100      		.word	1
 6294 01e2 1000      		.word	16
 6295 01e4 7000      		.word	112
 6296 01e6 1000      		.word	16
 6297 01e8 5400      		.word	84
 6298 01ea 1000      		.word	16
 6299 01ec 0100      		.word	1
 6300 01ee 1000      		.word	16
 6301 01f0 8500      		.word	133
 6302 01f2 0400      		.word	4
 6303 01f4 0100      		.word	1
 6304 01f6 1000      		.word	16
 6305 01f8 4300      		.word	67
 6306 01fa 1000      		.word	16
 6307 01fc 0100      		.word	1
 6308 01fe 1000      		.word	16
 6309 0200 4B00      		.word	75
 6310 0202 1000      		.word	16
 6311 0204 0100      		.word	1
 6312 0206 1000      		.word	16
 6313 0208 4300      		.word	67
 6314 020a 1000      		.word	16
 6315 020c 0100      		.word	1
 6316 020e 1000      		.word	16
 6317 0210 5400      		.word	84
 6318 0212 1000      		.word	16
 6319 0214 0100      		.word	1
 6320 0216 1000      		.word	16
 6321 0218 7000      		.word	112
 6322 021a 1000      		.word	16
 6323 021c 5400      		.word	84
 6324 021e 1000      		.word	16
 6325 0220 0100      		.word	1
 6326 0222 1000      		.word	16
 6327 0224 8500      		.word	133
 6328 0226 0400      		.word	4
 6329 0228 0100      		.word	1
 6330 022a 1000      		.word	16
 6331 022c 4300      		.word	67
 6332 022e 1000      		.word	16
 6333 0230 0100      		.word	1
 6334 0232 1000      		.word	16
 6335 0234 3B00      		.word	59
 6336 0236 1000      		.word	16
 6337 0238 0100      		.word	1
 6338 023a 1000      		.word	16
 6339 023c 3800      		.word	56
 6340 023e 1000      		.word	16
 6341 0240 0100      		.word	1
 6342 0242 1000      		.word	16
 6343 0244 3B00      		.word	59
 6344 0246 1000      		.word	16
 6345 0248 3800      		.word	56
 6346 024a 1000      		.word	16
 6347 024c 0100      		.word	1
 6348 024e 1000      		.word	16
 6349 0250 3800      		.word	56
 6350 0252 1000      		.word	16
 6351 0254 0100      		.word	1
 6352 0256 1000      		.word	16
 6353 0258 4300      		.word	67
 6354 025a 1000      		.word	16
 6355 025c 3B00      		.word	59
 6356 025e 1000      		.word	16
 6357 0260 0100      		.word	1
 6358 0262 1000      		.word	16
 6359 0264 4300      		.word	67
 6360 0266 1000      		.word	16
 6361 0268 3B00      		.word	59
 6362 026a 1000      		.word	16
 6363 026c 0100      		.word	1
 6364 026e 1000      		.word	16
 6365 0270 3B00      		.word	59
 6366 0272 1000      		.word	16
 6367 0274 0100      		.word	1
 6368 0276 1000      		.word	16
 6369 0278 4B00      		.word	75
 6370 027a 1000      		.word	16
 6371 027c 4300      		.word	67
 6372 027e 1000      		.word	16
 6373 0280 0100      		.word	1
 6374 0282 1000      		.word	16
 6375 0284 4B00      		.word	75
 6376 0286 1000      		.word	16
 6377 0288 4300      		.word	67
 6378 028a 1000      		.word	16
 6379 028c 0100      		.word	1
 6380 028e 1000      		.word	16
 6381 0290 4300      		.word	67
 6382 0292 1000      		.word	16
 6383 0294 0100      		.word	1
 6384 0296 1000      		.word	16
 6385 0298 4B00      		.word	75
 6386 029a 1000      		.word	16
 6387 029c 4300      		.word	67
 6388 029e 0400      		.word	4
 6389 02a0 0100      		.word	1
 6390 02a2 1000      		.word	16
 6391 02a4 4300      		.word	67
 6392 02a6 1000      		.word	16
 6393 02a8 0100      		.word	1
 6394 02aa 1000      		.word	16
 6395 02ac 4B00      		.word	75
 6396 02ae 1000      		.word	16
 6397 02b0 0100      		.word	1
 6398 02b2 1000      		.word	16
 6399 02b4 4300      		.word	67
 6400 02b6 1000      		.word	16
 6401 02b8 0100      		.word	1
 6402 02ba 1000      		.word	16
 6403 02bc 5400      		.word	84
 6404 02be 1000      		.word	16
 6405 02c0 0100      		.word	1
 6406 02c2 1000      		.word	16
 6407 02c4 7000      		.word	112
 6408 02c6 1000      		.word	16
 6409 02c8 5400      		.word	84
 6410 02ca 1000      		.word	16
 6411 02cc 0100      		.word	1
 6412 02ce 1000      		.word	16
 6413 02d0 8500      		.word	133
 6414 02d2 0400      		.word	4
 6415 02d4 0100      		.word	1
 6416 02d6 1000      		.word	16
 6417 02d8 4300      		.word	67
 6418 02da 1000      		.word	16
 6419 02dc 0100      		.word	1
 6420 02de 1000      		.word	16
 6421 02e0 4B00      		.word	75
 6422 02e2 1000      		.word	16
 6423 02e4 0100      		.word	1
 6424 02e6 1000      		.word	16
 6425 02e8 4300      		.word	67
 6426 02ea 1000      		.word	16
 6427 02ec 0100      		.word	1
 6428 02ee 1000      		.word	16
 6429 02f0 5400      		.word	84
 6430 02f2 1000      		.word	16
 6431 02f4 0100      		.word	1
 6432 02f6 1000      		.word	16
 6433 02f8 7000      		.word	112
 6434 02fa 1000      		.word	16
 6435 02fc 5400      		.word	84
 6436 02fe 1000      		.word	16
 6437 0300 0100      		.word	1
 6438 0302 1000      		.word	16
 6439 0304 8500      		.word	133
 6440 0306 0400      		.word	4
 6441 0308 0100      		.word	1
 6442 030a 1000      		.word	16
 6443 030c 4300      		.word	67
 6444 030e 1000      		.word	16
 6445 0310 0100      		.word	1
 6446 0312 1000      		.word	16
 6447 0314 3B00      		.word	59
 6448 0316 1000      		.word	16
 6449 0318 0100      		.word	1
 6450 031a 1000      		.word	16
 6451 031c 3800      		.word	56
 6452 031e 1000      		.word	16
 6453 0320 0100      		.word	1
 6454 0322 1000      		.word	16
 6455 0324 3B00      		.word	59
 6456 0326 1000      		.word	16
 6457 0328 3800      		.word	56
 6458 032a 1000      		.word	16
 6459 032c 0100      		.word	1
 6460 032e 1000      		.word	16
 6461 0330 3800      		.word	56
 6462 0332 1000      		.word	16
 6463 0334 0100      		.word	1
 6464 0336 1000      		.word	16
 6465 0338 4300      		.word	67
 6466 033a 1000      		.word	16
 6467 033c 3B00      		.word	59
 6468 033e 1000      		.word	16
 6469 0340 0100      		.word	1
 6470 0342 1000      		.word	16
 6471 0344 4300      		.word	67
 6472 0346 1000      		.word	16
 6473 0348 3B00      		.word	59
 6474 034a 1000      		.word	16
 6475 034c 0100      		.word	1
 6476 034e 1000      		.word	16
 6477 0350 3B00      		.word	59
 6478 0352 1000      		.word	16
 6479 0354 0100      		.word	1
 6480 0356 1000      		.word	16
 6481 0358 4B00      		.word	75
 6482 035a 1000      		.word	16
 6483 035c 4300      		.word	67
 6484 035e 1000      		.word	16
 6485 0360 0100      		.word	1
 6486 0362 1000      		.word	16
 6487 0364 4B00      		.word	75
 6488 0366 1000      		.word	16
 6489 0368 5900      		.word	89
 6490 036a 1000      		.word	16
 6491 036c 0100      		.word	1
 6492 036e 1000      		.word	16
 6493 0370 5900      		.word	89
 6494 0372 1000      		.word	16
 6495 0374 4B00      		.word	75
 6496 0376 1000      		.word	16
 6497 0378 0100      		.word	1
 6498 037a 1000      		.word	16
 6499 037c 4300      		.word	67
 6500 037e 0400      		.word	4
 6501 0380 0100      		.word	1
 6502 0382 1000      		.word	16
 6503 0384 6400      		.word	100
 6504 0386 1000      		.word	16
 6505 0388 0100      		.word	1
 6506 038a 1000      		.word	16
 6507 038c 7000      		.word	112
 6508 038e 1000      		.word	16
 6509 0390 0100      		.word	1
 6510 0392 1000      		.word	16
 6511 0394 6400      		.word	100
 6512 0396 1000      		.word	16
 6513 0398 0100      		.word	1
 6514 039a 1000      		.word	16
 6515 039c 8500      		.word	133
 6516 039e 1000      		.word	16
 6517 03a0 0100      		.word	1
 6518 03a2 1000      		.word	16
 6519 03a4 A800      		.word	168
 6520 03a6 1000      		.word	16
 6521 03a8 8500      		.word	133
 6522 03aa 1000      		.word	16
 6523 03ac 0100      		.word	1
 6524 03ae 1000      		.word	16
 6525 03b0 C700      		.word	199
 6526 03b2 0400      		.word	4
 6527 03b4 0100      		.word	1
 6528 03b6 1000      		.word	16
 6529 03b8 6400      		.word	100
 6530 03ba 1000      		.word	16
 6531 03bc 0100      		.word	1
 6532 03be 1000      		.word	16
 6533 03c0 7000      		.word	112
 6534 03c2 1000      		.word	16
 6535 03c4 0100      		.word	1
 6536 03c6 1000      		.word	16
 6537 03c8 6400      		.word	100
 6538 03ca 1000      		.word	16
 6539 03cc 0100      		.word	1
 6540 03ce 1000      		.word	16
 6541 03d0 8500      		.word	133
 6542 03d2 1000      		.word	16
 6543 03d4 0100      		.word	1
 6544 03d6 1000      		.word	16
 6545 03d8 A800      		.word	168
 6546 03da 1000      		.word	16
 6547 03dc 8500      		.word	133
 6548 03de 1000      		.word	16
 6549 03e0 0100      		.word	1
 6550 03e2 1000      		.word	16
 6551 03e4 C700      		.word	199
 6552 03e6 0400      		.word	4
 6553 03e8 0100      		.word	1
 6554 03ea 1000      		.word	16
 6555 03ec 6400      		.word	100
 6556 03ee 1000      		.word	16
 6557 03f0 0100      		.word	1
 6558 03f2 1000      		.word	16
 6559 03f4 5900      		.word	89
 6560 03f6 1000      		.word	16
 6561 03f8 0100      		.word	1
 6562 03fa 1000      		.word	16
 6563 03fc 5400      		.word	84
 6564 03fe 1000      		.word	16
 6565 0400 0100      		.word	1
 6566 0402 1000      		.word	16
 6567 0404 5900      		.word	89
 6568 0406 1000      		.word	16
 6569 0408 5400      		.word	84
 6570 040a 1000      		.word	16
 6571 040c 0100      		.word	1
 6572 040e 1000      		.word	16
 6573 0410 5400      		.word	84
 6574 0412 1000      		.word	16
 6575 0414 0100      		.word	1
 6576 0416 1000      		.word	16
 6577 0418 6400      		.word	100
 6578 041a 1000      		.word	16
 6579 041c 5900      		.word	89
 6580 041e 1000      		.word	16
 6581 0420 0100      		.word	1
 6582 0422 1000      		.word	16
 6583 0424 6400      		.word	100
 6584 0426 1000      		.word	16
 6585 0428 5900      		.word	89
 6586 042a 1000      		.word	16
 6587 042c 0100      		.word	1
 6588 042e 1000      		.word	16
 6589 0430 5900      		.word	89
 6590 0432 1000      		.word	16
 6591 0434 0100      		.word	1
 6592 0436 1000      		.word	16
 6593 0438 7000      		.word	112
 6594 043a 1000      		.word	16
 6595 043c 6400      		.word	100
 6596 043e 1000      		.word	16
 6597 0440 0100      		.word	1
 6598 0442 1000      		.word	16
 6599 0444 7000      		.word	112
 6600 0446 1000      		.word	16
 6601 0448 6400      		.word	100
 6602 044a 1000      		.word	16
 6603 044c 0100      		.word	1
 6604 044e 1000      		.word	16
 6605 0450 6400      		.word	100
 6606 0452 1000      		.word	16
 6607 0454 0100      		.word	1
 6608 0456 1000      		.word	16
 6609 0458 7000      		.word	112
 6610 045a 1000      		.word	16
 6611 045c 6400      		.word	100
 6612 045e 0400      		.word	4
 6613 0460 0100      		.word	1
 6614 0462 1000      		.word	16
 6615 0464 6400      		.word	100
 6616 0466 1000      		.word	16
 6617 0468 0100      		.word	1
 6618 046a 1000      		.word	16
 6619 046c 7000      		.word	112
 6620 046e 1000      		.word	16
 6621 0470 0100      		.word	1
 6622 0472 1000      		.word	16
 6623 0474 6400      		.word	100
 6624 0476 1000      		.word	16
 6625 0478 0100      		.word	1
 6626 047a 1000      		.word	16
 6627 047c 8500      		.word	133
 6628 047e 1000      		.word	16
 6629 0480 0100      		.word	1
 6630 0482 1000      		.word	16
 6631 0484 A800      		.word	168
 6632 0486 1000      		.word	16
 6633 0488 8500      		.word	133
 6634 048a 1000      		.word	16
 6635 048c 0100      		.word	1
 6636 048e 1000      		.word	16
 6637 0490 C700      		.word	199
 6638 0492 0400      		.word	4
 6639 0494 0100      		.word	1
 6640 0496 1000      		.word	16
 6641 0498 6400      		.word	100
 6642 049a 1000      		.word	16
 6643 049c 0100      		.word	1
 6644 049e 1000      		.word	16
 6645 04a0 7000      		.word	112
 6646 04a2 1000      		.word	16
 6647 04a4 0100      		.word	1
 6648 04a6 1000      		.word	16
 6649 04a8 6400      		.word	100
 6650 04aa 1000      		.word	16
 6651 04ac 0100      		.word	1
 6652 04ae 1000      		.word	16
 6653 04b0 8500      		.word	133
 6654 04b2 1000      		.word	16
 6655 04b4 0100      		.word	1
 6656 04b6 1000      		.word	16
 6657 04b8 A800      		.word	168
 6658 04ba 1000      		.word	16
 6659 04bc 8500      		.word	133
 6660 04be 1000      		.word	16
 6661 04c0 0100      		.word	1
 6662 04c2 1000      		.word	16
 6663 04c4 C700      		.word	199
 6664 04c6 0400      		.word	4
 6665 04c8 0100      		.word	1
 6666 04ca 1000      		.word	16
 6667 04cc 6400      		.word	100
 6668 04ce 1000      		.word	16
 6669 04d0 0100      		.word	1
 6670 04d2 1000      		.word	16
 6671 04d4 5900      		.word	89
 6672 04d6 1000      		.word	16
 6673 04d8 0100      		.word	1
 6674 04da 1000      		.word	16
 6675 04dc 5400      		.word	84
 6676 04de 1000      		.word	16
 6677 04e0 0100      		.word	1
 6678 04e2 1000      		.word	16
 6679 04e4 5900      		.word	89
 6680 04e6 1000      		.word	16
 6681 04e8 5400      		.word	84
 6682 04ea 1000      		.word	16
 6683 04ec 0100      		.word	1
 6684 04ee 1000      		.word	16
 6685 04f0 5400      		.word	84
 6686 04f2 1000      		.word	16
 6687 04f4 0100      		.word	1
 6688 04f6 1000      		.word	16
 6689 04f8 6400      		.word	100
 6690 04fa 1000      		.word	16
 6691 04fc 5900      		.word	89
 6692 04fe 1000      		.word	16
 6693 0500 0100      		.word	1
 6694 0502 1000      		.word	16
 6695 0504 6400      		.word	100
 6696 0506 1000      		.word	16
 6697 0508 5900      		.word	89
 6698 050a 1000      		.word	16
 6699 050c 0100      		.word	1
 6700 050e 1000      		.word	16
 6701 0510 5900      		.word	89
 6702 0512 1000      		.word	16
 6703 0514 0100      		.word	1
 6704 0516 1000      		.word	16
 6705 0518 7000      		.word	112
 6706 051a 1000      		.word	16
 6707 051c 6400      		.word	100
 6708 051e 1000      		.word	16
 6709 0520 0100      		.word	1
 6710 0522 1000      		.word	16
 6711 0524 7000      		.word	112
 6712 0526 1000      		.word	16
 6713 0528 6400      		.word	100
 6714 052a 1000      		.word	16
 6715 052c 0100      		.word	1
 6716 052e 1000      		.word	16
 6717 0530 6400      		.word	100
 6718 0532 1000      		.word	16
 6719 0534 0100      		.word	1
 6720 0536 1000      		.word	16
 6721 0538 5900      		.word	89
 6722 053a 1000      		.word	16
 6723 053c 5400      		.word	84
 6724 053e 0400      		.word	4
 6725 0540 0100      		.word	1
 6726 0542 1000      		.word	16
 6727 0544 4300      		.word	67
 6728 0546 1000      		.word	16
 6729 0548 0100      		.word	1
 6730 054a 1000      		.word	16
 6731 054c 4B00      		.word	75
 6732 054e 1000      		.word	16
 6733 0550 0100      		.word	1
 6734 0552 1000      		.word	16
 6735 0554 4300      		.word	67
 6736 0556 1000      		.word	16
 6737 0558 0100      		.word	1
 6738 055a 1000      		.word	16
 6739 055c 5400      		.word	84
 6740 055e 1000      		.word	16
 6741 0560 0100      		.word	1
 6742 0562 1000      		.word	16
 6743 0564 7000      		.word	112
 6744 0566 1000      		.word	16
 6745 0568 5400      		.word	84
 6746 056a 1000      		.word	16
 6747 056c 0100      		.word	1
 6748 056e 1000      		.word	16
 6749 0570 8500      		.word	133
 6750 0572 0400      		.word	4
 6751 0574 0100      		.word	1
 6752 0576 1000      		.word	16
 6753 0578 4300      		.word	67
 6754 057a 1000      		.word	16
 6755 057c 0100      		.word	1
 6756 057e 1000      		.word	16
 6757 0580 4B00      		.word	75
 6758 0582 1000      		.word	16
 6759 0584 0100      		.word	1
 6760 0586 1000      		.word	16
 6761 0588 4300      		.word	67
 6762 058a 1000      		.word	16
 6763 058c 0100      		.word	1
 6764 058e 1000      		.word	16
 6765 0590 5400      		.word	84
 6766 0592 1000      		.word	16
 6767 0594 0100      		.word	1
 6768 0596 1000      		.word	16
 6769 0598 7000      		.word	112
 6770 059a 1000      		.word	16
 6771 059c 5400      		.word	84
 6772 059e 1000      		.word	16
 6773 05a0 0100      		.word	1
 6774 05a2 1000      		.word	16
 6775 05a4 8500      		.word	133
 6776 05a6 0400      		.word	4
 6777 05a8 0100      		.word	1
 6778 05aa 1000      		.word	16
 6779 05ac 4300      		.word	67
 6780 05ae 1000      		.word	16
 6781 05b0 0100      		.word	1
 6782 05b2 1000      		.word	16
 6783 05b4 3B00      		.word	59
 6784 05b6 1000      		.word	16
 6785 05b8 0100      		.word	1
 6786 05ba 1000      		.word	16
 6787 05bc 3800      		.word	56
 6788 05be 1000      		.word	16
 6789 05c0 0100      		.word	1
 6790 05c2 1000      		.word	16
 6791 05c4 3B00      		.word	59
 6792 05c6 1000      		.word	16
 6793 05c8 3800      		.word	56
 6794 05ca 1000      		.word	16
 6795 05cc 0100      		.word	1
 6796 05ce 1000      		.word	16
 6797 05d0 3800      		.word	56
 6798 05d2 1000      		.word	16
 6799 05d4 0100      		.word	1
 6800 05d6 1000      		.word	16
 6801 05d8 4300      		.word	67
 6802 05da 1000      		.word	16
 6803 05dc 3B00      		.word	59
 6804 05de 1000      		.word	16
 6805 05e0 0100      		.word	1
 6806 05e2 1000      		.word	16
 6807 05e4 4300      		.word	67
 6808 05e6 1000      		.word	16
 6809 05e8 3B00      		.word	59
 6810 05ea 1000      		.word	16
 6811 05ec 0100      		.word	1
 6812 05ee 1000      		.word	16
 6813 05f0 3B00      		.word	59
 6814 05f2 1000      		.word	16
 6815 05f4 0100      		.word	1
 6816 05f6 1000      		.word	16
 6817 05f8 4B00      		.word	75
 6818 05fa 1000      		.word	16
 6819 05fc 4300      		.word	67
 6820 05fe 1000      		.word	16
 6821 0600 0100      		.word	1
 6822 0602 1000      		.word	16
 6823 0604 4B00      		.word	75
 6824 0606 1000      		.word	16
 6825 0608 4300      		.word	67
 6826 060a 1000      		.word	16
 6827 060c 0100      		.word	1
 6828 060e 1000      		.word	16
 6829 0610 4300      		.word	67
 6830 0612 1000      		.word	16
 6831 0614 0100      		.word	1
 6832 0616 1000      		.word	16
 6833 0618 4B00      		.word	75
 6834 061a 1000      		.word	16
 6835 061c 4300      		.word	67
 6836 061e 0400      		.word	4
 6837 0620 0100      		.word	1
 6838 0622 1000      		.word	16
 6839 0624 4300      		.word	67
 6840 0626 1000      		.word	16
 6841 0628 0100      		.word	1
 6842 062a 1000      		.word	16
 6843 062c 4B00      		.word	75
 6844 062e 1000      		.word	16
 6845 0630 0100      		.word	1
 6846 0632 1000      		.word	16
 6847 0634 4300      		.word	67
 6848 0636 1000      		.word	16
 6849 0638 0100      		.word	1
 6850 063a 1000      		.word	16
 6851 063c 5400      		.word	84
 6852 063e 1000      		.word	16
 6853 0640 0100      		.word	1
 6854 0642 1000      		.word	16
 6855 0644 7000      		.word	112
 6856 0646 1000      		.word	16
 6857 0648 5400      		.word	84
 6858 064a 1000      		.word	16
 6859 064c 0100      		.word	1
 6860 064e 1000      		.word	16
 6861 0650 8500      		.word	133
 6862 0652 0400      		.word	4
 6863 0654 0100      		.word	1
 6864 0656 1000      		.word	16
 6865 0658 4300      		.word	67
 6866 065a 1000      		.word	16
 6867 065c 0100      		.word	1
 6868 065e 1000      		.word	16
 6869 0660 4B00      		.word	75
 6870 0662 1000      		.word	16
 6871 0664 0100      		.word	1
 6872 0666 1000      		.word	16
 6873 0668 4300      		.word	67
 6874 066a 1000      		.word	16
 6875 066c 0100      		.word	1
 6876 066e 1000      		.word	16
 6877 0670 5400      		.word	84
 6878 0672 1000      		.word	16
 6879 0674 0100      		.word	1
 6880 0676 1000      		.word	16
 6881 0678 7000      		.word	112
 6882 067a 1000      		.word	16
 6883 067c 5400      		.word	84
 6884 067e 1000      		.word	16
 6885 0680 0100      		.word	1
 6886 0682 1000      		.word	16
 6887 0684 8500      		.word	133
 6888 0686 0400      		.word	4
 6889 0688 0100      		.word	1
 6890 068a 1000      		.word	16
 6891 068c 4300      		.word	67
 6892 068e 1000      		.word	16
 6893 0690 0100      		.word	1
 6894 0692 1000      		.word	16
 6895 0694 3B00      		.word	59
 6896 0696 1000      		.word	16
 6897 0698 0100      		.word	1
 6898 069a 1000      		.word	16
 6899 069c 3800      		.word	56
 6900 069e 1000      		.word	16
 6901 06a0 0100      		.word	1
 6902 06a2 1000      		.word	16
 6903 06a4 3B00      		.word	59
 6904 06a6 1000      		.word	16
 6905 06a8 3800      		.word	56
 6906 06aa 1000      		.word	16
 6907 06ac 0100      		.word	1
 6908 06ae 1000      		.word	16
 6909 06b0 3800      		.word	56
 6910 06b2 1000      		.word	16
 6911 06b4 0100      		.word	1
 6912 06b6 1000      		.word	16
 6913 06b8 4300      		.word	67
 6914 06ba 1000      		.word	16
 6915 06bc 3B00      		.word	59
 6916 06be 1000      		.word	16
 6917 06c0 0100      		.word	1
 6918 06c2 1000      		.word	16
 6919 06c4 4300      		.word	67
 6920 06c6 1000      		.word	16
 6921 06c8 3B00      		.word	59
 6922 06ca 1000      		.word	16
 6923 06cc 0100      		.word	1
 6924 06ce 1000      		.word	16
 6925 06d0 3B00      		.word	59
 6926 06d2 1000      		.word	16
 6927 06d4 0100      		.word	1
 6928 06d6 1000      		.word	16
 6929 06d8 4B00      		.word	75
 6930 06da 1000      		.word	16
 6931 06dc 4300      		.word	67
 6932 06de 1000      		.word	16
 6933 06e0 0100      		.word	1
 6934 06e2 1000      		.word	16
 6935 06e4 4B00      		.word	75
 6936 06e6 1000      		.word	16
 6937 06e8 5900      		.word	89
 6938 06ea 1000      		.word	16
 6939 06ec 0100      		.word	1
 6940 06ee 1000      		.word	16
 6941 06f0 5900      		.word	89
 6942 06f2 1000      		.word	16
 6943 06f4 4B00      		.word	75
 6944 06f6 1000      		.word	16
 6945 06f8 0100      		.word	1
 6946 06fa 1000      		.word	16
 6947 06fc 4300      		.word	67
 6948 06fe 0000      		.word	0
 6949               	.global	g_music_pipi
 6952               	g_music_pipi:
 6953 0700 7800      		.word	120
 6954 0702 0C00      		.word	12
 6955 0704 2B01      		.word	299
 6956 0706 1A00      		.word	26
 6957 0708 0100      		.word	1
 6958 070a 0C00      		.word	12
 6959 070c E000      		.word	224
 6960 070e 1800      		.word	24
 6961 0710 0100      		.word	1
 6962 0712 0C00      		.word	12
 6963 0714 B200      		.word	178
 6964 0716 1800      		.word	24
 6965 0718 0100      		.word	1
 6966 071a 0C00      		.word	12
 6967 071c E000      		.word	224
 6968 071e 1800      		.word	24
 6969 0720 0100      		.word	1
 6970 0722 0600      		.word	6
 6971 0724 C700      		.word	199
 6972 0726 0C00      		.word	12
 6973 0728 0100      		.word	1
 6974 072a 1800      		.word	24
 6975 072c A800      		.word	168
 6976 072e 3000      		.word	48
 6977 0730 0100      		.word	1
 6978 0732 1800      		.word	24
 6979 0734 B200      		.word	178
 6980 0736 3000      		.word	48
 6981 0738 0100      		.word	1
 6982 073a 1800      		.word	24
 6983 073c C700      		.word	199
 6984 073e 3000      		.word	48
 6985 0740 0100      		.word	1
 6986 0742 1800      		.word	24
 6987 0744 E000      		.word	224
 6988 0746 3000      		.word	48
 6989 0748 0100      		.word	1
 6990 074a 0C00      		.word	12
 6991 074c ED00      		.word	237
 6992 074e 1800      		.word	24
 6993 0750 0100      		.word	1
 6994 0752 0C00      		.word	12
 6995 0754 C700      		.word	199
 6996 0756 1800      		.word	24
 6997 0758 0100      		.word	1
 6998 075a 0C00      		.word	12
 6999 075c 2B01      		.word	299
 7000 075e 1800      		.word	24
 7001 0760 0100      		.word	1
 7002 0762 0C00      		.word	12
 7003 0764 ED00      		.word	237
 7004 0766 1800      		.word	24
 7005 0768 0100      		.word	1
 7006 076a 0600      		.word	6
 7007 076c E000      		.word	224
 7008 076e 0C00      		.word	12
 7009 0770 0100      		.word	1
 7010 0772 0600      		.word	6
 7011 0774 B200      		.word	178
 7012 0776 0C00      		.word	12
 7013 0778 0100      		.word	1
 7014 077a 0C00      		.word	12
 7015 077c 2B01      		.word	299
 7016 077e 1800      		.word	24
 7017 0780 0100      		.word	1
 7018 0782 0C00      		.word	12
 7019 0784 E000      		.word	224
 7020 0786 1800      		.word	24
 7021 0788 0100      		.word	1
 7022 078a 0C00      		.word	12
 7023 078c B200      		.word	178
 7024 078e 1800      		.word	24
 7025 0790 0100      		.word	1
 7026 0792 0C00      		.word	12
 7027 0794 E000      		.word	224
 7028 0796 1800      		.word	24
 7029 0798 0100      		.word	1
 7030 079a 0600      		.word	6
 7031 079c C700      		.word	199
 7032 079e 0C00      		.word	12
 7033 07a0 0100      		.word	1
 7034 07a2 1800      		.word	24
 7035 07a4 A800      		.word	168
 7036 07a6 3000      		.word	48
 7037 07a8 0100      		.word	1
 7038 07aa 1800      		.word	24
 7039 07ac B200      		.word	178
 7040 07ae 3000      		.word	48
 7041 07b0 0100      		.word	1
 7042 07b2 1800      		.word	24
 7043 07b4 C700      		.word	199
 7044 07b6 3000      		.word	48
 7045 07b8 0100      		.word	1
 7046 07ba 1800      		.word	24
 7047 07bc E000      		.word	224
 7048 07be 3000      		.word	48
 7049 07c0 0100      		.word	1
 7050 07c2 0C00      		.word	12
 7051 07c4 ED00      		.word	237
 7052 07c6 1800      		.word	24
 7053 07c8 0100      		.word	1
 7054 07ca 0C00      		.word	12
 7055 07cc C700      		.word	199
 7056 07ce 1800      		.word	24
 7057 07d0 0100      		.word	1
 7058 07d2 0C00      		.word	12
 7059 07d4 2B01      		.word	299
 7060 07d6 1800      		.word	24
 7061 07d8 0100      		.word	1
 7062 07da 0C00      		.word	12
 7063 07dc ED00      		.word	237
 7064 07de 1800      		.word	24
 7065 07e0 0100      		.word	1
 7066 07e2 0300      		.word	3
 7067 07e4 E000      		.word	224
 7068 07e6 0600      		.word	6
 7069 07e8 0100      		.word	1
 7070 07ea 0C00      		.word	12
 7071 07ec B200      		.word	178
 7072 07ee 1800      		.word	24
 7073 07f0 0100      		.word	1
 7074 07f2 1800      		.word	24
 7075 07f4 B200      		.word	178
 7076 07f6 3000      		.word	48
 7077 07f8 0100      		.word	1
 7078 07fa 1800      		.word	24
 7079 07fc B200      		.word	178
 7080 07fe 3000      		.word	48
 7081 0800 0100      		.word	1
 7082 0802 0C00      		.word	12
 7083 0804 B200      		.word	178
 7084 0806 1800      		.word	24
 7085 0808 0100      		.word	1
 7086 080a 0C00      		.word	12
 7087 080c B200      		.word	178
 7088 080e 1800      		.word	24
 7089 0810 0100      		.word	1
 7090 0812 0600      		.word	6
 7091 0814 A800      		.word	168
 7092 0816 0C00      		.word	12
 7093 0818 0100      		.word	1
 7094 081a 0C00      		.word	12
 7095 081c A800      		.word	168
 7096 081e 1800      		.word	24
 7097 0820 0100      		.word	1
 7098 0822 1800      		.word	24
 7099 0824 A800      		.word	168
 7100 0826 3000      		.word	48
 7101 0828 0100      		.word	1
 7102 082a 1800      		.word	24
 7103 082c B200      		.word	178
 7104 082e 3000      		.word	48
 7105 0830 0100      		.word	1
 7106 0832 0C00      		.word	12
 7107 0834 C700      		.word	199
 7108 0836 1800      		.word	24
 7109 0838 0100      		.word	1
 7110 083a 0C00      		.word	12
 7111 083c C700      		.word	199
 7112 083e 1800      		.word	24
 7113 0840 0100      		.word	1
 7114 0842 0C00      		.word	12
 7115 0844 C700      		.word	199
 7116 0846 1800      		.word	24
 7117 0848 0100      		.word	1
 7118 084a 0C00      		.word	12
 7119 084c E000      		.word	224
 7120 084e 1800      		.word	24
 7121 0850 0100      		.word	1
 7122 0852 0C00      		.word	12
 7123 0854 ED00      		.word	237
 7124 0856 1800      		.word	24
 7125 0858 0100      		.word	1
 7126 085a 0C00      		.word	12
 7127 085c E000      		.word	224
 7128 085e 1800      		.word	24
 7129 0860 0100      		.word	1
 7130 0862 0600      		.word	6
 7131 0864 C700      		.word	199
 7132 0866 0C00      		.word	12
 7133 0868 0100      		.word	1
 7134 086a 0C00      		.word	12
 7135 086c B200      		.word	178
 7136 086e 1800      		.word	24
 7137 0870 0100      		.word	1
 7138 0872 1800      		.word	24
 7139 0874 B200      		.word	178
 7140 0876 3000      		.word	48
 7141 0878 0100      		.word	1
 7142 087a 1800      		.word	24
 7143 087c B200      		.word	178
 7144 087e 3000      		.word	48
 7145 0880 0100      		.word	1
 7146 0882 0C00      		.word	12
 7147 0884 B200      		.word	178
 7148 0886 1800      		.word	24
 7149 0888 0100      		.word	1
 7150 088a 0C00      		.word	12
 7151 088c B200      		.word	178
 7152 088e 1800      		.word	24
 7153 0890 0100      		.word	1
 7154 0892 0600      		.word	6
 7155 0894 A800      		.word	168
 7156 0896 0C00      		.word	12
 7157 0898 0100      		.word	1
 7158 089a 0C00      		.word	12
 7159 089c A800      		.word	168
 7160 089e 1800      		.word	24
 7161 08a0 0100      		.word	1
 7162 08a2 1800      		.word	24
 7163 08a4 A800      		.word	168
 7164 08a6 3000      		.word	48
 7165 08a8 0100      		.word	1
 7166 08aa 1800      		.word	24
 7167 08ac B200      		.word	178
 7168 08ae 3000      		.word	48
 7169 08b0 0100      		.word	1
 7170 08b2 0C00      		.word	12
 7171 08b4 C700      		.word	199
 7172 08b6 1800      		.word	24
 7173 08b8 0100      		.word	1
 7174 08ba 0C00      		.word	12
 7175 08bc C700      		.word	199
 7176 08be 1800      		.word	24
 7177 08c0 0100      		.word	1
 7178 08c2 0C00      		.word	12
 7179 08c4 E000      		.word	224
 7180 08c6 1800      		.word	24
 7181 08c8 0100      		.word	1
 7182 08ca 0C00      		.word	12
 7183 08cc ED00      		.word	237
 7184 08ce 1800      		.word	24
 7185 08d0 0100      		.word	1
 7186 08d2 0300      		.word	3
 7187 08d4 E000      		.word	224
 7188 08d6 0000      		.word	0
 7189               	.global	g_music_larry
 7192               	g_music_larry:
 7193 08d8 7800      		.word	120
 7194 08da 0500      		.word	5
 7195 08dc ED00      		.word	237
 7196 08de 2800      		.word	40
 7197 08e0 0100      		.word	1
 7198 08e2 0500      		.word	5
 7199 08e4 E000      		.word	224
 7200 08e6 2800      		.word	40
 7201 08e8 0100      		.word	1
 7202 08ea 0700      		.word	7
 7203 08ec D300      		.word	211
 7204 08ee 1100      		.word	17
 7205 08f0 0100      		.word	1
 7206 08f2 0700      		.word	7
 7207 08f4 C700      		.word	199
 7208 08f6 1300      		.word	19
 7209 08f8 B200      		.word	178
 7210 08fa 8000      		.word	128
 7211 08fc 0100      		.word	1
 7212 08fe 0A00      		.word	10
 7213 0900 ED00      		.word	237
 7214 0902 1300      		.word	19
 7215 0904 0100      		.word	1
 7216 0906 1100      		.word	17
 7217 0908 C700      		.word	199
 7218 090a 0600      		.word	6
 7219 090c 0100      		.word	1
 7220 090e 0500      		.word	5
 7221 0910 B200      		.word	178
 7222 0912 6D00      		.word	109
 7223 0914 0100      		.word	1
 7224 0916 1800      		.word	24
 7225 0918 ED00      		.word	237
 7226 091a 2800      		.word	40
 7227 091c 0100      		.word	1
 7228 091e 0900      		.word	9
 7229 0920 C700      		.word	199
 7230 0922 2800      		.word	40
 7231 0924 0100      		.word	1
 7232 0926 1700      		.word	23
 7233 0928 B200      		.word	178
 7234 092a 9900      		.word	153
 7235 092c 0100      		.word	1
 7236 092e 1100      		.word	17
 7237 0930 C700      		.word	199
 7238 0932 0B00      		.word	11
 7239 0934 0100      		.word	1
 7240 0936 0200      		.word	2
 7241 0938 9500      		.word	149
 7242 093a 0E00      		.word	14
 7243 093c 0100      		.word	1
 7244 093e 0900      		.word	9
 7245 0940 B200      		.word	178
 7246 0942 8000      		.word	128
 7247 0944 0100      		.word	1
 7248 0946 1000      		.word	16
 7249 0948 9500      		.word	149
 7250 094a 8000      		.word	128
 7251 094c 0100      		.word	1
 7252 094e 0900      		.word	9
 7253 0950 BC00      		.word	188
 7254 0952 2600      		.word	38
 7255 0954 0100      		.word	1
 7256 0956 0F00      		.word	15
 7257 0958 B200      		.word	178
 7258 095a 0700      		.word	7
 7259 095c 0100      		.word	1
 7260 095e 0500      		.word	5
 7261 0960 9500      		.word	149
 7262 0962 1800      		.word	24
 7263 0964 0100      		.word	1
 7264 0966 1400      		.word	20
 7265 0968 BC00      		.word	188
 7266 096a 3B00      		.word	59
 7267 096c 0100      		.word	1
 7268 096e 0900      		.word	9
 7269 0970 B200      		.word	178
 7270 0972 4000      		.word	64
 7271 0974 0100      		.word	1
 7272 0976 1300      		.word	19
 7273 0978 9500      		.word	149
 7274 097a 6D00      		.word	109
 7275 097c 0100      		.word	1
 7276 097e 0F00      		.word	15
 7277 0980 8500      		.word	133
 7278 0982 1100      		.word	17
 7279 0984 0100      		.word	1
 7280 0986 0400      		.word	4
 7281 0988 7E00      		.word	126
 7282 098a 4000      		.word	64
 7283 098c 8500      		.word	133
 7284 098e 8001      		.word	384
 7285 0990 0100      		.word	1
 7286 0992 1400      		.word	20
 7287 0994 8D00      		.word	141
 7288 0996 8001      		.word	384
 7289 0998 0100      		.word	1
 7290 099a 0700      		.word	7
 7291 099c 9500      		.word	149
 7292 099e 0C00      		.word	12
 7293 09a0 0100      		.word	1
 7294 09a2 0900      		.word	9
 7295 09a4 7700      		.word	119
 7296 09a6 0900      		.word	9
 7297 09a8 0100      		.word	1
 7298 09aa 0A00      		.word	10
 7299 09ac 7700      		.word	119
 7300 09ae 0900      		.word	9
 7301 09b0 0100      		.word	1
 7302 09b2 0800      		.word	8
 7303 09b4 7700      		.word	119
 7304 09b6 0A00      		.word	10
 7305 09b8 0100      		.word	1
 7306 09ba 0900      		.word	9
 7307 09bc 7700      		.word	119
 7308 09be 0A00      		.word	10
 7309 09c0 0100      		.word	1
 7310 09c2 0800      		.word	8
 7311 09c4 7700      		.word	119
 7312 09c6 1300      		.word	19
 7313 09c8 7E00      		.word	126
 7314 09ca 6000      		.word	96
 7315 09cc 0100      		.word	1
 7316 09ce 0800      		.word	8
 7317 09d0 8500      		.word	133
 7318 09d2 3300      		.word	51
 7319 09d4 0100      		.word	1
 7320 09d6 0300      		.word	3
 7321 09d8 8D00      		.word	141
 7322 09da 4500      		.word	69
 7323 09dc 0100      		.word	1
 7324 09de 0800      		.word	8
 7325 09e0 B200      		.word	178
 7326 09e2 0D00      		.word	13
 7327 09e4 0100      		.word	1
 7328 09e6 0800      		.word	8
 7329 09e8 7E00      		.word	126
 7330 09ea 3B00      		.word	59
 7331 09ec 0100      		.word	1
 7332 09ee 1000      		.word	16
 7333 09f0 7700      		.word	119
 7334 09f2 0800      		.word	8
 7335 09f4 7E00      		.word	126
 7336 09f6 8000      		.word	128
 7337 09f8 0100      		.word	1
 7338 09fa 1000      		.word	16
 7339 09fc 7700      		.word	119
 7340 09fe 5500      		.word	85
 7341 0a00 0100      		.word	1
 7342 0a02 0900      		.word	9
 7343 0a04 9500      		.word	149
 7344 0a06 2800      		.word	40
 7345 0a08 0100      		.word	1
 7346 0a0a 0D00      		.word	13
 7347 0a0c 8500      		.word	133
 7348 0a0e 0800      		.word	8
 7349 0a10 0100      		.word	1
 7350 0a12 0E00      		.word	14
 7351 0a14 9500      		.word	149
 7352 0a16 0400      		.word	4
 7353 0a18 0100      		.word	1
 7354 0a1a 0500      		.word	5
 7355 0a1c ED00      		.word	237
 7356 0a1e 2800      		.word	40
 7357 0a20 0100      		.word	1
 7358 0a22 0500      		.word	5
 7359 0a24 E000      		.word	224
 7360 0a26 2800      		.word	40
 7361 0a28 0100      		.word	1
 7362 0a2a 0700      		.word	7
 7363 0a2c D300      		.word	211
 7364 0a2e 1100      		.word	17
 7365 0a30 0100      		.word	1
 7366 0a32 0700      		.word	7
 7367 0a34 C700      		.word	199
 7368 0a36 1400      		.word	20
 7369 0a38 B200      		.word	178
 7370 0a3a 6D00      		.word	109
 7371 0a3c 0100      		.word	1
 7372 0a3e 0A00      		.word	10
 7373 0a40 ED00      		.word	237
 7374 0a42 1300      		.word	19
 7375 0a44 0100      		.word	1
 7376 0a46 1100      		.word	17
 7377 0a48 C700      		.word	199
 7378 0a4a 0600      		.word	6
 7379 0a4c 0100      		.word	1
 7380 0a4e 0500      		.word	5
 7381 0a50 B200      		.word	178
 7382 0a52 8000      		.word	128
 7383 0a54 0100      		.word	1
 7384 0a56 1700      		.word	23
 7385 0a58 ED00      		.word	237
 7386 0a5a 2800      		.word	40
 7387 0a5c 0100      		.word	1
 7388 0a5e 0900      		.word	9
 7389 0a60 C700      		.word	199
 7390 0a62 2600      		.word	38
 7391 0a64 0100      		.word	1
 7392 0a66 1800      		.word	24
 7393 0a68 B200      		.word	178
 7394 0a6a 8000      		.word	128
 7395 0a6c 0100      		.word	1
 7396 0a6e 1100      		.word	17
 7397 0a70 C700      		.word	199
 7398 0a72 0C00      		.word	12
 7399 0a74 0100      		.word	1
 7400 0a76 0200      		.word	2
 7401 0a78 9500      		.word	149
 7402 0a7a 0E00      		.word	14
 7403 0a7c 0100      		.word	1
 7404 0a7e 0900      		.word	9
 7405 0a80 B200      		.word	178
 7406 0a82 8000      		.word	128
 7407 0a84 0100      		.word	1
 7408 0a86 1000      		.word	16
 7409 0a88 9500      		.word	149
 7410 0a8a 9900      		.word	153
 7411 0a8c 0100      		.word	1
 7412 0a8e 0900      		.word	9
 7413 0a90 BC00      		.word	188
 7414 0a92 2800      		.word	40
 7415 0a94 0100      		.word	1
 7416 0a96 0E00      		.word	14
 7417 0a98 B200      		.word	178
 7418 0a9a 0700      		.word	7
 7419 0a9c 0100      		.word	1
 7420 0a9e 0600      		.word	6
 7421 0aa0 9500      		.word	149
 7422 0aa2 1700      		.word	23
 7423 0aa4 0100      		.word	1
 7424 0aa6 1400      		.word	20
 7425 0aa8 BC00      		.word	188
 7426 0aaa 3B00      		.word	59
 7427 0aac 0100      		.word	1
 7428 0aae 0900      		.word	9
 7429 0ab0 B200      		.word	178
 7430 0ab2 3B00      		.word	59
 7431 0ab4 0100      		.word	1
 7432 0ab6 1300      		.word	19
 7433 0ab8 9500      		.word	149
 7434 0aba 6000      		.word	96
 7435 0abc 0100      		.word	1
 7436 0abe 0F00      		.word	15
 7437 0ac0 8500      		.word	133
 7438 0ac2 1000      		.word	16
 7439 0ac4 0100      		.word	1
 7440 0ac6 0400      		.word	4
 7441 0ac8 7E00      		.word	126
 7442 0aca 4C00      		.word	76
 7443 0acc 8500      		.word	133
 7444 0ace 0001      		.word	256
 7445 0ad0 0100      		.word	1
 7446 0ad2 1400      		.word	20
 7447 0ad4 8D00      		.word	141
 7448 0ad6 0700      		.word	7
 7449 0ad8 9500      		.word	149
 7450 0ada 0C00      		.word	12
 7451 0adc 0100      		.word	1
 7452 0ade 0900      		.word	9
 7453 0ae0 7700      		.word	119
 7454 0ae2 0900      		.word	9
 7455 0ae4 0100      		.word	1
 7456 0ae6 0900      		.word	9
 7457 0ae8 7700      		.word	119
 7458 0aea 0900      		.word	9
 7459 0aec 0100      		.word	1
 7460 0aee 0800      		.word	8
 7461 0af0 7700      		.word	119
 7462 0af2 0A00      		.word	10
 7463 0af4 0100      		.word	1
 7464 0af6 0900      		.word	9
 7465 0af8 7700      		.word	119
 7466 0afa 0A00      		.word	10
 7467 0afc 0100      		.word	1
 7468 0afe 0700      		.word	7
 7469 0b00 7700      		.word	119
 7470 0b02 1300      		.word	19
 7471 0b04 7E00      		.word	126
 7472 0b06 5500      		.word	85
 7473 0b08 0100      		.word	1
 7474 0b0a 0800      		.word	8
 7475 0b0c 8500      		.word	133
 7476 0b0e 3600      		.word	54
 7477 0b10 0100      		.word	1
 7478 0b12 0300      		.word	3
 7479 0b14 8D00      		.word	141
 7480 0b16 4000      		.word	64
 7481 0b18 0100      		.word	1
 7482 0b1a 0800      		.word	8
 7483 0b1c B200      		.word	178
 7484 0b1e 0D00      		.word	13
 7485 0b20 0100      		.word	1
 7486 0b22 0700      		.word	7
 7487 0b24 7E00      		.word	126
 7488 0b26 3B00      		.word	59
 7489 0b28 0100      		.word	1
 7490 0b2a 1000      		.word	16
 7491 0b2c 7700      		.word	119
 7492 0b2e 0800      		.word	8
 7493 0b30 7E00      		.word	126
 7494 0b32 8000      		.word	128
 7495 0b34 0100      		.word	1
 7496 0b36 1000      		.word	16
 7497 0b38 7700      		.word	119
 7498 0b3a 4C00      		.word	76
 7499 0b3c 0100      		.word	1
 7500 0b3e 0900      		.word	9
 7501 0b40 9500      		.word	149
 7502 0b42 2800      		.word	40
 7503 0b44 0100      		.word	1
 7504 0b46 0D00      		.word	13
 7505 0b48 8500      		.word	133
 7506 0b4a 0800      		.word	8
 7507 0b4c 0100      		.word	1
 7508 0b4e 0E00      		.word	14
 7509 0b50 9500      		.word	149
 7510 0b52 0100      		.word	1
 7511 0b54 0100      		.word	1
 7512 0b56 0000      		.word	0
 7513               	.global	g_music_furelise
 7516               	g_music_furelise:
 7517 0b58 7800      		.word	120
 7518 0b5a 0800      		.word	8
 7519 0b5c ED00      		.word	237
 7520 0b5e 0800      		.word	8
 7521 0b60 FB00      		.word	251
 7522 0b62 0800      		.word	8
 7523 0b64 ED00      		.word	237
 7524 0b66 0800      		.word	8
 7525 0b68 FB00      		.word	251
 7526 0b6a 0800      		.word	8
 7527 0b6c ED00      		.word	237
 7528 0b6e 0800      		.word	8
 7529 0b70 3C01      		.word	316
 7530 0b72 0800      		.word	8
 7531 0b74 0A01      		.word	266
 7532 0b76 0800      		.word	8
 7533 0b78 2B01      		.word	299
 7534 0b7a 0400      		.word	4
 7535 0b7c 6301      		.word	355
 7536 0b7e 0800      		.word	8
 7537 0b80 0100      		.word	1
 7538 0b82 0800      		.word	8
 7539 0b84 5502      		.word	597
 7540 0b86 0800      		.word	8
 7541 0b88 DA01      		.word	474
 7542 0b8a 0800      		.word	8
 7543 0b8c 6301      		.word	355
 7544 0b8e 0400      		.word	4
 7545 0b90 3C01      		.word	316
 7546 0b92 0800      		.word	8
 7547 0b94 0100      		.word	1
 7548 0b96 0800      		.word	8
 7549 0b98 DA01      		.word	474
 7550 0b9a 0800      		.word	8
 7551 0b9c 7801      		.word	376
 7552 0b9e 0800      		.word	8
 7553 0ba0 3C01      		.word	316
 7554 0ba2 0400      		.word	4
 7555 0ba4 2B01      		.word	299
 7556 0ba6 0800      		.word	8
 7557 0ba8 0100      		.word	1
 7558 0baa 0800      		.word	8
 7559 0bac DA01      		.word	474
 7560 0bae 0800      		.word	8
 7561 0bb0 ED00      		.word	237
 7562 0bb2 0800      		.word	8
 7563 0bb4 FB00      		.word	251
 7564 0bb6 0800      		.word	8
 7565 0bb8 ED00      		.word	237
 7566 0bba 0800      		.word	8
 7567 0bbc FB00      		.word	251
 7568 0bbe 0800      		.word	8
 7569 0bc0 ED00      		.word	237
 7570 0bc2 0800      		.word	8
 7571 0bc4 3C01      		.word	316
 7572 0bc6 0800      		.word	8
 7573 0bc8 0A01      		.word	266
 7574 0bca 0800      		.word	8
 7575 0bcc 2B01      		.word	299
 7576 0bce 0400      		.word	4
 7577 0bd0 6301      		.word	355
 7578 0bd2 0800      		.word	8
 7579 0bd4 0100      		.word	1
 7580 0bd6 0800      		.word	8
 7581 0bd8 5502      		.word	597
 7582 0bda 0800      		.word	8
 7583 0bdc DA01      		.word	474
 7584 0bde 0800      		.word	8
 7585 0be0 6301      		.word	355
 7586 0be2 0400      		.word	4
 7587 0be4 3C01      		.word	316
 7588 0be6 0800      		.word	8
 7589 0be8 0100      		.word	1
 7590 0bea 0800      		.word	8
 7591 0bec DA01      		.word	474
 7592 0bee 0800      		.word	8
 7593 0bf0 2B01      		.word	299
 7594 0bf2 0800      		.word	8
 7595 0bf4 3C01      		.word	316
 7596 0bf6 0400      		.word	4
 7597 0bf8 6301      		.word	355
 7598 0bfa 0000      		.word	0
 7599               	.global	g_music_frogger
 7602               	g_music_frogger:
 7603 0bfc 7800      		.word	120
 7604 0bfe 0800      		.word	8
 7605 0c00 0A01      		.word	266
 7606 0c02 0800      		.word	8
 7607 0c04 ED00      		.word	237
 7608 0c06 0800      		.word	8
 7609 0c08 D300      		.word	211
 7610 0c0a 0800      		.word	8
 7611 0c0c C700      		.word	199
 7612 0c0e 0800      		.word	8
 7613 0c10 B200      		.word	178
 7614 0c12 0800      		.word	8
 7615 0c14 0100      		.word	1
 7616 0c16 0800      		.word	8
 7617 0c18 D300      		.word	211
 7618 0c1a 0800      		.word	8
 7619 0c1c 0100      		.word	1
 7620 0c1e 0800      		.word	8
 7621 0c20 0A01      		.word	266
 7622 0c22 0800      		.word	8
 7623 0c24 ED00      		.word	237
 7624 0c26 0800      		.word	8
 7625 0c28 D300      		.word	211
 7626 0c2a 0800      		.word	8
 7627 0c2c ED00      		.word	237
 7628 0c2e 0800      		.word	8
 7629 0c30 0A01      		.word	266
 7630 0c32 0800      		.word	8
 7631 0c34 0100      		.word	1
 7632 0c36 0800      		.word	8
 7633 0c38 0A01      		.word	266
 7634 0c3a 0800      		.word	8
 7635 0c3c 0100      		.word	1
 7636 0c3e 0800      		.word	8
 7637 0c40 0A01      		.word	266
 7638 0c42 0800      		.word	8
 7639 0c44 ED00      		.word	237
 7640 0c46 0800      		.word	8
 7641 0c48 D300      		.word	211
 7642 0c4a 0800      		.word	8
 7643 0c4c C700      		.word	199
 7644 0c4e 0800      		.word	8
 7645 0c50 B200      		.word	178
 7646 0c52 0800      		.word	8
 7647 0c54 0100      		.word	1
 7648 0c56 0800      		.word	8
 7649 0c58 D300      		.word	211
 7650 0c5a 0800      		.word	8
 7651 0c5c 0100      		.word	1
 7652 0c5e 0800      		.word	8
 7653 0c60 B200      		.word	178
 7654 0c62 0800      		.word	8
 7655 0c64 C700      		.word	199
 7656 0c66 0800      		.word	8
 7657 0c68 D300      		.word	211
 7658 0c6a 0800      		.word	8
 7659 0c6c ED00      		.word	237
 7660 0c6e 0800      		.word	8
 7661 0c70 0A01      		.word	266
 7662 0c72 0800      		.word	8
 7663 0c74 0100      		.word	1
 7664 0c76 0800      		.word	8
 7665 0c78 0A01      		.word	266
 7666 0c7a 0800      		.word	8
 7667 0c7c 0100      		.word	1
 7668 0c7e 0800      		.word	8
 7669 0c80 0A01      		.word	266
 7670 0c82 0800      		.word	8
 7671 0c84 ED00      		.word	237
 7672 0c86 0800      		.word	8
 7673 0c88 D300      		.word	211
 7674 0c8a 0800      		.word	8
 7675 0c8c C700      		.word	199
 7676 0c8e 0800      		.word	8
 7677 0c90 B200      		.word	178
 7678 0c92 0800      		.word	8
 7679 0c94 0100      		.word	1
 7680 0c96 0800      		.word	8
 7681 0c98 D300      		.word	211
 7682 0c9a 0800      		.word	8
 7683 0c9c 0100      		.word	1
 7684 0c9e 0800      		.word	8
 7685 0ca0 0A01      		.word	266
 7686 0ca2 0800      		.word	8
 7687 0ca4 ED00      		.word	237
 7688 0ca6 0800      		.word	8
 7689 0ca8 D300      		.word	211
 7690 0caa 0800      		.word	8
 7691 0cac ED00      		.word	237
 7692 0cae 0800      		.word	8
 7693 0cb0 0A01      		.word	266
 7694 0cb2 0800      		.word	8
 7695 0cb4 0100      		.word	1
 7696 0cb6 0800      		.word	8
 7697 0cb8 0A01      		.word	266
 7698 0cba 0800      		.word	8
 7699 0cbc 0100      		.word	1
 7700 0cbe 0800      		.word	8
 7701 0cc0 0A01      		.word	266
 7702 0cc2 0800      		.word	8
 7703 0cc4 ED00      		.word	237
 7704 0cc6 0800      		.word	8
 7705 0cc8 D300      		.word	211
 7706 0cca 0800      		.word	8
 7707 0ccc C700      		.word	199
 7708 0cce 0800      		.word	8
 7709 0cd0 B200      		.word	178
 7710 0cd2 0800      		.word	8
 7711 0cd4 0100      		.word	1
 7712 0cd6 0800      		.word	8
 7713 0cd8 D300      		.word	211
 7714 0cda 0800      		.word	8
 7715 0cdc 0100      		.word	1
 7716 0cde 0800      		.word	8
 7717 0ce0 B200      		.word	178
 7718 0ce2 0800      		.word	8
 7719 0ce4 C700      		.word	199
 7720 0ce6 0800      		.word	8
 7721 0ce8 D300      		.word	211
 7722 0cea 0800      		.word	8
 7723 0cec ED00      		.word	237
 7724 0cee 0800      		.word	8
 7725 0cf0 0A01      		.word	266
 7726 0cf2 0200      		.word	2
 7727 0cf4 0100      		.word	1
 7728 0cf6 0800      		.word	8
 7729 0cf8 D300      		.word	211
 7730 0cfa 0800      		.word	8
 7731 0cfc 0A01      		.word	266
 7732 0cfe 0800      		.word	8
 7733 0d00 6301      		.word	355
 7734 0d02 0800      		.word	8
 7735 0d04 0A01      		.word	266
 7736 0d06 0800      		.word	8
 7737 0d08 D300      		.word	211
 7738 0d0a 0800      		.word	8
 7739 0d0c 0A01      		.word	266
 7740 0d0e 0800      		.word	8
 7741 0d10 6301      		.word	355
 7742 0d12 0800      		.word	8
 7743 0d14 0A01      		.word	266
 7744 0d16 0800      		.word	8
 7745 0d18 C700      		.word	199
 7746 0d1a 0800      		.word	8
 7747 0d1c C700      		.word	199
 7748 0d1e 0800      		.word	8
 7749 0d20 D300      		.word	211
 7750 0d22 0800      		.word	8
 7751 0d24 D300      		.word	211
 7752 0d26 0800      		.word	8
 7753 0d28 ED00      		.word	237
 7754 0d2a 0200      		.word	2
 7755 0d2c 0100      		.word	1
 7756 0d2e 0800      		.word	8
 7757 0d30 C700      		.word	199
 7758 0d32 0800      		.word	8
 7759 0d34 C700      		.word	199
 7760 0d36 0800      		.word	8
 7761 0d38 D300      		.word	211
 7762 0d3a 0800      		.word	8
 7763 0d3c D300      		.word	211
 7764 0d3e 0800      		.word	8
 7765 0d40 ED00      		.word	237
 7766 0d42 0800      		.word	8
 7767 0d44 ED00      		.word	237
 7768 0d46 0800      		.word	8
 7769 0d48 9E00      		.word	158
 7770 0d4a 0800      		.word	8
 7771 0d4c 9E00      		.word	158
 7772 0d4e 0800      		.word	8
 7773 0d50 B200      		.word	178
 7774 0d52 0800      		.word	8
 7775 0d54 C700      		.word	199
 7776 0d56 0800      		.word	8
 7777 0d58 D300      		.word	211
 7778 0d5a 0800      		.word	8
 7779 0d5c ED00      		.word	237
 7780 0d5e 0800      		.word	8
 7781 0d60 0A01      		.word	266
 7782 0d62 0200      		.word	2
 7783 0d64 0100      		.word	1
 7784 0d66 0800      		.word	8
 7785 0d68 D300      		.word	211
 7786 0d6a 0800      		.word	8
 7787 0d6c 0A01      		.word	266
 7788 0d6e 0800      		.word	8
 7789 0d70 6301      		.word	355
 7790 0d72 0800      		.word	8
 7791 0d74 0A01      		.word	266
 7792 0d76 0800      		.word	8
 7793 0d78 D300      		.word	211
 7794 0d7a 0800      		.word	8
 7795 0d7c 0A01      		.word	266
 7796 0d7e 0800      		.word	8
 7797 0d80 6301      		.word	355
 7798 0d82 0800      		.word	8
 7799 0d84 0A01      		.word	266
 7800 0d86 0800      		.word	8
 7801 0d88 C700      		.word	199
 7802 0d8a 0800      		.word	8
 7803 0d8c C700      		.word	199
 7804 0d8e 0800      		.word	8
 7805 0d90 D300      		.word	211
 7806 0d92 0800      		.word	8
 7807 0d94 D300      		.word	211
 7808 0d96 0800      		.word	8
 7809 0d98 ED00      		.word	237
 7810 0d9a 0200      		.word	2
 7811 0d9c 0100      		.word	1
 7812 0d9e 0800      		.word	8
 7813 0da0 C700      		.word	199
 7814 0da2 0800      		.word	8
 7815 0da4 C700      		.word	199
 7816 0da6 0800      		.word	8
 7817 0da8 D300      		.word	211
 7818 0daa 0800      		.word	8
 7819 0dac D300      		.word	211
 7820 0dae 0800      		.word	8
 7821 0db0 ED00      		.word	237
 7822 0db2 0800      		.word	8
 7823 0db4 ED00      		.word	237
 7824 0db6 0800      		.word	8
 7825 0db8 9E00      		.word	158
 7826 0dba 0800      		.word	8
 7827 0dbc 9E00      		.word	158
 7828 0dbe 0800      		.word	8
 7829 0dc0 B200      		.word	178
 7830 0dc2 0800      		.word	8
 7831 0dc4 C700      		.word	199
 7832 0dc6 0800      		.word	8
 7833 0dc8 D300      		.word	211
 7834 0dca 0800      		.word	8
 7835 0dcc ED00      		.word	237
 7836 0dce 0800      		.word	8
 7837 0dd0 0A01      		.word	266
 7838 0dd2 0200      		.word	2
 7839 0dd4 0100      		.word	1
 7840 0dd6 0800      		.word	8
 7841 0dd8 8500      		.word	133
 7842 0dda 0800      		.word	8
 7843 0ddc 8500      		.word	133
 7844 0dde 1000      		.word	16
 7845 0de0 9E00      		.word	158
 7846 0de2 1000      		.word	16
 7847 0de4 B200      		.word	178
 7848 0de6 0800      		.word	8
 7849 0de8 0100      		.word	1
 7850 0dea 0800      		.word	8
 7851 0dec 8500      		.word	133
 7852 0dee 0800      		.word	8
 7853 0df0 8500      		.word	133
 7854 0df2 1000      		.word	16
 7855 0df4 9E00      		.word	158
 7856 0df6 1000      		.word	16
 7857 0df8 B200      		.word	178
 7858 0dfa 0800      		.word	8
 7859 0dfc 0100      		.word	1
 7860 0dfe 0800      		.word	8
 7861 0e00 D300      		.word	211
 7862 0e02 0800      		.word	8
 7863 0e04 C700      		.word	199
 7864 0e06 1000      		.word	16
 7865 0e08 BC00      		.word	188
 7866 0e0a 1000      		.word	16
 7867 0e0c B200      		.word	178
 7868 0e0e 0800      		.word	8
 7869 0e10 0100      		.word	1
 7870 0e12 0800      		.word	8
 7871 0e14 D300      		.word	211
 7872 0e16 0800      		.word	8
 7873 0e18 D300      		.word	211
 7874 0e1a 1000      		.word	16
 7875 0e1c ED00      		.word	237
 7876 0e1e 1000      		.word	16
 7877 0e20 0A01      		.word	266
 7878 0e22 0800      		.word	8
 7879 0e24 0100      		.word	1
 7880 0e26 0800      		.word	8
 7881 0e28 8500      		.word	133
 7882 0e2a 0800      		.word	8
 7883 0e2c 8500      		.word	133
 7884 0e2e 1000      		.word	16
 7885 0e30 9E00      		.word	158
 7886 0e32 1000      		.word	16
 7887 0e34 B200      		.word	178
 7888 0e36 0800      		.word	8
 7889 0e38 0100      		.word	1
 7890 0e3a 0800      		.word	8
 7891 0e3c 8500      		.word	133
 7892 0e3e 0800      		.word	8
 7893 0e40 8500      		.word	133
 7894 0e42 1000      		.word	16
 7895 0e44 9E00      		.word	158
 7896 0e46 1000      		.word	16
 7897 0e48 B200      		.word	178
 7898 0e4a 0800      		.word	8
 7899 0e4c 0100      		.word	1
 7900 0e4e 0800      		.word	8
 7901 0e50 D300      		.word	211
 7902 0e52 0800      		.word	8
 7903 0e54 C700      		.word	199
 7904 0e56 1000      		.word	16
 7905 0e58 BC00      		.word	188
 7906 0e5a 1000      		.word	16
 7907 0e5c B200      		.word	178
 7908 0e5e 0800      		.word	8
 7909 0e60 0100      		.word	1
 7910 0e62 0800      		.word	8
 7911 0e64 D300      		.word	211
 7912 0e66 0800      		.word	8
 7913 0e68 D300      		.word	211
 7914 0e6a 1000      		.word	16
 7915 0e6c ED00      		.word	237
 7916 0e6e 1000      		.word	16
 7917 0e70 0A01      		.word	266
 7918 0e72 0800      		.word	8
 7919 0e74 0100      		.word	1
 7920 0e76 0800      		.word	8
 7921 0e78 D300      		.word	211
 7922 0e7a 0800      		.word	8
 7923 0e7c 0A01      		.word	266
 7924 0e7e 0800      		.word	8
 7925 0e80 6301      		.word	355
 7926 0e82 0800      		.word	8
 7927 0e84 0A01      		.word	266
 7928 0e86 0800      		.word	8
 7929 0e88 D300      		.word	211
 7930 0e8a 0800      		.word	8
 7931 0e8c 0A01      		.word	266
 7932 0e8e 0800      		.word	8
 7933 0e90 6301      		.word	355
 7934 0e92 0800      		.word	8
 7935 0e94 0A01      		.word	266
 7936 0e96 0800      		.word	8
 7937 0e98 C700      		.word	199
 7938 0e9a 0800      		.word	8
 7939 0e9c C700      		.word	199
 7940 0e9e 0800      		.word	8
 7941 0ea0 D300      		.word	211
 7942 0ea2 0800      		.word	8
 7943 0ea4 D300      		.word	211
 7944 0ea6 0800      		.word	8
 7945 0ea8 ED00      		.word	237
 7946 0eaa 0200      		.word	2
 7947 0eac 0100      		.word	1
 7948 0eae 0800      		.word	8
 7949 0eb0 C700      		.word	199
 7950 0eb2 0800      		.word	8
 7951 0eb4 C700      		.word	199
 7952 0eb6 0800      		.word	8
 7953 0eb8 D300      		.word	211
 7954 0eba 0800      		.word	8
 7955 0ebc D300      		.word	211
 7956 0ebe 0800      		.word	8
 7957 0ec0 ED00      		.word	237
 7958 0ec2 0800      		.word	8
 7959 0ec4 ED00      		.word	237
 7960 0ec6 0800      		.word	8
 7961 0ec8 9E00      		.word	158
 7962 0eca 0800      		.word	8
 7963 0ecc 9E00      		.word	158
 7964 0ece 0800      		.word	8
 7965 0ed0 B200      		.word	178
 7966 0ed2 0800      		.word	8
 7967 0ed4 C700      		.word	199
 7968 0ed6 0800      		.word	8
 7969 0ed8 D300      		.word	211
 7970 0eda 0800      		.word	8
 7971 0edc ED00      		.word	237
 7972 0ede 0100      		.word	1
 7973 0ee0 0A01      		.word	266
 7974 0ee2 0000      		.word	0
 7975               	.global	g_music_alarm
 7978               	g_music_alarm:
 7979 0ee4 A000      		.word	160
 7980 0ee6 2000      		.word	32
 7981 0ee8 2C01      		.word	300
 7982 0eea 2000      		.word	32
 7983 0eec 2901      		.word	297
 7984 0eee 2000      		.word	32
 7985 0ef0 2601      		.word	294
 7986 0ef2 2000      		.word	32
 7987 0ef4 2301      		.word	291
 7988 0ef6 2000      		.word	32
 7989 0ef8 2001      		.word	288
 7990 0efa 2000      		.word	32
 7991 0efc 1D01      		.word	285
 7992 0efe 2000      		.word	32
 7993 0f00 1A01      		.word	282
 7994 0f02 2000      		.word	32
 7995 0f04 1701      		.word	279
 7996 0f06 2000      		.word	32
 7997 0f08 1401      		.word	276
 7998 0f0a 2000      		.word	32
 7999 0f0c 1101      		.word	273
 8000 0f0e 2000      		.word	32
 8001 0f10 0E01      		.word	270
 8002 0f12 2000      		.word	32
 8003 0f14 0B01      		.word	267
 8004 0f16 2000      		.word	32
 8005 0f18 0801      		.word	264
 8006 0f1a 2000      		.word	32
 8007 0f1c 0501      		.word	261
 8008 0f1e 2000      		.word	32
 8009 0f20 0201      		.word	258
 8010 0f22 2000      		.word	32
 8011 0f24 FF00      		.word	255
 8012 0f26 2000      		.word	32
 8013 0f28 FC00      		.word	252
 8014 0f2a 2000      		.word	32
 8015 0f2c F900      		.word	249
 8016 0f2e 2000      		.word	32
 8017 0f30 F600      		.word	246
 8018 0f32 2000      		.word	32
 8019 0f34 F300      		.word	243
 8020 0f36 2000      		.word	32
 8021 0f38 F000      		.word	240
 8022 0f3a 2000      		.word	32
 8023 0f3c ED00      		.word	237
 8024 0f3e 2000      		.word	32
 8025 0f40 EA00      		.word	234
 8026 0f42 2000      		.word	32
 8027 0f44 E700      		.word	231
 8028 0f46 2000      		.word	32
 8029 0f48 E400      		.word	228
 8030 0f4a 2000      		.word	32
 8031 0f4c E100      		.word	225
 8032 0f4e 2000      		.word	32
 8033 0f50 DE00      		.word	222
 8034 0f52 2000      		.word	32
 8035 0f54 DB00      		.word	219
 8036 0f56 2000      		.word	32
 8037 0f58 D800      		.word	216
 8038 0f5a 2000      		.word	32
 8039 0f5c D500      		.word	213
 8040 0f5e 2000      		.word	32
 8041 0f60 D200      		.word	210
 8042 0f62 2000      		.word	32
 8043 0f64 CF00      		.word	207
 8044 0f66 2000      		.word	32
 8045 0f68 CC00      		.word	204
 8046 0f6a 2000      		.word	32
 8047 0f6c C900      		.word	201
 8048 0f6e 2000      		.word	32
 8049 0f70 C600      		.word	198
 8050 0f72 2000      		.word	32
 8051 0f74 C600      		.word	198
 8052 0f76 2000      		.word	32
 8053 0f78 C900      		.word	201
 8054 0f7a 2000      		.word	32
 8055 0f7c CC00      		.word	204
 8056 0f7e 2000      		.word	32
 8057 0f80 CF00      		.word	207
 8058 0f82 2000      		.word	32
 8059 0f84 D200      		.word	210
 8060 0f86 2000      		.word	32
 8061 0f88 D500      		.word	213
 8062 0f8a 2000      		.word	32
 8063 0f8c D800      		.word	216
 8064 0f8e 2000      		.word	32
 8065 0f90 DB00      		.word	219
 8066 0f92 2000      		.word	32
 8067 0f94 DE00      		.word	222
 8068 0f96 2000      		.word	32
 8069 0f98 E100      		.word	225
 8070 0f9a 2000      		.word	32
 8071 0f9c E400      		.word	228
 8072 0f9e 2000      		.word	32
 8073 0fa0 E700      		.word	231
 8074 0fa2 2000      		.word	32
 8075 0fa4 EA00      		.word	234
 8076 0fa6 2000      		.word	32
 8077 0fa8 ED00      		.word	237
 8078 0faa 2000      		.word	32
 8079 0fac F000      		.word	240
 8080 0fae 2000      		.word	32
 8081 0fb0 F300      		.word	243
 8082 0fb2 2000      		.word	32
 8083 0fb4 F600      		.word	246
 8084 0fb6 2000      		.word	32
 8085 0fb8 F900      		.word	249
 8086 0fba 2000      		.word	32
 8087 0fbc FC00      		.word	252
 8088 0fbe 2000      		.word	32
 8089 0fc0 FF00      		.word	255
 8090 0fc2 2000      		.word	32
 8091 0fc4 0201      		.word	258
 8092 0fc6 2000      		.word	32
 8093 0fc8 0501      		.word	261
 8094 0fca 2000      		.word	32
 8095 0fcc 0801      		.word	264
 8096 0fce 2000      		.word	32
 8097 0fd0 0B01      		.word	267
 8098 0fd2 2000      		.word	32
 8099 0fd4 0E01      		.word	270
 8100 0fd6 2000      		.word	32
 8101 0fd8 1101      		.word	273
 8102 0fda 2000      		.word	32
 8103 0fdc 1401      		.word	276
 8104 0fde 2000      		.word	32
 8105 0fe0 1701      		.word	279
 8106 0fe2 2000      		.word	32
 8107 0fe4 1A01      		.word	282
 8108 0fe6 2000      		.word	32
 8109 0fe8 1D01      		.word	285
 8110 0fea 2000      		.word	32
 8111 0fec 2001      		.word	288
 8112 0fee 2000      		.word	32
 8113 0ff0 2301      		.word	291
 8114 0ff2 2000      		.word	32
 8115 0ff4 2601      		.word	294
 8116 0ff6 2000      		.word	32
 8117 0ff8 2901      		.word	297
 8118 0ffa 2000      		.word	32
 8119 0ffc 2C01      		.word	300
 8120 0ffe 2000      		.word	32
 8121 1000 2C01      		.word	300
 8122 1002 2000      		.word	32
 8123 1004 2901      		.word	297
 8124 1006 2000      		.word	32
 8125 1008 2601      		.word	294
 8126 100a 2000      		.word	32
 8127 100c 2301      		.word	291
 8128 100e 2000      		.word	32
 8129 1010 2001      		.word	288
 8130 1012 2000      		.word	32
 8131 1014 1D01      		.word	285
 8132 1016 2000      		.word	32
 8133 1018 1A01      		.word	282
 8134 101a 2000      		.word	32
 8135 101c 1701      		.word	279
 8136 101e 2000      		.word	32
 8137 1020 1401      		.word	276
 8138 1022 2000      		.word	32
 8139 1024 1101      		.word	273
 8140 1026 2000      		.word	32
 8141 1028 0E01      		.word	270
 8142 102a 2000      		.word	32
 8143 102c 0B01      		.word	267
 8144 102e 2000      		.word	32
 8145 1030 0801      		.word	264
 8146 1032 2000      		.word	32
 8147 1034 0501      		.word	261
 8148 1036 2000      		.word	32
 8149 1038 0201      		.word	258
 8150 103a 2000      		.word	32
 8151 103c FF00      		.word	255
 8152 103e 2000      		.word	32
 8153 1040 FC00      		.word	252
 8154 1042 2000      		.word	32
 8155 1044 F900      		.word	249
 8156 1046 2000      		.word	32
 8157 1048 F600      		.word	246
 8158 104a 2000      		.word	32
 8159 104c F300      		.word	243
 8160 104e 2000      		.word	32
 8161 1050 F000      		.word	240
 8162 1052 2000      		.word	32
 8163 1054 ED00      		.word	237
 8164 1056 2000      		.word	32
 8165 1058 EA00      		.word	234
 8166 105a 2000      		.word	32
 8167 105c E700      		.word	231
 8168 105e 2000      		.word	32
 8169 1060 E400      		.word	228
 8170 1062 2000      		.word	32
 8171 1064 E100      		.word	225
 8172 1066 2000      		.word	32
 8173 1068 DE00      		.word	222
 8174 106a 2000      		.word	32
 8175 106c DB00      		.word	219
 8176 106e 2000      		.word	32
 8177 1070 D800      		.word	216
 8178 1072 2000      		.word	32
 8179 1074 D500      		.word	213
 8180 1076 2000      		.word	32
 8181 1078 D200      		.word	210
 8182 107a 2000      		.word	32
 8183 107c CF00      		.word	207
 8184 107e 2000      		.word	32
 8185 1080 CC00      		.word	204
 8186 1082 2000      		.word	32
 8187 1084 C900      		.word	201
 8188 1086 2000      		.word	32
 8189 1088 C600      		.word	198
 8190 108a 2000      		.word	32
 8191 108c C600      		.word	198
 8192 108e 2000      		.word	32
 8193 1090 C900      		.word	201
 8194 1092 2000      		.word	32
 8195 1094 CC00      		.word	204
 8196 1096 2000      		.word	32
 8197 1098 CF00      		.word	207
 8198 109a 2000      		.word	32
 8199 109c D200      		.word	210
 8200 109e 2000      		.word	32
 8201 10a0 D500      		.word	213
 8202 10a2 2000      		.word	32
 8203 10a4 D800      		.word	216
 8204 10a6 2000      		.word	32
 8205 10a8 DB00      		.word	219
 8206 10aa 2000      		.word	32
 8207 10ac DE00      		.word	222
 8208 10ae 2000      		.word	32
 8209 10b0 E100      		.word	225
 8210 10b2 2000      		.word	32
 8211 10b4 E400      		.word	228
 8212 10b6 2000      		.word	32
 8213 10b8 E700      		.word	231
 8214 10ba 2000      		.word	32
 8215 10bc EA00      		.word	234
 8216 10be 2000      		.word	32
 8217 10c0 ED00      		.word	237
 8218 10c2 2000      		.word	32
 8219 10c4 F000      		.word	240
 8220 10c6 2000      		.word	32
 8221 10c8 F300      		.word	243
 8222 10ca 2000      		.word	32
 8223 10cc F600      		.word	246
 8224 10ce 2000      		.word	32
 8225 10d0 F900      		.word	249
 8226 10d2 2000      		.word	32
 8227 10d4 FC00      		.word	252
 8228 10d6 2000      		.word	32
 8229 10d8 FF00      		.word	255
 8230 10da 2000      		.word	32
 8231 10dc 0201      		.word	258
 8232 10de 2000      		.word	32
 8233 10e0 0501      		.word	261
 8234 10e2 2000      		.word	32
 8235 10e4 0801      		.word	264
 8236 10e6 2000      		.word	32
 8237 10e8 0B01      		.word	267
 8238 10ea 2000      		.word	32
 8239 10ec 0E01      		.word	270
 8240 10ee 2000      		.word	32
 8241 10f0 1101      		.word	273
 8242 10f2 2000      		.word	32
 8243 10f4 1401      		.word	276
 8244 10f6 2000      		.word	32
 8245 10f8 1701      		.word	279
 8246 10fa 2000      		.word	32
 8247 10fc 1A01      		.word	282
 8248 10fe 2000      		.word	32
 8249 1100 1D01      		.word	285
 8250 1102 2000      		.word	32
 8251 1104 2001      		.word	288
 8252 1106 2000      		.word	32
 8253 1108 2301      		.word	291
 8254 110a 2000      		.word	32
 8255 110c 2601      		.word	294
 8256 110e 2000      		.word	32
 8257 1110 2901      		.word	297
 8258 1112 2000      		.word	32
 8259 1114 2C01      		.word	300
 8260 1116 2000      		.word	32
 8261 1118 2C01      		.word	300
 8262 111a 2000      		.word	32
 8263 111c 2901      		.word	297
 8264 111e 2000      		.word	32
 8265 1120 2601      		.word	294
 8266 1122 2000      		.word	32
 8267 1124 2301      		.word	291
 8268 1126 2000      		.word	32
 8269 1128 2001      		.word	288
 8270 112a 2000      		.word	32
 8271 112c 1D01      		.word	285
 8272 112e 2000      		.word	32
 8273 1130 1A01      		.word	282
 8274 1132 2000      		.word	32
 8275 1134 1701      		.word	279
 8276 1136 2000      		.word	32
 8277 1138 1401      		.word	276
 8278 113a 2000      		.word	32
 8279 113c 1101      		.word	273
 8280 113e 2000      		.word	32
 8281 1140 0E01      		.word	270
 8282 1142 2000      		.word	32
 8283 1144 0B01      		.word	267
 8284 1146 2000      		.word	32
 8285 1148 0801      		.word	264
 8286 114a 2000      		.word	32
 8287 114c 0501      		.word	261
 8288 114e 2000      		.word	32
 8289 1150 0201      		.word	258
 8290 1152 2000      		.word	32
 8291 1154 FF00      		.word	255
 8292 1156 2000      		.word	32
 8293 1158 FC00      		.word	252
 8294 115a 2000      		.word	32
 8295 115c F900      		.word	249
 8296 115e 2000      		.word	32
 8297 1160 F600      		.word	246
 8298 1162 2000      		.word	32
 8299 1164 F300      		.word	243
 8300 1166 2000      		.word	32
 8301 1168 F000      		.word	240
 8302 116a 2000      		.word	32
 8303 116c ED00      		.word	237
 8304 116e 2000      		.word	32
 8305 1170 EA00      		.word	234
 8306 1172 2000      		.word	32
 8307 1174 E700      		.word	231
 8308 1176 2000      		.word	32
 8309 1178 E400      		.word	228
 8310 117a 2000      		.word	32
 8311 117c E100      		.word	225
 8312 117e 2000      		.word	32
 8313 1180 DE00      		.word	222
 8314 1182 2000      		.word	32
 8315 1184 DB00      		.word	219
 8316 1186 2000      		.word	32
 8317 1188 D800      		.word	216
 8318 118a 2000      		.word	32
 8319 118c D500      		.word	213
 8320 118e 2000      		.word	32
 8321 1190 D200      		.word	210
 8322 1192 2000      		.word	32
 8323 1194 CF00      		.word	207
 8324 1196 2000      		.word	32
 8325 1198 CC00      		.word	204
 8326 119a 2000      		.word	32
 8327 119c C900      		.word	201
 8328 119e 2000      		.word	32
 8329 11a0 C600      		.word	198
 8330 11a2 2000      		.word	32
 8331 11a4 C600      		.word	198
 8332 11a6 2000      		.word	32
 8333 11a8 C900      		.word	201
 8334 11aa 2000      		.word	32
 8335 11ac CC00      		.word	204
 8336 11ae 2000      		.word	32
 8337 11b0 CF00      		.word	207
 8338 11b2 2000      		.word	32
 8339 11b4 D200      		.word	210
 8340 11b6 2000      		.word	32
 8341 11b8 D500      		.word	213
 8342 11ba 2000      		.word	32
 8343 11bc D800      		.word	216
 8344 11be 2000      		.word	32
 8345 11c0 DB00      		.word	219
 8346 11c2 2000      		.word	32
 8347 11c4 DE00      		.word	222
 8348 11c6 2000      		.word	32
 8349 11c8 E100      		.word	225
 8350 11ca 2000      		.word	32
 8351 11cc E400      		.word	228
 8352 11ce 2000      		.word	32
 8353 11d0 E700      		.word	231
 8354 11d2 2000      		.word	32
 8355 11d4 EA00      		.word	234
 8356 11d6 2000      		.word	32
 8357 11d8 ED00      		.word	237
 8358 11da 2000      		.word	32
 8359 11dc F000      		.word	240
 8360 11de 2000      		.word	32
 8361 11e0 F300      		.word	243
 8362 11e2 2000      		.word	32
 8363 11e4 F600      		.word	246
 8364 11e6 2000      		.word	32
 8365 11e8 F900      		.word	249
 8366 11ea 2000      		.word	32
 8367 11ec FC00      		.word	252
 8368 11ee 2000      		.word	32
 8369 11f0 FF00      		.word	255
 8370 11f2 2000      		.word	32
 8371 11f4 0201      		.word	258
 8372 11f6 2000      		.word	32
 8373 11f8 0501      		.word	261
 8374 11fa 2000      		.word	32
 8375 11fc 0801      		.word	264
 8376 11fe 2000      		.word	32
 8377 1200 0B01      		.word	267
 8378 1202 2000      		.word	32
 8379 1204 0E01      		.word	270
 8380 1206 2000      		.word	32
 8381 1208 1101      		.word	273
 8382 120a 2000      		.word	32
 8383 120c 1401      		.word	276
 8384 120e 2000      		.word	32
 8385 1210 1701      		.word	279
 8386 1212 2000      		.word	32
 8387 1214 1A01      		.word	282
 8388 1216 2000      		.word	32
 8389 1218 1D01      		.word	285
 8390 121a 2000      		.word	32
 8391 121c 2001      		.word	288
 8392 121e 2000      		.word	32
 8393 1220 2301      		.word	291
 8394 1222 2000      		.word	32
 8395 1224 2601      		.word	294
 8396 1226 2000      		.word	32
 8397 1228 2901      		.word	297
 8398 122a 2000      		.word	32
 8399 122c 2C01      		.word	300
 8400 122e 0000      		.word	0
 8401               		.local	g_warning_debounce
 8402               		.comm	g_warning_debounce,1,1
 8403               		.local	g_alarm_debounce
 8404               		.comm	g_alarm_debounce,1,1
 8405               		.local	g_light_debounce
 8406               		.comm	g_light_debounce,1,1
 8407               		.local	g_pilot_debounce
 8408               		.comm	g_pilot_debounce,1,1
 8409               		.local	g_brake_debounce
 8410               		.comm	g_brake_debounce,1,1
 8411               		.local	g_ign_debounce
 8412               		.comm	g_ign_debounce,1,1
 8413               		.local	g_claxon_debounce
 8414               		.comm	g_claxon_debounce,1,1
 8415               		.local	g_li_debounce
 8416               		.comm	g_li_debounce,1,1
 8417               		.local	g_ri_debounce
 8418               		.comm	g_ri_debounce,1,1
 8419               		.local	g_trigger_counter
 8420               		.comm	g_trigger_counter,1,1
 8421               		.local	g_sleep_counter
 8422               		.comm	g_sleep_counter,2,1
 8423               		.local	g_indicator_sound
 8424               		.comm	g_indicator_sound,1,1
 8425               		.local	g_alarm_snapshot
 8426               		.comm	g_alarm_snapshot,6,1
 8427               		.local	g_alarm_counter
 8428               		.comm	g_alarm_counter,1,1
 8429               		.local	g_alarm_blink_counter
 8430               		.comm	g_alarm_blink_counter,1,1
 8431               		.local	g_battery_blink_counter
 8432               		.comm	g_battery_blink_counter,1,1
 8433               		.local	g_adc_avg_voltage
 8434               		.comm	g_adc_avg_voltage,6,1
 8435               		.comm	g_adc_voltage,8,1
 8436               		.local	g_adc_read_pin
 8437               		.comm	g_adc_read_pin,1,1
 8438               		.local	g_current_music
 8439               		.comm	g_current_music,2,1
 8440               		.local	g_selected_music
 8441               		.comm	g_selected_music,2,1
 8442               		.local	g_current_alarm_settle_time
 8443               		.comm	g_current_alarm_settle_time,2,1
 8444               		.local	g_current_settle_time
 8445               		.comm	g_current_settle_time,2,1
 8446               		.local	g_buffer_tail
 8447               		.comm	g_buffer_tail,1,1
 8448               		.local	g_buffer_head
 8449               		.comm	g_buffer_head,1,1
 8450               		.local	g_event_buffer
 8451               		.comm	g_event_buffer,64,1
 8452               		.comm	g_mcu_reset,1,1
 8453               		.comm	g_dyn_senses_status,2,1
 8454               		.comm	g_dyn_senses,2,1
 8455               		.comm	g_senses,2,1
 8456               		.local	g_event
 8457               		.comm	g_event,1,1
 8458               		.comm	g_state,2,1
 8459               		.local	FLAG_BACKPEDAL
 8460               		.comm	FLAG_BACKPEDAL,1,1
 8461               		.local	FLAG_READ_BACKPEDAL
 8462               		.comm	FLAG_READ_BACKPEDAL,1,1
 8463               		.local	FLAG_READ_BATT
 8464               		.comm	FLAG_READ_BATT,1,1
 8465               		.local	FLAG_DEBOUNCE_WARNING
 8466               		.comm	FLAG_DEBOUNCE_WARNING,1,1
 8467               		.local	FLAG_DEBOUNCE_LIGHT
 8468               		.comm	FLAG_DEBOUNCE_LIGHT,1,1
 8469               		.local	FLAG_DEBOUNCE_PILOT
 8470               		.comm	FLAG_DEBOUNCE_PILOT,1,1
 8471               		.local	FLAG_DEBOUNCE_BRAKE
 8472               		.comm	FLAG_DEBOUNCE_BRAKE,1,1
 8473               		.local	FLAG_DEBOUNCE_ALARM
 8474               		.comm	FLAG_DEBOUNCE_ALARM,1,1
 8475               		.local	FLAG_DEBOUNCE_IGN
 8476               		.comm	FLAG_DEBOUNCE_IGN,1,1
 8477               		.local	FLAG_DEBOUNCE_CLAXON
 8478               		.comm	FLAG_DEBOUNCE_CLAXON,1,1
 8479               		.local	FLAG_DEBOUNCE_LI
 8480               		.comm	FLAG_DEBOUNCE_LI,1,1
 8481               		.local	FLAG_DEBOUNCE_RI
 8482               		.comm	FLAG_DEBOUNCE_RI,1,1
 8483               		.local	FLAG_MUSIC
 8484               		.comm	FLAG_MUSIC,1,1
 8485               		.local	FLAG_ALARM_TRIGGER
 8486               		.comm	FLAG_ALARM_TRIGGER,1,1
 8487               		.local	FLAG_ALARM_BLINK
 8488               		.comm	FLAG_ALARM_BLINK,1,1
 8489               		.local	FLAG_ALARM_SETTLE
 8490               		.comm	FLAG_ALARM_SETTLE,1,1
 8491               		.local	FLAG_SETTLE
 8492               		.comm	FLAG_SETTLE,1,1
 8493               		.local	FLAG_BLINK_BACKPEDAL
 8494               		.comm	FLAG_BLINK_BACKPEDAL,1,1
 8495               		.local	FLAG_BLINK_WARNING
 8496               		.comm	FLAG_BLINK_WARNING,1,1
 8497               		.local	FLAG_BLINK_LI
 8498               		.comm	FLAG_BLINK_LI,1,1
 8499               		.local	FLAG_BLINK_RI
 8500               		.comm	FLAG_BLINK_RI,1,1
 8501               	.global	g_rom_settings
 8502               		.section	.eeprom,"aw",@progbits
 8505               	g_rom_settings:
 8506 0000 B004      		.word	1200
 8507 0002 2003      		.word	800
 8508 0004 2003      		.word	800
 8509 0006 01        		.byte	1
 8510 0007 2626      		.word	9766
 8511 0009 06        		.byte	6
 8512 000a 12        		.byte	18
 8513 000b 04        		.byte	4
 8514 000c 8C        		.byte	-116
 8515 000d 2602      		.word	550
 8516 000f 00        		.byte	0
 8517 0010 2901      		.word	297
 8518 0012 00        		.byte	0
 8519 0013 01        		.byte	1
 8520 0014 6164 6D69 		.string	"admin"
 8520      6E00 
 8521 001a 0000 0000 		.zero	26
 8521      0000 0000 
 8521      0000 0000 
 8521      0000 0000 
 8521      0000 0000 
 8522               	.global	g_settings
 8523               		.data
 8526               	g_settings:
 8527 0064 B004      		.word	1200
 8528 0066 2003      		.word	800
 8529 0068 2003      		.word	800
 8530 006a 01        		.byte	1
 8531 006b 2626      		.word	9766
 8532 006d 06        		.byte	6
 8533 006e 12        		.byte	18
 8534 006f 04        		.byte	4
 8535 0070 8C        		.byte	-116
 8536 0071 2602      		.word	550
 8537 0073 00        		.byte	0
 8538 0074 2901      		.word	297
 8539 0076 00        		.byte	0
 8540 0077 01        		.byte	1
 8541 0078 6164 6D69 		.string	"admin"
 8541      6E00 
 8542 007e 0000 0000 		.zero	26
 8542      0000 0000 
 8542      0000 0000 
 8542      0000 0000 
 8542      0000 0000 
 8543               		.section	.progmem.data,"a",@progbits
 8546               	g_music:
 8547 1230 0000      		.word	g_music_alarm
 8548 1232 0000      		.word	g_music_pipi
 8549 1234 0000      		.word	g_music_popcorn
 8550 1236 0000      		.word	g_music_larry
 8551 1238 0000      		.word	g_music_frogger
 8552 123a 0000      		.word	g_music_furelise
 8553               	.global	g_firmware_version
 8556               	g_firmware_version:
 8557 123c 4561 7379 		.string	"EasyRider version 1.0 March 2013"
 8557      5269 6465 
 8557      7220 7665 
 8557      7273 696F 
 8557      6E20 312E 
 8558               	.global	g_user
 8559               		.section	.rodata.str1.1,"aMS",@progbits,1
 8560               	.LC0:
 8561 0000 7573 6572 		.string	"user"
 8561      00
 8562               		.data
 8565               	g_user:
 8566 0098 0000      		.word	.LC0
 8567               	.global	g_appname
 8568               		.section	.rodata.str1.1
 8569               	.LC1:
 8570 0005 4561 7379 		.string	"EasyRider"
 8570      5269 6465 
 8570      7200 
 8571               		.data
 8574               	g_appname:
 8575 009a 0000      		.word	.LC1
 8576               	.global	g_logo
 8577               		.section	.progmem.data,"a",@progbits
 8580               	g_logo:
 8581 125d 0000      		.word	g_logo1
 8582 125f 0000      		.word	g_logo2
 8583 1261 0000      		.word	g_logo3
 8584 1263 0000      		.word	g_logo4
 8585               	.global	g_logo4
 8588               	g_logo4:
 8589 1265 3230 3133 		.string	"2013 Bas Brugman - http://www.visionnaire.nl - type help for command overview"
 8589      2042 6173 
 8589      2042 7275 
 8589      676D 616E 
 8589      202D 2068 
 8590               	.global	g_logo3
 8593               	g_logo3:
 8594 12b3 285F 293D 		.string	"(_)=='(_)"
 8594      3D27 285F 
 8594      2900 
 8595               	.global	g_logo2
 8598               	g_logo2:
 8599 12bd 2E2D 2E2D 		.string	".-.-.=\\-."
 8599      2E3D 5C2D 
 8599      2E00 
 8600               	.global	g_logo1
 8603               	g_logo1:
 8604 12c7 2020 2020 		.string	"    _"
 8604      5F00 
 8605               		.local	g_music_tempo
 8606               		.comm	g_music_tempo,1,1
 8607               		.local	g_music_duration
 8608               		.comm	g_music_duration,2,1
 8609               		.comm	uart_buf,512,1
 8610               		.comm	byte_buf,9,1
 8611               		.local	rx_buffer_tail
 8612               		.comm	rx_buffer_tail,1,1
 8613               		.local	rx_buffer_head
 8614               		.comm	rx_buffer_head,1,1
 8615               		.local	rx_buffer
 8616               		.comm	rx_buffer,256,1
 8617               		.local	tx_buffer_tail
 8618               		.comm	tx_buffer_tail,1,1
 8619               		.local	tx_buffer_head
 8620               		.comm	tx_buffer_head,1,1
 8621               		.local	tx_buffer
 8622               		.comm	tx_buffer,256,1
 8623               		.text
 8624               	.Letext0:
 8625               		.file 2 "/usr/avr/include/stdint.h"
 8626               		.file 3 "/usr/lib/gcc/avr/4.8.0/include/stddef.h"
 8627               		.file 4 "settings.h"
 8628               		.file 5 "easyrider.h"
 8629               		.file 6 "usart.h"
 8630               		.file 7 "command_handlers.h"
 8631               		.file 8 "sound/alarm.h"
 8632               		.file 9 "sound/pipi.h"
 8633               		.file 10 "sound/popcorn.h"
 8634               		.file 11 "sound/frogger.h"
 8635               		.file 12 "sound/larry.h"
 8636               		.file 13 "sound/furelise.h"
 8637               		.file 14 "/usr/avr/include/avr/eeprom.h"
 8638               		.file 15 "/usr/avr/include/string.h"
 8639               		.file 16 "command.h"
 8640               		.file 17 "/usr/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 easyrider.c
     /tmp/ccFutq6B.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccFutq6B.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccFutq6B.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccFutq6B.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccFutq6B.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccFutq6B.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccFutq6B.s:13     .text.check_battery_read:0000000000000000 check_battery_read
                            *COM*:0000000000000002 g_state
     /tmp/ccFutq6B.s:42     .text.check_ri_on:0000000000000000 check_ri_on
     /tmp/ccFutq6B.s:84     .text.check_li_on:0000000000000000 check_li_on
     /tmp/ccFutq6B.s:126    .text.check_brake_on:0000000000000000 check_brake_on
     /tmp/ccFutq6B.s:168    .text.check_warning_on:0000000000000000 check_warning_on
     /tmp/ccFutq6B.s:210    .text.check_pilot_on:0000000000000000 check_pilot_on
     /tmp/ccFutq6B.s:252    .text.check_light_on:0000000000000000 check_light_on
     /tmp/ccFutq6B.s:294    .text.check_backpedal_on:0000000000000000 check_backpedal_on
     /tmp/ccFutq6B.s:336    .text.check_claxon_on:0000000000000000 check_claxon_on
     /tmp/ccFutq6B.s:378    .text.check_ign_on:0000000000000000 check_ign_on
     /tmp/ccFutq6B.s:406    .text.check_alarm_on:0000000000000000 check_alarm_on
     /tmp/ccFutq6B.s:434    .text.check_ri_off:0000000000000000 check_ri_off
     /tmp/ccFutq6B.s:455    .text.check_li_off:0000000000000000 check_li_off
     /tmp/ccFutq6B.s:478    .text.check_claxon_off:0000000000000000 check_claxon_off
     /tmp/ccFutq6B.s:503    .text.check_pilot_off:0000000000000000 check_pilot_off
     /tmp/ccFutq6B.s:527    .text.check_brake_off:0000000000000000 check_brake_off
     /tmp/ccFutq6B.s:552    .text.check_warning_off:0000000000000000 check_warning_off
     /tmp/ccFutq6B.s:573    .text.check_light_off:0000000000000000 check_light_off
     /tmp/ccFutq6B.s:600    .text.check_ign_off:0000000000000000 check_ign_off
     /tmp/ccFutq6B.s:628    .text.check_alarm_off:0000000000000000 check_alarm_off
     /tmp/ccFutq6B.s:656    .text.reset_ports:0000000000000000 reset_ports
                            *COM*:0000000000000002 g_senses
     /tmp/ccFutq6B.s:775    .text.process_ri_off:0000000000000000 process_ri_off
     /tmp/ccFutq6B.s:8480   .bss:0000000000000073 FLAG_DEBOUNCE_RI
     /tmp/ccFutq6B.s:8416   .bss:0000000000000008 g_ri_debounce
     /tmp/ccFutq6B.s:8526   .data:0000000000000064 g_settings
     /tmp/ccFutq6B.s:837    .text.process_ri_on:0000000000000000 process_ri_on
     /tmp/ccFutq6B.s:8498   .bss:000000000000007c FLAG_BLINK_RI
     /tmp/ccFutq6B.s:928    .text.process_li_off:0000000000000000 process_li_off
     /tmp/ccFutq6B.s:8478   .bss:0000000000000072 FLAG_DEBOUNCE_LI
     /tmp/ccFutq6B.s:8414   .bss:0000000000000007 g_li_debounce
     /tmp/ccFutq6B.s:990    .text.process_li_on:0000000000000000 process_li_on
     /tmp/ccFutq6B.s:8496   .bss:000000000000007b FLAG_BLINK_LI
     /tmp/ccFutq6B.s:1081   .text.process_claxon_on:0000000000000000 process_claxon_on
     /tmp/ccFutq6B.s:8476   .bss:0000000000000071 FLAG_DEBOUNCE_CLAXON
     /tmp/ccFutq6B.s:8412   .bss:0000000000000006 g_claxon_debounce
     /tmp/ccFutq6B.s:1138   .text.process_claxon_off:0000000000000000 process_claxon_off
     /tmp/ccFutq6B.s:1188   .text.process_warning_on:0000000000000000 process_warning_on
     /tmp/ccFutq6B.s:8464   .bss:000000000000006b FLAG_DEBOUNCE_WARNING
                             .bss:0000000000000000 g_warning_debounce
     /tmp/ccFutq6B.s:8494   .bss:000000000000007a FLAG_BLINK_WARNING
     /tmp/ccFutq6B.s:1301   .text.process_warning_off:0000000000000000 process_warning_off
     /tmp/ccFutq6B.s:1367   .text.process_backpedal:0000000000000000 process_backpedal
     /tmp/ccFutq6B.s:8460   .bss:0000000000000069 FLAG_READ_BACKPEDAL
                            *COM*:0000000000000008 g_adc_voltage
     /tmp/ccFutq6B.s:8457   .bss:0000000000000068 FLAG_BACKPEDAL
     /tmp/ccFutq6B.s:8492   .bss:0000000000000079 FLAG_BLINK_BACKPEDAL
     /tmp/ccFutq6B.s:1476   .text.process_ign_on:0000000000000000 process_ign_on
     /tmp/ccFutq6B.s:8474   .bss:0000000000000070 FLAG_DEBOUNCE_IGN
     /tmp/ccFutq6B.s:8410   .bss:0000000000000005 g_ign_debounce
     /tmp/ccFutq6B.s:1516   .text.process_brake_on:0000000000000000 process_brake_on
     /tmp/ccFutq6B.s:8470   .bss:000000000000006e FLAG_DEBOUNCE_BRAKE
     /tmp/ccFutq6B.s:8408   .bss:0000000000000004 g_brake_debounce
     /tmp/ccFutq6B.s:1573   .text.process_brake_off:0000000000000000 process_brake_off
     /tmp/ccFutq6B.s:1623   .text.process_pilot_on:0000000000000000 process_pilot_on
     /tmp/ccFutq6B.s:8468   .bss:000000000000006d FLAG_DEBOUNCE_PILOT
     /tmp/ccFutq6B.s:8406   .bss:0000000000000003 g_pilot_debounce
     /tmp/ccFutq6B.s:1680   .text.process_pilot_off:0000000000000000 process_pilot_off
     /tmp/ccFutq6B.s:1730   .text.process_light_on:0000000000000000 process_light_on
     /tmp/ccFutq6B.s:8466   .bss:000000000000006c FLAG_DEBOUNCE_LIGHT
     /tmp/ccFutq6B.s:8404   .bss:0000000000000002 g_light_debounce
     /tmp/ccFutq6B.s:1787   .text.process_light_off:0000000000000000 process_light_off
     /tmp/ccFutq6B.s:1837   .text.process_alarm_on:0000000000000000 process_alarm_on
     /tmp/ccFutq6B.s:8472   .bss:000000000000006f FLAG_DEBOUNCE_ALARM
     /tmp/ccFutq6B.s:8402   .bss:0000000000000001 g_alarm_debounce
     /tmp/ccFutq6B.s:8488   .bss:0000000000000077 FLAG_ALARM_SETTLE
     /tmp/ccFutq6B.s:1879   .text.process_battery:0000000000000000 process_battery
     /tmp/ccFutq6B.s:8462   .bss:000000000000006a FLAG_READ_BATT
     /tmp/ccFutq6B.s:8430   .bss:0000000000000015 g_battery_blink_counter
     /tmp/ccFutq6B.s:1960   .text.process_alarm_off:0000000000000000 process_alarm_off
     /tmp/ccFutq6B.s:2029   .text.process_ign_off:0000000000000000 process_ign_off
     /tmp/ccFutq6B.s:8490   .bss:0000000000000078 FLAG_SETTLE
     /tmp/ccFutq6B.s:2101   .text.__vector_24:0000000000000000 __vector_24
     /tmp/ccFutq6B.s:8434   .bss:000000000000001c g_adc_read_pin
     /tmp/ccFutq6B.s:2235   .text.__vector_16:0000000000000000 __vector_16
     /tmp/ccFutq6B.s:8443   .bss:0000000000000023 g_current_settle_time
     /tmp/ccFutq6B.s:8441   .bss:0000000000000021 g_current_alarm_settle_time
     /tmp/ccFutq6B.s:8606   .bss:000000000000007e g_music_duration
     /tmp/ccFutq6B.s:2347   .text.__vector_13:0000000000000000 __vector_13
     /tmp/ccFutq6B.s:8486   .bss:0000000000000076 FLAG_ALARM_BLINK
     /tmp/ccFutq6B.s:8420   .bss:000000000000000a g_sleep_counter
     /tmp/ccFutq6B.s:8428   .bss:0000000000000014 g_alarm_blink_counter
     /tmp/ccFutq6B.s:2416   .text.__vector_32:0000000000000000 __vector_32
     /tmp/ccFutq6B.s:2463   .text.startup.main:0000000000000000 main
     /tmp/ccFutq6B.s:8445   .bss:0000000000000025 g_buffer_tail
     /tmp/ccFutq6B.s:8447   .bss:0000000000000026 g_buffer_head
     /tmp/ccFutq6B.s:8505   .eeprom:0000000000000000 g_rom_settings
                            *COM*:0000000000000002 g_dyn_senses
                            *COM*:0000000000000002 g_dyn_senses_status
     /tmp/ccFutq6B.s:8449   .bss:0000000000000027 g_event_buffer
     /tmp/ccFutq6B.s:8482   .bss:0000000000000074 FLAG_MUSIC
     /tmp/ccFutq6B.s:8437   .bss:000000000000001d g_current_music
     /tmp/ccFutq6B.s:8439   .bss:000000000000001f g_selected_music
     /tmp/ccFutq6B.s:8500   .bss:000000000000007d g_music_tempo
     /tmp/ccFutq6B.s:8451   .bss:0000000000000067 g_event
     /tmp/ccFutq6B.s:5987   .data:0000000000000000 g_trans
                            *COM*:0000000000000001 g_mcu_reset
     /tmp/ccFutq6B.s:8484   .bss:0000000000000075 FLAG_ALARM_TRIGGER
     /tmp/ccFutq6B.s:8426   .bss:0000000000000013 g_alarm_counter
     /tmp/ccFutq6B.s:8546   .progmem.data:0000000000001230 g_music
     /tmp/ccFutq6B.s:8424   .bss:000000000000000d g_alarm_snapshot
     /tmp/ccFutq6B.s:8418   .bss:0000000000000009 g_trigger_counter
     /tmp/ccFutq6B.s:6052   .progmem.data:0000000000000000 g_music_popcorn
     /tmp/ccFutq6B.s:6952   .progmem.data:0000000000000700 g_music_pipi
     /tmp/ccFutq6B.s:7192   .progmem.data:00000000000008d8 g_music_larry
     /tmp/ccFutq6B.s:7516   .progmem.data:0000000000000b58 g_music_furelise
     /tmp/ccFutq6B.s:7602   .progmem.data:0000000000000bfc g_music_frogger
     /tmp/ccFutq6B.s:7978   .progmem.data:0000000000000ee4 g_music_alarm
     /tmp/ccFutq6B.s:8422   .bss:000000000000000c g_indicator_sound
     /tmp/ccFutq6B.s:8432   .bss:0000000000000016 g_adc_avg_voltage
     /tmp/ccFutq6B.s:8556   .progmem.data:000000000000123c g_firmware_version
     /tmp/ccFutq6B.s:8565   .data:0000000000000098 g_user
     /tmp/ccFutq6B.s:8574   .data:000000000000009a g_appname
     /tmp/ccFutq6B.s:8580   .progmem.data:000000000000125d g_logo
     /tmp/ccFutq6B.s:8603   .progmem.data:00000000000012c7 g_logo1
     /tmp/ccFutq6B.s:8598   .progmem.data:00000000000012bd g_logo2
     /tmp/ccFutq6B.s:8593   .progmem.data:00000000000012b3 g_logo3
     /tmp/ccFutq6B.s:8588   .progmem.data:0000000000001265 g_logo4
                            *COM*:0000000000000200 uart_buf
                            *COM*:0000000000000009 byte_buf
     /tmp/ccFutq6B.s:8608   .bss:0000000000000080 rx_buffer_tail
     /tmp/ccFutq6B.s:8612   .bss:0000000000000081 rx_buffer_head
     /tmp/ccFutq6B.s:8614   .bss:0000000000000082 rx_buffer
     /tmp/ccFutq6B.s:8616   .bss:0000000000000182 tx_buffer_tail
     /tmp/ccFutq6B.s:8618   .bss:0000000000000183 tx_buffer_head
     /tmp/ccFutq6B.s:8620   .bss:0000000000000184 tx_buffer

UNDEFINED SYMBOLS
__eerd_word_m1284p
__eerd_byte_m1284p
__eerd_block_m1284p
strcmp
strcpy
uart_init
command_usart_output
command_usart_input
command_init
register_commands
command_process
__divmodhi4
__udivmodhi4
srand
rand
__do_copy_data
__do_clear_bss
