
easyrider.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000356  00800100  00005162  00005216  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005162  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000df5  00800456  00800456  0000556c  2**0
                  ALLOC
  3 .eeprom       00000034  00810000  00810000  0000556c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00002d18  00000000  00000000  000055a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00001264  00000000  00000000  000082b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000011  00000000  00000000  0000951c  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000002e0  00000000  00000000  0000952d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000452f  00000000  00000000  0000980d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00000c2e  00000000  00000000  0000dd3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00000fec  00000000  00000000  0000e96a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000007a8  00000000  00000000  0000f958  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000ff8  00000000  00000000  00010100  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001a0e  00000000  00000000  000110f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000009a0  00000000  00000000  00012b06  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8f 0a 	jmp	0x151e	; 0x151e <__ctors_end>
       4:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
       8:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
       c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      10:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      14:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      18:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      1c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      20:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      24:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      28:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      2c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      30:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      34:	0c 94 95 10 	jmp	0x212a	; 0x212a <__vector_13>
      38:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      3c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      40:	0c 94 38 10 	jmp	0x2070	; 0x2070 <__vector_16>
      44:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      48:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      4c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      50:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      54:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      58:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      5c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      60:	0c 94 d7 0f 	jmp	0x1fae	; 0x1fae <__vector_24>
      64:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      68:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      6c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      70:	0c 94 75 1b 	jmp	0x36ea	; 0x36ea <__vector_28>
      74:	0c 94 47 1b 	jmp	0x368e	; 0x368e <__vector_29>
      78:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      7c:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      80:	0c 94 c2 10 	jmp	0x2184	; 0x2184 <__vector_32>
      84:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>
      88:	0c 94 ad 0a 	jmp	0x155a	; 0x155a <__bad_interrupt>

0000008c <g_music_popcorn>:
      8c:	7d 00 10 00 64 00 10 00 01 00 10 00 70 00 10 00     }...d.......p...
      9c:	01 00 10 00 64 00 10 00 01 00 10 00 85 00 10 00     ....d...........
      ac:	01 00 10 00 a8 00 10 00 85 00 10 00 01 00 10 00     ................
      bc:	c7 00 04 00 01 00 10 00 64 00 10 00 01 00 10 00     ........d.......
      cc:	70 00 10 00 01 00 10 00 64 00 10 00 01 00 10 00     p.......d.......
      dc:	85 00 10 00 01 00 10 00 a8 00 10 00 85 00 10 00     ................
      ec:	01 00 10 00 c7 00 04 00 01 00 10 00 64 00 10 00     ............d...
      fc:	01 00 10 00 59 00 10 00 01 00 10 00 54 00 10 00     ....Y.......T...
     10c:	01 00 10 00 59 00 10 00 54 00 10 00 01 00 10 00     ....Y...T.......
     11c:	54 00 10 00 01 00 10 00 64 00 10 00 59 00 10 00     T.......d...Y...
     12c:	01 00 10 00 64 00 10 00 59 00 10 00 01 00 10 00     ....d...Y.......
     13c:	59 00 10 00 01 00 10 00 70 00 10 00 64 00 10 00     Y.......p...d...
     14c:	01 00 10 00 70 00 10 00 64 00 10 00 01 00 10 00     ....p...d.......
     15c:	64 00 10 00 01 00 10 00 70 00 10 00 64 00 04 00     d.......p...d...
     16c:	01 00 10 00 64 00 10 00 01 00 10 00 70 00 10 00     ....d.......p...
     17c:	01 00 10 00 64 00 10 00 01 00 10 00 85 00 10 00     ....d...........
     18c:	01 00 10 00 a8 00 10 00 85 00 10 00 01 00 10 00     ................
     19c:	c7 00 04 00 01 00 10 00 64 00 10 00 01 00 10 00     ........d.......
     1ac:	70 00 10 00 01 00 10 00 64 00 10 00 01 00 10 00     p.......d.......
     1bc:	85 00 10 00 01 00 10 00 a8 00 10 00 85 00 10 00     ................
     1cc:	01 00 10 00 c7 00 04 00 01 00 10 00 64 00 10 00     ............d...
     1dc:	01 00 10 00 59 00 10 00 01 00 10 00 54 00 10 00     ....Y.......T...
     1ec:	01 00 10 00 59 00 10 00 54 00 10 00 01 00 10 00     ....Y...T.......
     1fc:	54 00 10 00 01 00 10 00 64 00 10 00 59 00 10 00     T.......d...Y...
     20c:	01 00 10 00 64 00 10 00 59 00 10 00 01 00 10 00     ....d...Y.......
     21c:	59 00 10 00 01 00 10 00 70 00 10 00 64 00 10 00     Y.......p...d...
     22c:	01 00 10 00 70 00 10 00 64 00 10 00 01 00 10 00     ....p...d.......
     23c:	64 00 10 00 01 00 10 00 59 00 10 00 54 00 04 00     d.......Y...T...
     24c:	01 00 10 00 43 00 10 00 01 00 10 00 4b 00 10 00     ....C.......K...
     25c:	01 00 10 00 43 00 10 00 01 00 10 00 54 00 10 00     ....C.......T...
     26c:	01 00 10 00 70 00 10 00 54 00 10 00 01 00 10 00     ....p...T.......
     27c:	85 00 04 00 01 00 10 00 43 00 10 00 01 00 10 00     ........C.......
     28c:	4b 00 10 00 01 00 10 00 43 00 10 00 01 00 10 00     K.......C.......
     29c:	54 00 10 00 01 00 10 00 70 00 10 00 54 00 10 00     T.......p...T...
     2ac:	01 00 10 00 85 00 04 00 01 00 10 00 43 00 10 00     ............C...
     2bc:	01 00 10 00 3b 00 10 00 01 00 10 00 38 00 10 00     ....;.......8...
     2cc:	01 00 10 00 3b 00 10 00 38 00 10 00 01 00 10 00     ....;...8.......
     2dc:	38 00 10 00 01 00 10 00 43 00 10 00 3b 00 10 00     8.......C...;...
     2ec:	01 00 10 00 43 00 10 00 3b 00 10 00 01 00 10 00     ....C...;.......
     2fc:	3b 00 10 00 01 00 10 00 4b 00 10 00 43 00 10 00     ;.......K...C...
     30c:	01 00 10 00 4b 00 10 00 43 00 10 00 01 00 10 00     ....K...C.......
     31c:	43 00 10 00 01 00 10 00 4b 00 10 00 43 00 04 00     C.......K...C...
     32c:	01 00 10 00 43 00 10 00 01 00 10 00 4b 00 10 00     ....C.......K...
     33c:	01 00 10 00 43 00 10 00 01 00 10 00 54 00 10 00     ....C.......T...
     34c:	01 00 10 00 70 00 10 00 54 00 10 00 01 00 10 00     ....p...T.......
     35c:	85 00 04 00 01 00 10 00 43 00 10 00 01 00 10 00     ........C.......
     36c:	4b 00 10 00 01 00 10 00 43 00 10 00 01 00 10 00     K.......C.......
     37c:	54 00 10 00 01 00 10 00 70 00 10 00 54 00 10 00     T.......p...T...
     38c:	01 00 10 00 85 00 04 00 01 00 10 00 43 00 10 00     ............C...
     39c:	01 00 10 00 3b 00 10 00 01 00 10 00 38 00 10 00     ....;.......8...
     3ac:	01 00 10 00 3b 00 10 00 38 00 10 00 01 00 10 00     ....;...8.......
     3bc:	38 00 10 00 01 00 10 00 43 00 10 00 3b 00 10 00     8.......C...;...
     3cc:	01 00 10 00 43 00 10 00 3b 00 10 00 01 00 10 00     ....C...;.......
     3dc:	3b 00 10 00 01 00 10 00 4b 00 10 00 43 00 10 00     ;.......K...C...
     3ec:	01 00 10 00 4b 00 10 00 59 00 10 00 01 00 10 00     ....K...Y.......
     3fc:	59 00 10 00 4b 00 10 00 01 00 10 00 43 00 04 00     Y...K.......C...
     40c:	01 00 10 00 64 00 10 00 01 00 10 00 70 00 10 00     ....d.......p...
     41c:	01 00 10 00 64 00 10 00 01 00 10 00 85 00 10 00     ....d...........
     42c:	01 00 10 00 a8 00 10 00 85 00 10 00 01 00 10 00     ................
     43c:	c7 00 04 00 01 00 10 00 64 00 10 00 01 00 10 00     ........d.......
     44c:	70 00 10 00 01 00 10 00 64 00 10 00 01 00 10 00     p.......d.......
     45c:	85 00 10 00 01 00 10 00 a8 00 10 00 85 00 10 00     ................
     46c:	01 00 10 00 c7 00 04 00 01 00 10 00 64 00 10 00     ............d...
     47c:	01 00 10 00 59 00 10 00 01 00 10 00 54 00 10 00     ....Y.......T...
     48c:	01 00 10 00 59 00 10 00 54 00 10 00 01 00 10 00     ....Y...T.......
     49c:	54 00 10 00 01 00 10 00 64 00 10 00 59 00 10 00     T.......d...Y...
     4ac:	01 00 10 00 64 00 10 00 59 00 10 00 01 00 10 00     ....d...Y.......
     4bc:	59 00 10 00 01 00 10 00 70 00 10 00 64 00 10 00     Y.......p...d...
     4cc:	01 00 10 00 70 00 10 00 64 00 10 00 01 00 10 00     ....p...d.......
     4dc:	64 00 10 00 01 00 10 00 70 00 10 00 64 00 04 00     d.......p...d...
     4ec:	01 00 10 00 64 00 10 00 01 00 10 00 70 00 10 00     ....d.......p...
     4fc:	01 00 10 00 64 00 10 00 01 00 10 00 85 00 10 00     ....d...........
     50c:	01 00 10 00 a8 00 10 00 85 00 10 00 01 00 10 00     ................
     51c:	c7 00 04 00 01 00 10 00 64 00 10 00 01 00 10 00     ........d.......
     52c:	70 00 10 00 01 00 10 00 64 00 10 00 01 00 10 00     p.......d.......
     53c:	85 00 10 00 01 00 10 00 a8 00 10 00 85 00 10 00     ................
     54c:	01 00 10 00 c7 00 04 00 01 00 10 00 64 00 10 00     ............d...
     55c:	01 00 10 00 59 00 10 00 01 00 10 00 54 00 10 00     ....Y.......T...
     56c:	01 00 10 00 59 00 10 00 54 00 10 00 01 00 10 00     ....Y...T.......
     57c:	54 00 10 00 01 00 10 00 64 00 10 00 59 00 10 00     T.......d...Y...
     58c:	01 00 10 00 64 00 10 00 59 00 10 00 01 00 10 00     ....d...Y.......
     59c:	59 00 10 00 01 00 10 00 70 00 10 00 64 00 10 00     Y.......p...d...
     5ac:	01 00 10 00 70 00 10 00 64 00 10 00 01 00 10 00     ....p...d.......
     5bc:	64 00 10 00 01 00 10 00 59 00 10 00 54 00 04 00     d.......Y...T...
     5cc:	01 00 10 00 43 00 10 00 01 00 10 00 4b 00 10 00     ....C.......K...
     5dc:	01 00 10 00 43 00 10 00 01 00 10 00 54 00 10 00     ....C.......T...
     5ec:	01 00 10 00 70 00 10 00 54 00 10 00 01 00 10 00     ....p...T.......
     5fc:	85 00 04 00 01 00 10 00 43 00 10 00 01 00 10 00     ........C.......
     60c:	4b 00 10 00 01 00 10 00 43 00 10 00 01 00 10 00     K.......C.......
     61c:	54 00 10 00 01 00 10 00 70 00 10 00 54 00 10 00     T.......p...T...
     62c:	01 00 10 00 85 00 04 00 01 00 10 00 43 00 10 00     ............C...
     63c:	01 00 10 00 3b 00 10 00 01 00 10 00 38 00 10 00     ....;.......8...
     64c:	01 00 10 00 3b 00 10 00 38 00 10 00 01 00 10 00     ....;...8.......
     65c:	38 00 10 00 01 00 10 00 43 00 10 00 3b 00 10 00     8.......C...;...
     66c:	01 00 10 00 43 00 10 00 3b 00 10 00 01 00 10 00     ....C...;.......
     67c:	3b 00 10 00 01 00 10 00 4b 00 10 00 43 00 10 00     ;.......K...C...
     68c:	01 00 10 00 4b 00 10 00 43 00 10 00 01 00 10 00     ....K...C.......
     69c:	43 00 10 00 01 00 10 00 4b 00 10 00 43 00 04 00     C.......K...C...
     6ac:	01 00 10 00 43 00 10 00 01 00 10 00 4b 00 10 00     ....C.......K...
     6bc:	01 00 10 00 43 00 10 00 01 00 10 00 54 00 10 00     ....C.......T...
     6cc:	01 00 10 00 70 00 10 00 54 00 10 00 01 00 10 00     ....p...T.......
     6dc:	85 00 04 00 01 00 10 00 43 00 10 00 01 00 10 00     ........C.......
     6ec:	4b 00 10 00 01 00 10 00 43 00 10 00 01 00 10 00     K.......C.......
     6fc:	54 00 10 00 01 00 10 00 70 00 10 00 54 00 10 00     T.......p...T...
     70c:	01 00 10 00 85 00 04 00 01 00 10 00 43 00 10 00     ............C...
     71c:	01 00 10 00 3b 00 10 00 01 00 10 00 38 00 10 00     ....;.......8...
     72c:	01 00 10 00 3b 00 10 00 38 00 10 00 01 00 10 00     ....;...8.......
     73c:	38 00 10 00 01 00 10 00 43 00 10 00 3b 00 10 00     8.......C...;...
     74c:	01 00 10 00 43 00 10 00 3b 00 10 00 01 00 10 00     ....C...;.......
     75c:	3b 00 10 00 01 00 10 00 4b 00 10 00 43 00 10 00     ;.......K...C...
     76c:	01 00 10 00 4b 00 10 00 59 00 10 00 01 00 10 00     ....K...Y.......
     77c:	59 00 10 00 4b 00 10 00 01 00 10 00 43 00 00 00     Y...K.......C...

0000078c <g_music_pipi>:
     78c:	78 00 0c 00 2b 01 1a 00 01 00 0c 00 e0 00 18 00     x...+...........
     79c:	01 00 0c 00 b2 00 18 00 01 00 0c 00 e0 00 18 00     ................
     7ac:	01 00 06 00 c7 00 0c 00 01 00 18 00 a8 00 30 00     ..............0.
     7bc:	01 00 18 00 b2 00 30 00 01 00 18 00 c7 00 30 00     ......0.......0.
     7cc:	01 00 18 00 e0 00 30 00 01 00 0c 00 ed 00 18 00     ......0.........
     7dc:	01 00 0c 00 c7 00 18 00 01 00 0c 00 2b 01 18 00     ............+...
     7ec:	01 00 0c 00 ed 00 18 00 01 00 06 00 e0 00 0c 00     ................
     7fc:	01 00 06 00 b2 00 0c 00 01 00 0c 00 2b 01 18 00     ............+...
     80c:	01 00 0c 00 e0 00 18 00 01 00 0c 00 b2 00 18 00     ................
     81c:	01 00 0c 00 e0 00 18 00 01 00 06 00 c7 00 0c 00     ................
     82c:	01 00 18 00 a8 00 30 00 01 00 18 00 b2 00 30 00     ......0.......0.
     83c:	01 00 18 00 c7 00 30 00 01 00 18 00 e0 00 30 00     ......0.......0.
     84c:	01 00 0c 00 ed 00 18 00 01 00 0c 00 c7 00 18 00     ................
     85c:	01 00 0c 00 2b 01 18 00 01 00 0c 00 ed 00 18 00     ....+...........
     86c:	01 00 03 00 e0 00 06 00 01 00 0c 00 b2 00 18 00     ................
     87c:	01 00 18 00 b2 00 30 00 01 00 18 00 b2 00 30 00     ......0.......0.
     88c:	01 00 0c 00 b2 00 18 00 01 00 0c 00 b2 00 18 00     ................
     89c:	01 00 06 00 a8 00 0c 00 01 00 0c 00 a8 00 18 00     ................
     8ac:	01 00 18 00 a8 00 30 00 01 00 18 00 b2 00 30 00     ......0.......0.
     8bc:	01 00 0c 00 c7 00 18 00 01 00 0c 00 c7 00 18 00     ................
     8cc:	01 00 0c 00 c7 00 18 00 01 00 0c 00 e0 00 18 00     ................
     8dc:	01 00 0c 00 ed 00 18 00 01 00 0c 00 e0 00 18 00     ................
     8ec:	01 00 06 00 c7 00 0c 00 01 00 0c 00 b2 00 18 00     ................
     8fc:	01 00 18 00 b2 00 30 00 01 00 18 00 b2 00 30 00     ......0.......0.
     90c:	01 00 0c 00 b2 00 18 00 01 00 0c 00 b2 00 18 00     ................
     91c:	01 00 06 00 a8 00 0c 00 01 00 0c 00 a8 00 18 00     ................
     92c:	01 00 18 00 a8 00 30 00 01 00 18 00 b2 00 30 00     ......0.......0.
     93c:	01 00 0c 00 c7 00 18 00 01 00 0c 00 c7 00 18 00     ................
     94c:	01 00 0c 00 e0 00 18 00 01 00 0c 00 ed 00 18 00     ................
     95c:	01 00 03 00 e0 00 00 00                             ........

00000964 <g_music_larry>:
     964:	78 00 05 00 ed 00 28 00 01 00 05 00 e0 00 28 00     x.....(.......(.
     974:	01 00 07 00 d3 00 11 00 01 00 07 00 c7 00 13 00     ................
     984:	b2 00 80 00 01 00 0a 00 ed 00 13 00 01 00 11 00     ................
     994:	c7 00 06 00 01 00 05 00 b2 00 6d 00 01 00 18 00     ..........m.....
     9a4:	ed 00 28 00 01 00 09 00 c7 00 28 00 01 00 17 00     ..(.......(.....
     9b4:	b2 00 99 00 01 00 11 00 c7 00 0b 00 01 00 02 00     ................
     9c4:	95 00 0e 00 01 00 09 00 b2 00 80 00 01 00 10 00     ................
     9d4:	95 00 80 00 01 00 09 00 bc 00 26 00 01 00 0f 00     ..........&.....
     9e4:	b2 00 07 00 01 00 05 00 95 00 18 00 01 00 14 00     ................
     9f4:	bc 00 3b 00 01 00 09 00 b2 00 40 00 01 00 13 00     ..;.......@.....
     a04:	95 00 6d 00 01 00 0f 00 85 00 11 00 01 00 04 00     ..m.............
     a14:	7e 00 40 00 85 00 80 01 01 00 14 00 8d 00 80 01     ~.@.............
     a24:	01 00 07 00 95 00 0c 00 01 00 09 00 77 00 09 00     ............w...
     a34:	01 00 0a 00 77 00 09 00 01 00 08 00 77 00 0a 00     ....w.......w...
     a44:	01 00 09 00 77 00 0a 00 01 00 08 00 77 00 13 00     ....w.......w...
     a54:	7e 00 60 00 01 00 08 00 85 00 33 00 01 00 03 00     ~.`.......3.....
     a64:	8d 00 45 00 01 00 08 00 b2 00 0d 00 01 00 08 00     ..E.............
     a74:	7e 00 3b 00 01 00 10 00 77 00 08 00 7e 00 80 00     ~.;.....w...~...
     a84:	01 00 10 00 77 00 55 00 01 00 09 00 95 00 28 00     ....w.U.......(.
     a94:	01 00 0d 00 85 00 08 00 01 00 0e 00 95 00 04 00     ................
     aa4:	01 00 05 00 ed 00 28 00 01 00 05 00 e0 00 28 00     ......(.......(.
     ab4:	01 00 07 00 d3 00 11 00 01 00 07 00 c7 00 14 00     ................
     ac4:	b2 00 6d 00 01 00 0a 00 ed 00 13 00 01 00 11 00     ..m.............
     ad4:	c7 00 06 00 01 00 05 00 b2 00 80 00 01 00 17 00     ................
     ae4:	ed 00 28 00 01 00 09 00 c7 00 26 00 01 00 18 00     ..(.......&.....
     af4:	b2 00 80 00 01 00 11 00 c7 00 0c 00 01 00 02 00     ................
     b04:	95 00 0e 00 01 00 09 00 b2 00 80 00 01 00 10 00     ................
     b14:	95 00 99 00 01 00 09 00 bc 00 28 00 01 00 0e 00     ..........(.....
     b24:	b2 00 07 00 01 00 06 00 95 00 17 00 01 00 14 00     ................
     b34:	bc 00 3b 00 01 00 09 00 b2 00 3b 00 01 00 13 00     ..;.......;.....
     b44:	95 00 60 00 01 00 0f 00 85 00 10 00 01 00 04 00     ..`.............
     b54:	7e 00 4c 00 85 00 00 01 01 00 14 00 8d 00 07 00     ~.L.............
     b64:	95 00 0c 00 01 00 09 00 77 00 09 00 01 00 09 00     ........w.......
     b74:	77 00 09 00 01 00 08 00 77 00 0a 00 01 00 09 00     w.......w.......
     b84:	77 00 0a 00 01 00 07 00 77 00 13 00 7e 00 55 00     w.......w...~.U.
     b94:	01 00 08 00 85 00 36 00 01 00 03 00 8d 00 40 00     ......6.......@.
     ba4:	01 00 08 00 b2 00 0d 00 01 00 07 00 7e 00 3b 00     ............~.;.
     bb4:	01 00 10 00 77 00 08 00 7e 00 80 00 01 00 10 00     ....w...~.......
     bc4:	77 00 4c 00 01 00 09 00 95 00 28 00 01 00 0d 00     w.L.......(.....
     bd4:	85 00 08 00 01 00 0e 00 95 00 01 00 01 00 00 00     ................

00000be4 <g_music_furelise>:
     be4:	78 00 08 00 ed 00 08 00 fb 00 08 00 ed 00 08 00     x...............
     bf4:	fb 00 08 00 ed 00 08 00 3c 01 08 00 0a 01 08 00     ........<.......
     c04:	2b 01 04 00 63 01 08 00 01 00 08 00 55 02 08 00     +...c.......U...
     c14:	da 01 08 00 63 01 04 00 3c 01 08 00 01 00 08 00     ....c...<.......
     c24:	da 01 08 00 78 01 08 00 3c 01 04 00 2b 01 08 00     ....x...<...+...
     c34:	01 00 08 00 da 01 08 00 ed 00 08 00 fb 00 08 00     ................
     c44:	ed 00 08 00 fb 00 08 00 ed 00 08 00 3c 01 08 00     ............<...
     c54:	0a 01 08 00 2b 01 04 00 63 01 08 00 01 00 08 00     ....+...c.......
     c64:	55 02 08 00 da 01 08 00 63 01 04 00 3c 01 08 00     U.......c...<...
     c74:	01 00 08 00 da 01 08 00 2b 01 08 00 3c 01 04 00     ........+...<...
     c84:	63 01 00 00                                         c...

00000c88 <g_music_frogger>:
     c88:	78 00 08 00 0a 01 08 00 ed 00 08 00 d3 00 08 00     x...............
     c98:	c7 00 08 00 b2 00 08 00 01 00 08 00 d3 00 08 00     ................
     ca8:	01 00 08 00 0a 01 08 00 ed 00 08 00 d3 00 08 00     ................
     cb8:	ed 00 08 00 0a 01 08 00 01 00 08 00 0a 01 08 00     ................
     cc8:	01 00 08 00 0a 01 08 00 ed 00 08 00 d3 00 08 00     ................
     cd8:	c7 00 08 00 b2 00 08 00 01 00 08 00 d3 00 08 00     ................
     ce8:	01 00 08 00 b2 00 08 00 c7 00 08 00 d3 00 08 00     ................
     cf8:	ed 00 08 00 0a 01 08 00 01 00 08 00 0a 01 08 00     ................
     d08:	01 00 08 00 0a 01 08 00 ed 00 08 00 d3 00 08 00     ................
     d18:	c7 00 08 00 b2 00 08 00 01 00 08 00 d3 00 08 00     ................
     d28:	01 00 08 00 0a 01 08 00 ed 00 08 00 d3 00 08 00     ................
     d38:	ed 00 08 00 0a 01 08 00 01 00 08 00 0a 01 08 00     ................
     d48:	01 00 08 00 0a 01 08 00 ed 00 08 00 d3 00 08 00     ................
     d58:	c7 00 08 00 b2 00 08 00 01 00 08 00 d3 00 08 00     ................
     d68:	01 00 08 00 b2 00 08 00 c7 00 08 00 d3 00 08 00     ................
     d78:	ed 00 08 00 0a 01 02 00 01 00 08 00 d3 00 08 00     ................
     d88:	0a 01 08 00 63 01 08 00 0a 01 08 00 d3 00 08 00     ....c...........
     d98:	0a 01 08 00 63 01 08 00 0a 01 08 00 c7 00 08 00     ....c...........
     da8:	c7 00 08 00 d3 00 08 00 d3 00 08 00 ed 00 02 00     ................
     db8:	01 00 08 00 c7 00 08 00 c7 00 08 00 d3 00 08 00     ................
     dc8:	d3 00 08 00 ed 00 08 00 ed 00 08 00 9e 00 08 00     ................
     dd8:	9e 00 08 00 b2 00 08 00 c7 00 08 00 d3 00 08 00     ................
     de8:	ed 00 08 00 0a 01 02 00 01 00 08 00 d3 00 08 00     ................
     df8:	0a 01 08 00 63 01 08 00 0a 01 08 00 d3 00 08 00     ....c...........
     e08:	0a 01 08 00 63 01 08 00 0a 01 08 00 c7 00 08 00     ....c...........
     e18:	c7 00 08 00 d3 00 08 00 d3 00 08 00 ed 00 02 00     ................
     e28:	01 00 08 00 c7 00 08 00 c7 00 08 00 d3 00 08 00     ................
     e38:	d3 00 08 00 ed 00 08 00 ed 00 08 00 9e 00 08 00     ................
     e48:	9e 00 08 00 b2 00 08 00 c7 00 08 00 d3 00 08 00     ................
     e58:	ed 00 08 00 0a 01 02 00 01 00 08 00 85 00 08 00     ................
     e68:	85 00 10 00 9e 00 10 00 b2 00 08 00 01 00 08 00     ................
     e78:	85 00 08 00 85 00 10 00 9e 00 10 00 b2 00 08 00     ................
     e88:	01 00 08 00 d3 00 08 00 c7 00 10 00 bc 00 10 00     ................
     e98:	b2 00 08 00 01 00 08 00 d3 00 08 00 d3 00 10 00     ................
     ea8:	ed 00 10 00 0a 01 08 00 01 00 08 00 85 00 08 00     ................
     eb8:	85 00 10 00 9e 00 10 00 b2 00 08 00 01 00 08 00     ................
     ec8:	85 00 08 00 85 00 10 00 9e 00 10 00 b2 00 08 00     ................
     ed8:	01 00 08 00 d3 00 08 00 c7 00 10 00 bc 00 10 00     ................
     ee8:	b2 00 08 00 01 00 08 00 d3 00 08 00 d3 00 10 00     ................
     ef8:	ed 00 10 00 0a 01 08 00 01 00 08 00 d3 00 08 00     ................
     f08:	0a 01 08 00 63 01 08 00 0a 01 08 00 d3 00 08 00     ....c...........
     f18:	0a 01 08 00 63 01 08 00 0a 01 08 00 c7 00 08 00     ....c...........
     f28:	c7 00 08 00 d3 00 08 00 d3 00 08 00 ed 00 02 00     ................
     f38:	01 00 08 00 c7 00 08 00 c7 00 08 00 d3 00 08 00     ................
     f48:	d3 00 08 00 ed 00 08 00 ed 00 08 00 9e 00 08 00     ................
     f58:	9e 00 08 00 b2 00 08 00 c7 00 08 00 d3 00 08 00     ................
     f68:	ed 00 01 00 0a 01 00 00                             ........

00000f70 <g_music_alarm>:
     f70:	a0 00 20 00 2c 01 20 00 29 01 20 00 26 01 20 00     .. .,. .). .&. .
     f80:	23 01 20 00 20 01 20 00 1d 01 20 00 1a 01 20 00     #. . . ... ... .
     f90:	17 01 20 00 14 01 20 00 11 01 20 00 0e 01 20 00     .. ... ... ... .
     fa0:	0b 01 20 00 08 01 20 00 05 01 20 00 02 01 20 00     .. ... ... ... .
     fb0:	ff 00 20 00 fc 00 20 00 f9 00 20 00 f6 00 20 00     .. ... ... ... .
     fc0:	f3 00 20 00 f0 00 20 00 ed 00 20 00 ea 00 20 00     .. ... ... ... .
     fd0:	e7 00 20 00 e4 00 20 00 e1 00 20 00 de 00 20 00     .. ... ... ... .
     fe0:	db 00 20 00 d8 00 20 00 d5 00 20 00 d2 00 20 00     .. ... ... ... .
     ff0:	cf 00 20 00 cc 00 20 00 c9 00 20 00 c6 00 20 00     .. ... ... ... .
    1000:	c6 00 20 00 c9 00 20 00 cc 00 20 00 cf 00 20 00     .. ... ... ... .
    1010:	d2 00 20 00 d5 00 20 00 d8 00 20 00 db 00 20 00     .. ... ... ... .
    1020:	de 00 20 00 e1 00 20 00 e4 00 20 00 e7 00 20 00     .. ... ... ... .
    1030:	ea 00 20 00 ed 00 20 00 f0 00 20 00 f3 00 20 00     .. ... ... ... .
    1040:	f6 00 20 00 f9 00 20 00 fc 00 20 00 ff 00 20 00     .. ... ... ... .
    1050:	02 01 20 00 05 01 20 00 08 01 20 00 0b 01 20 00     .. ... ... ... .
    1060:	0e 01 20 00 11 01 20 00 14 01 20 00 17 01 20 00     .. ... ... ... .
    1070:	1a 01 20 00 1d 01 20 00 20 01 20 00 23 01 20 00     .. ... . . .#. .
    1080:	26 01 20 00 29 01 20 00 2c 01 20 00 2c 01 20 00     &. .). .,. .,. .
    1090:	29 01 20 00 26 01 20 00 23 01 20 00 20 01 20 00     ). .&. .#. . . .
    10a0:	1d 01 20 00 1a 01 20 00 17 01 20 00 14 01 20 00     .. ... ... ... .
    10b0:	11 01 20 00 0e 01 20 00 0b 01 20 00 08 01 20 00     .. ... ... ... .
    10c0:	05 01 20 00 02 01 20 00 ff 00 20 00 fc 00 20 00     .. ... ... ... .
    10d0:	f9 00 20 00 f6 00 20 00 f3 00 20 00 f0 00 20 00     .. ... ... ... .
    10e0:	ed 00 20 00 ea 00 20 00 e7 00 20 00 e4 00 20 00     .. ... ... ... .
    10f0:	e1 00 20 00 de 00 20 00 db 00 20 00 d8 00 20 00     .. ... ... ... .
    1100:	d5 00 20 00 d2 00 20 00 cf 00 20 00 cc 00 20 00     .. ... ... ... .
    1110:	c9 00 20 00 c6 00 20 00 c6 00 20 00 c9 00 20 00     .. ... ... ... .
    1120:	cc 00 20 00 cf 00 20 00 d2 00 20 00 d5 00 20 00     .. ... ... ... .
    1130:	d8 00 20 00 db 00 20 00 de 00 20 00 e1 00 20 00     .. ... ... ... .
    1140:	e4 00 20 00 e7 00 20 00 ea 00 20 00 ed 00 20 00     .. ... ... ... .
    1150:	f0 00 20 00 f3 00 20 00 f6 00 20 00 f9 00 20 00     .. ... ... ... .
    1160:	fc 00 20 00 ff 00 20 00 02 01 20 00 05 01 20 00     .. ... ... ... .
    1170:	08 01 20 00 0b 01 20 00 0e 01 20 00 11 01 20 00     .. ... ... ... .
    1180:	14 01 20 00 17 01 20 00 1a 01 20 00 1d 01 20 00     .. ... ... ... .
    1190:	20 01 20 00 23 01 20 00 26 01 20 00 29 01 20 00      . .#. .&. .). .
    11a0:	2c 01 20 00 2c 01 20 00 29 01 20 00 26 01 20 00     ,. .,. .). .&. .
    11b0:	23 01 20 00 20 01 20 00 1d 01 20 00 1a 01 20 00     #. . . ... ... .
    11c0:	17 01 20 00 14 01 20 00 11 01 20 00 0e 01 20 00     .. ... ... ... .
    11d0:	0b 01 20 00 08 01 20 00 05 01 20 00 02 01 20 00     .. ... ... ... .
    11e0:	ff 00 20 00 fc 00 20 00 f9 00 20 00 f6 00 20 00     .. ... ... ... .
    11f0:	f3 00 20 00 f0 00 20 00 ed 00 20 00 ea 00 20 00     .. ... ... ... .
    1200:	e7 00 20 00 e4 00 20 00 e1 00 20 00 de 00 20 00     .. ... ... ... .
    1210:	db 00 20 00 d8 00 20 00 d5 00 20 00 d2 00 20 00     .. ... ... ... .
    1220:	cf 00 20 00 cc 00 20 00 c9 00 20 00 c6 00 20 00     .. ... ... ... .
    1230:	c6 00 20 00 c9 00 20 00 cc 00 20 00 cf 00 20 00     .. ... ... ... .
    1240:	d2 00 20 00 d5 00 20 00 d8 00 20 00 db 00 20 00     .. ... ... ... .
    1250:	de 00 20 00 e1 00 20 00 e4 00 20 00 e7 00 20 00     .. ... ... ... .
    1260:	ea 00 20 00 ed 00 20 00 f0 00 20 00 f3 00 20 00     .. ... ... ... .
    1270:	f6 00 20 00 f9 00 20 00 fc 00 20 00 ff 00 20 00     .. ... ... ... .
    1280:	02 01 20 00 05 01 20 00 08 01 20 00 0b 01 20 00     .. ... ... ... .
    1290:	0e 01 20 00 11 01 20 00 14 01 20 00 17 01 20 00     .. ... ... ... .
    12a0:	1a 01 20 00 1d 01 20 00 20 01 20 00 23 01 20 00     .. ... . . .#. .
    12b0:	26 01 20 00 29 01 20 00 2c 01 00 00                 &. .). .,...

000012bc <g_music>:
    12bc:	70 0f 8c 07 8c 00 64 09 88 0c e4 0b                 p.....d.....

000012c8 <g_firmware_version>:
    12c8:	45 61 73 79 52 69 64 65 72 20 76 65 72 73 69 6f     EasyRider versio
    12d8:	6e 20 31 2e 30 20 4d 61 72 63 68 20 32 30 31 33     n 1.0 March 2013
    12e8:	00                                                  .

000012e9 <g_logo>:
    12e9:	53 13 49 13 3f 13 f1 12                             S.I.?...

000012f1 <g_logo4>:
    12f1:	32 30 31 33 20 42 61 73 20 42 72 75 67 6d 61 6e     2013 Bas Brugman
    1301:	20 2d 20 68 74 74 70 3a 2f 2f 77 77 77 2e 76 69      - http://www.vi
    1311:	73 69 6f 6e 6e 61 69 72 65 2e 6e 6c 20 2d 20 74     sionnaire.nl - t
    1321:	79 70 65 20 68 65 6c 70 20 66 6f 72 20 63 6f 6d     ype help for com
    1331:	6d 61 6e 64 20 6f 76 65 72 76 69 65 77 00           mand overview.

0000133f <g_logo3>:
    133f:	28 5f 29 3d 3d 27 28 5f 29 00                       (_)=='(_).

00001349 <g_logo2>:
    1349:	2e 2d 2e 2d 2e 3d 5c 2d 2e 00                       .-.-.=\-..

00001353 <g_logo1>:
    1353:	20 20 20 20 5f 00                                       _.

00001359 <CMD_NOT_FOUND>:
    1359:	43 6f 6d 6d 61 6e 64 20 6e 6f 74 20 66 6f 75 6e     Command not foun
    1369:	64 2e 00                                            d..

0000136c <show_conf_info>:
    136c:	73 68 6f 77 20 63 6f 6e 66 3a 20 73 68 6f 77 20     show conf: show 
    137c:	45 45 50 52 4f 4d 20 63 6f 6e 66 69 67 75 72 61     EEPROM configura
    138c:	74 69 6f 6e 00                                      tion.

00001391 <set_conf_info>:
    1391:	73 65 74 20 63 6f 6e 66 20 5b 76 61 72 69 61 62     set conf [variab
    13a1:	6c 65 20 61 62 62 72 2e 5d 20 5b 76 61 6c 75 65     le abbr.] [value
    13b1:	5d 3a 20 73 65 74 20 63 6f 6e 66 69 67 75 72 61     ]: set configura
    13c1:	74 69 6f 6e 20 76 61 6c 75 65 73 20 2f 20 52 45     tion values / RE
    13d1:	53 45 54 20 44 45 56 49 43 45 20 74 6f 20 75 73     SET DEVICE to us
    13e1:	65 20 6e 65 77 20 76 61 6c 75 65 73 21 00           e new values!.

000013ef <set_sense_info>:
    13ef:	73 65 74 20 64 73 65 6e 73 65 20 5b 31 36 62 69     set dsense [16bi
    13ff:	74 73 5d 20 28 65 6e 61 62 6c 65 2f 64 69 73 61     ts] (enable/disa
    140f:	62 6c 65 29 20 5b 31 36 62 69 74 73 5d 20 28 68     ble) [16bits] (h
    141f:	69 67 68 2f 6c 6f 77 29 3a 20 73 65 74 20 64 79     igh/low): set dy
    142f:	6e 61 6d 69 63 20 73 65 6e 73 65 73 00              namic senses.

0000143c <show_voltage_info>:
    143c:	73 68 6f 77 20 76 6f 6c 74 61 67 65 3a 20 73 68     show voltage: sh
    144c:	6f 77 20 63 75 72 72 65 6e 74 20 62 61 74 74 65     ow current batte
    145c:	72 79 20 61 6e 64 20 61 63 63 65 6c 65 72 6f 6d     ry and accelerom
    146c:	65 74 65 72 20 78 2f 79 2f 7a 20 61 78 69 73 20     eter x/y/z axis 
    147c:	76 6f 6c 74 61 67 65 73 00                          voltages.

00001485 <show_state_info>:
    1485:	73 68 6f 77 20 73 74 61 74 65 3a 20 73 68 6f 77     show state: show
    1495:	20 63 75 72 72 65 6e 74 20 73 74 61 74 65 2c 20      current state, 
    14a5:	73 65 6e 73 65 73 20 61 6e 64 20 65 76 65 6e 74     senses and event
    14b5:	20 71 75 65 75 65 00                                 queue.

000014bc <show_version_info>:
    14bc:	73 68 6f 77 20 76 65 72 73 69 6f 6e 3a 20 73 68     show version: sh
    14cc:	6f 77 20 66 69 72 6d 77 61 72 65 20 76 65 72 73     ow firmware vers
    14dc:	69 6f 6e 00                                         ion.

000014e0 <reset_info>:
    14e0:	72 65 73 65 74 3a 20 72 65 62 6f 6f 74 20 74 68     reset: reboot th
    14f0:	65 20 6d 69 63 72 6f 63 6f 6e 74 72 6f 6c 6c 65     e microcontrolle
    1500:	72 00                                               r.

00001502 <help_info>:
    1502:	68 65 6c 70 3a 20 73 68 6f 77 20 63 6f 6d 6d 61     help: show comma
    1512:	6e 64 20 6f 76 65 72 76 69 65 77 00                 nd overview.

0000151e <__ctors_end>:
    151e:	11 24       	eor	r1, r1
    1520:	1f be       	out	0x3f, r1	; 63
    1522:	cf ef       	ldi	r28, 0xFF	; 255
    1524:	d0 e4       	ldi	r29, 0x40	; 64
    1526:	de bf       	out	0x3e, r29	; 62
    1528:	cd bf       	out	0x3d, r28	; 61

0000152a <__do_copy_data>:
    152a:	14 e0       	ldi	r17, 0x04	; 4
    152c:	a0 e0       	ldi	r26, 0x00	; 0
    152e:	b1 e0       	ldi	r27, 0x01	; 1
    1530:	e2 e6       	ldi	r30, 0x62	; 98
    1532:	f1 e5       	ldi	r31, 0x51	; 81
    1534:	00 e0       	ldi	r16, 0x00	; 0
    1536:	0b bf       	out	0x3b, r16	; 59
    1538:	02 c0       	rjmp	.+4      	; 0x153e <__do_copy_data+0x14>
    153a:	07 90       	elpm	r0, Z+
    153c:	0d 92       	st	X+, r0
    153e:	a6 35       	cpi	r26, 0x56	; 86
    1540:	b1 07       	cpc	r27, r17
    1542:	d9 f7       	brne	.-10     	; 0x153a <__do_copy_data+0x10>

00001544 <__do_clear_bss>:
    1544:	12 e1       	ldi	r17, 0x12	; 18
    1546:	a6 e5       	ldi	r26, 0x56	; 86
    1548:	b4 e0       	ldi	r27, 0x04	; 4
    154a:	01 c0       	rjmp	.+2      	; 0x154e <.do_clear_bss_start>

0000154c <.do_clear_bss_loop>:
    154c:	1d 92       	st	X+, r1

0000154e <.do_clear_bss_start>:
    154e:	ab 34       	cpi	r26, 0x4B	; 75
    1550:	b1 07       	cpc	r27, r17
    1552:	e1 f7       	brne	.-8      	; 0x154c <.do_clear_bss_loop>
    1554:	29 d6       	rcall	.+3154   	; 0x21a8 <main>
    1556:	0c 94 af 28 	jmp	0x515e	; 0x515e <_exit>

0000155a <__bad_interrupt>:
    155a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000155e <check_battery_read>:
    check_backpedal();
  }
}

uint8_t check_battery_read() {
  return ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state);
    155e:	20 91 43 12 	lds	r18, 0x1243
    1562:	30 91 44 12 	lds	r19, 0x1244
    1566:	40 91 43 12 	lds	r20, 0x1243
    156a:	50 91 44 12 	lds	r21, 0x1244
    156e:	2f 7b       	andi	r18, 0xBF	; 191
    1570:	38 7f       	andi	r19, 0xF8	; 248
    1572:	81 e0       	ldi	r24, 0x01	; 1
    1574:	24 17       	cp	r18, r20
    1576:	35 07       	cpc	r19, r21
    1578:	09 f0       	breq	.+2      	; 0x157c <check_battery_read+0x1e>
    157a:	80 e0       	ldi	r24, 0x00	; 0
}
    157c:	08 95       	ret

0000157e <check_ri_on>:

uint8_t check_ri_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
    157e:	80 91 43 12 	lds	r24, 0x1243
    1582:	90 91 44 12 	lds	r25, 0x1244
    1586:	20 91 43 12 	lds	r18, 0x1243
    158a:	30 91 44 12 	lds	r19, 0x1244
    158e:	8b 7b       	andi	r24, 0xBB	; 187
    1590:	99 27       	eor	r25, r25
    1592:	82 17       	cp	r24, r18
    1594:	93 07       	cpc	r25, r19
    1596:	11 f0       	breq	.+4      	; 0x159c <check_ri_on+0x1e>
    1598:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}
    159a:	08 95       	ret
  return ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state);
}

uint8_t check_ri_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
        ((g_state & ~(ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
    159c:	20 91 43 12 	lds	r18, 0x1243
    15a0:	30 91 44 12 	lds	r19, 0x1244
    15a4:	40 91 43 12 	lds	r20, 0x1243
    15a8:	50 91 44 12 	lds	r21, 0x1244
    15ac:	2b 7b       	andi	r18, 0xBB	; 187
    15ae:	30 7f       	andi	r19, 0xF0	; 240
uint8_t check_battery_read() {
  return ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state);
}

uint8_t check_ri_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	24 17       	cp	r18, r20
    15b4:	35 07       	cpc	r19, r21
    15b6:	89 f3       	breq	.-30     	; 0x159a <check_ri_on+0x1c>
    15b8:	80 e0       	ldi	r24, 0x00	; 0
    15ba:	ef cf       	rjmp	.-34     	; 0x159a <check_ri_on+0x1c>

000015bc <check_li_on>:
        ((g_state & ~(ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}

uint8_t check_li_on() {
  return (((g_state & (ST_NORMAL | ST_LI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
    15bc:	80 91 43 12 	lds	r24, 0x1243
    15c0:	90 91 44 12 	lds	r25, 0x1244
    15c4:	20 91 43 12 	lds	r18, 0x1243
    15c8:	30 91 44 12 	lds	r19, 0x1244
    15cc:	8d 7b       	andi	r24, 0xBD	; 189
    15ce:	99 27       	eor	r25, r25
    15d0:	82 17       	cp	r24, r18
    15d2:	93 07       	cpc	r25, r19
    15d4:	11 f0       	breq	.+4      	; 0x15da <check_li_on+0x1e>
    15d6:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_RI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}
    15d8:	08 95       	ret
        ((g_state & ~(ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}

uint8_t check_li_on() {
  return (((g_state & (ST_NORMAL | ST_LI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
        ((g_state & ~(ST_RI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
    15da:	20 91 43 12 	lds	r18, 0x1243
    15de:	30 91 44 12 	lds	r19, 0x1244
    15e2:	40 91 43 12 	lds	r20, 0x1243
    15e6:	50 91 44 12 	lds	r21, 0x1244
    15ea:	2d 7b       	andi	r18, 0xBD	; 189
    15ec:	30 7f       	andi	r19, 0xF0	; 240
  return (((g_state & (ST_NORMAL | ST_RI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
        ((g_state & ~(ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}

uint8_t check_li_on() {
  return (((g_state & (ST_NORMAL | ST_LI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
    15ee:	81 e0       	ldi	r24, 0x01	; 1
    15f0:	24 17       	cp	r18, r20
    15f2:	35 07       	cpc	r19, r21
    15f4:	89 f3       	breq	.-30     	; 0x15d8 <check_li_on+0x1c>
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	ef cf       	rjmp	.-34     	; 0x15d8 <check_li_on+0x1c>

000015fa <check_brake_on>:
        ((g_state & ~(ST_RI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}

uint8_t check_brake_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_WARNING)) == g_state) &&
    15fa:	80 91 43 12 	lds	r24, 0x1243
    15fe:	90 91 44 12 	lds	r25, 0x1244
    1602:	20 91 43 12 	lds	r18, 0x1243
    1606:	30 91 44 12 	lds	r19, 0x1244
    160a:	8f 7a       	andi	r24, 0xAF	; 175
    160c:	98 70       	andi	r25, 0x08	; 8
    160e:	82 17       	cp	r24, r18
    1610:	93 07       	cpc	r25, r19
    1612:	11 f0       	breq	.+4      	; 0x1618 <check_brake_on+0x1e>
    1614:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_BRAKE | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}
    1616:	08 95       	ret
        ((g_state & ~(ST_RI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}

uint8_t check_brake_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_BRAKE | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
    1618:	20 91 43 12 	lds	r18, 0x1243
    161c:	30 91 44 12 	lds	r19, 0x1244
    1620:	40 91 43 12 	lds	r20, 0x1243
    1624:	50 91 44 12 	lds	r21, 0x1244
    1628:	2f 7a       	andi	r18, 0xAF	; 175
    162a:	38 7f       	andi	r19, 0xF8	; 248
  return (((g_state & (ST_NORMAL | ST_LI | ST_CLAXON | ST_BRAKE | ST_LIGHT | ST_PILOT)) == g_state) &&
        ((g_state & ~(ST_RI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_WARNING | ST_SLEEP)) == g_state));
}

uint8_t check_brake_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_WARNING)) == g_state) &&
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	24 17       	cp	r18, r20
    1630:	35 07       	cpc	r19, r21
    1632:	89 f3       	breq	.-30     	; 0x1616 <check_brake_on+0x1c>
    1634:	80 e0       	ldi	r24, 0x00	; 0
    1636:	ef cf       	rjmp	.-34     	; 0x1616 <check_brake_on+0x1c>

00001638 <check_warning_on>:
        ((g_state & ~(ST_BRAKE | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_warning_on() {
  // warning blinks override RI/LI
  return (((g_state & (ST_NORMAL | ST_WARNING | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_BRAKE )) == g_state) &&
    1638:	80 91 43 12 	lds	r24, 0x1243
    163c:	90 91 44 12 	lds	r25, 0x1244
    1640:	20 91 43 12 	lds	r18, 0x1243
    1644:	30 91 44 12 	lds	r19, 0x1244
    1648:	8f 7b       	andi	r24, 0xBF	; 191
    164a:	98 70       	andi	r25, 0x08	; 8
    164c:	82 17       	cp	r24, r18
    164e:	93 07       	cpc	r25, r19
    1650:	11 f0       	breq	.+4      	; 0x1656 <check_warning_on+0x1e>
    1652:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}
    1654:	08 95       	ret
}

uint8_t check_warning_on() {
  // warning blinks override RI/LI
  return (((g_state & (ST_NORMAL | ST_WARNING | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_BRAKE )) == g_state) &&
        ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
    1656:	20 91 43 12 	lds	r18, 0x1243
    165a:	30 91 44 12 	lds	r19, 0x1244
    165e:	40 91 43 12 	lds	r20, 0x1243
    1662:	50 91 44 12 	lds	r21, 0x1244
    1666:	2f 7b       	andi	r18, 0xBF	; 191
    1668:	38 7f       	andi	r19, 0xF8	; 248
        ((g_state & ~(ST_BRAKE | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_warning_on() {
  // warning blinks override RI/LI
  return (((g_state & (ST_NORMAL | ST_WARNING | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_BRAKE )) == g_state) &&
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	24 17       	cp	r18, r20
    166e:	35 07       	cpc	r19, r21
    1670:	89 f3       	breq	.-30     	; 0x1654 <check_warning_on+0x1c>
    1672:	80 e0       	ldi	r24, 0x00	; 0
    1674:	ef cf       	rjmp	.-34     	; 0x1654 <check_warning_on+0x1c>

00001676 <check_pilot_on>:
        ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_pilot_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_BRAKE | ST_WARNING)) == g_state) &&
    1676:	80 91 43 12 	lds	r24, 0x1243
    167a:	90 91 44 12 	lds	r25, 0x1244
    167e:	20 91 43 12 	lds	r18, 0x1243
    1682:	30 91 44 12 	lds	r19, 0x1244
    1686:	8f 73       	andi	r24, 0x3F	; 63
    1688:	98 70       	andi	r25, 0x08	; 8
    168a:	82 17       	cp	r24, r18
    168c:	93 07       	cpc	r25, r19
    168e:	11 f0       	breq	.+4      	; 0x1694 <check_pilot_on+0x1e>
    1690:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_PILOT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}
    1692:	08 95       	ret
        ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_pilot_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_BRAKE | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_PILOT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
    1694:	20 91 43 12 	lds	r18, 0x1243
    1698:	30 91 44 12 	lds	r19, 0x1244
    169c:	40 91 43 12 	lds	r20, 0x1243
    16a0:	50 91 44 12 	lds	r21, 0x1244
    16a4:	2f 73       	andi	r18, 0x3F	; 63
    16a6:	38 7f       	andi	r19, 0xF8	; 248
  return (((g_state & (ST_NORMAL | ST_WARNING | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_PILOT | ST_BRAKE )) == g_state) &&
        ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_pilot_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_BRAKE | ST_WARNING)) == g_state) &&
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	24 17       	cp	r18, r20
    16ac:	35 07       	cpc	r19, r21
    16ae:	89 f3       	breq	.-30     	; 0x1692 <check_pilot_on+0x1c>
    16b0:	80 e0       	ldi	r24, 0x00	; 0
    16b2:	ef cf       	rjmp	.-34     	; 0x1692 <check_pilot_on+0x1c>

000016b4 <check_light_on>:
        ((g_state & ~(ST_PILOT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_light_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) == g_state) &&
    16b4:	80 91 43 12 	lds	r24, 0x1243
    16b8:	90 91 44 12 	lds	r25, 0x1244
    16bc:	20 91 43 12 	lds	r18, 0x1243
    16c0:	30 91 44 12 	lds	r19, 0x1244
    16c4:	8f 79       	andi	r24, 0x9F	; 159
    16c6:	98 70       	andi	r25, 0x08	; 8
    16c8:	82 17       	cp	r24, r18
    16ca:	93 07       	cpc	r25, r19
    16cc:	11 f0       	breq	.+4      	; 0x16d2 <check_light_on+0x1e>
    16ce:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}
    16d0:	08 95       	ret
        ((g_state & ~(ST_PILOT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_light_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
    16d2:	20 91 43 12 	lds	r18, 0x1243
    16d6:	30 91 44 12 	lds	r19, 0x1244
    16da:	40 91 43 12 	lds	r20, 0x1243
    16de:	50 91 44 12 	lds	r21, 0x1244
    16e2:	2f 79       	andi	r18, 0x9F	; 159
    16e4:	38 7f       	andi	r19, 0xF8	; 248
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_LIGHT | ST_BRAKE | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_PILOT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_light_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) == g_state) &&
    16e6:	81 e0       	ldi	r24, 0x01	; 1
    16e8:	24 17       	cp	r18, r20
    16ea:	35 07       	cpc	r19, r21
    16ec:	89 f3       	breq	.-30     	; 0x16d0 <check_light_on+0x1c>
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	ef cf       	rjmp	.-34     	; 0x16d0 <check_light_on+0x1c>

000016f2 <check_backpedal_on>:
        ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_backpedal_on() {
  return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
    16f2:	80 91 43 12 	lds	r24, 0x1243
    16f6:	90 91 44 12 	lds	r25, 0x1244
    16fa:	20 91 43 12 	lds	r18, 0x1243
    16fe:	30 91 44 12 	lds	r19, 0x1244
    1702:	89 7b       	andi	r24, 0xB9	; 185
    1704:	99 27       	eor	r25, r25
    1706:	82 17       	cp	r24, r18
    1708:	93 07       	cpc	r25, r19
    170a:	11 f0       	breq	.+4      	; 0x1710 <check_backpedal_on+0x1e>
    170c:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}
    170e:	08 95       	ret
        ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_backpedal_on() {
  return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
        ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
    1710:	20 91 43 12 	lds	r18, 0x1243
    1714:	30 91 44 12 	lds	r19, 0x1244
    1718:	40 91 43 12 	lds	r20, 0x1243
    171c:	50 91 44 12 	lds	r21, 0x1244
    1720:	29 7b       	andi	r18, 0xB9	; 185
    1722:	30 7f       	andi	r19, 0xF0	; 240
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_backpedal_on() {
  return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
    1724:	81 e0       	ldi	r24, 0x01	; 1
    1726:	24 17       	cp	r18, r20
    1728:	35 07       	cpc	r19, r21
    172a:	89 f3       	breq	.-30     	; 0x170e <check_backpedal_on+0x1c>
    172c:	80 e0       	ldi	r24, 0x00	; 0
    172e:	ef cf       	rjmp	.-34     	; 0x170e <check_backpedal_on+0x1c>

00001730 <check_claxon_on>:
        ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_claxon_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_BRAKE | ST_LIGHT | ST_PILOT | ST_WARNING)) == g_state) &&
    1730:	80 91 43 12 	lds	r24, 0x1243
    1734:	90 91 44 12 	lds	r25, 0x1244
    1738:	20 91 43 12 	lds	r18, 0x1243
    173c:	30 91 44 12 	lds	r19, 0x1244
    1740:	87 7b       	andi	r24, 0xB7	; 183
    1742:	98 70       	andi	r25, 0x08	; 8
    1744:	82 17       	cp	r24, r18
    1746:	93 07       	cpc	r25, r19
    1748:	11 f0       	breq	.+4      	; 0x174e <check_claxon_on+0x1e>
    174a:	80 e0       	ldi	r24, 0x00	; 0
        ((g_state & ~(ST_CLAXON | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}
    174c:	08 95       	ret
        ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_claxon_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_BRAKE | ST_LIGHT | ST_PILOT | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_CLAXON | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
    174e:	20 91 43 12 	lds	r18, 0x1243
    1752:	30 91 44 12 	lds	r19, 0x1244
    1756:	40 91 43 12 	lds	r20, 0x1243
    175a:	50 91 44 12 	lds	r21, 0x1244
    175e:	27 7b       	andi	r18, 0xB7	; 183
    1760:	38 7f       	andi	r19, 0xF8	; 248
  return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
        ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_claxon_on() {
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_BRAKE | ST_LIGHT | ST_PILOT | ST_WARNING)) == g_state) &&
    1762:	81 e0       	ldi	r24, 0x01	; 1
    1764:	24 17       	cp	r18, r20
    1766:	35 07       	cpc	r19, r21
    1768:	89 f3       	breq	.-30     	; 0x174c <check_claxon_on+0x1c>
    176a:	80 e0       	ldi	r24, 0x00	; 0
    176c:	ef cf       	rjmp	.-34     	; 0x174c <check_claxon_on+0x1c>

0000176e <check_ign_on>:
        ((g_state & ~(ST_CLAXON | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_ign_on() {
  return ((g_state & (ST_SLEEP | ST_ALARM_SETTLE | ST_ALARM)) == g_state);
    176e:	20 91 43 12 	lds	r18, 0x1243
    1772:	30 91 44 12 	lds	r19, 0x1244
    1776:	40 91 43 12 	lds	r20, 0x1243
    177a:	50 91 44 12 	lds	r21, 0x1244
    177e:	20 74       	andi	r18, 0x40	; 64
    1780:	33 70       	andi	r19, 0x03	; 3
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	24 17       	cp	r18, r20
    1786:	35 07       	cpc	r19, r21
    1788:	09 f0       	breq	.+2      	; 0x178c <check_ign_on+0x1e>
    178a:	80 e0       	ldi	r24, 0x00	; 0
}
    178c:	08 95       	ret

0000178e <check_alarm_on>:

uint8_t check_alarm_on() {
  //BUG: change this..
  return ((g_state & ST_SLEEP) == g_state);
    178e:	20 91 43 12 	lds	r18, 0x1243
    1792:	30 91 44 12 	lds	r19, 0x1244
    1796:	40 91 43 12 	lds	r20, 0x1243
    179a:	50 91 44 12 	lds	r21, 0x1244
    179e:	22 27       	eor	r18, r18
    17a0:	32 70       	andi	r19, 0x02	; 2
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	24 17       	cp	r18, r20
    17a6:	35 07       	cpc	r19, r21
    17a8:	09 f0       	breq	.+2      	; 0x17ac <check_alarm_on+0x1e>
    17aa:	80 e0       	ldi	r24, 0x00	; 0
}
    17ac:	08 95       	ret

000017ae <check_ri_off>:

uint8_t check_ri_off() {
 return ((ST_RI & g_state) == ST_RI);
    17ae:	80 91 43 12 	lds	r24, 0x1243
    17b2:	90 91 44 12 	lds	r25, 0x1244
    17b6:	96 95       	lsr	r25
    17b8:	87 95       	ror	r24
}
    17ba:	81 70       	andi	r24, 0x01	; 1
    17bc:	08 95       	ret

000017be <check_li_off>:

uint8_t check_li_off() {
 return ((ST_LI & g_state) == ST_LI);
    17be:	80 91 43 12 	lds	r24, 0x1243
    17c2:	90 91 44 12 	lds	r25, 0x1244
    17c6:	96 95       	lsr	r25
    17c8:	87 95       	ror	r24
    17ca:	96 95       	lsr	r25
    17cc:	87 95       	ror	r24
}
    17ce:	81 70       	andi	r24, 0x01	; 1
    17d0:	08 95       	ret

000017d2 <check_claxon_off>:

uint8_t check_claxon_off() {
 return ((ST_CLAXON & g_state) == ST_CLAXON);
    17d2:	80 91 43 12 	lds	r24, 0x1243
    17d6:	90 91 44 12 	lds	r25, 0x1244
    17da:	96 95       	lsr	r25
    17dc:	87 95       	ror	r24
    17de:	96 95       	lsr	r25
    17e0:	87 95       	ror	r24
    17e2:	96 95       	lsr	r25
    17e4:	87 95       	ror	r24
}
    17e6:	81 70       	andi	r24, 0x01	; 1
    17e8:	08 95       	ret

000017ea <check_pilot_off>:

uint8_t check_pilot_off() {
 return ((ST_PILOT & g_state) == ST_PILOT);
    17ea:	80 91 43 12 	lds	r24, 0x1243
    17ee:	90 91 44 12 	lds	r25, 0x1244
    17f2:	88 0f       	add	r24, r24
    17f4:	89 2f       	mov	r24, r25
    17f6:	88 1f       	adc	r24, r24
    17f8:	99 0b       	sbc	r25, r25
    17fa:	91 95       	neg	r25
}
    17fc:	81 70       	andi	r24, 0x01	; 1
    17fe:	08 95       	ret

00001800 <check_brake_off>:

uint8_t check_brake_off() {
 return ((ST_BRAKE & g_state) == ST_BRAKE);
    1800:	80 91 43 12 	lds	r24, 0x1243
    1804:	90 91 44 12 	lds	r25, 0x1244
    1808:	92 95       	swap	r25
    180a:	82 95       	swap	r24
    180c:	8f 70       	andi	r24, 0x0F	; 15
    180e:	89 27       	eor	r24, r25
    1810:	9f 70       	andi	r25, 0x0F	; 15
    1812:	89 27       	eor	r24, r25
}
    1814:	81 70       	andi	r24, 0x01	; 1
    1816:	08 95       	ret

00001818 <check_warning_off>:

uint8_t check_warning_off() {
 return ((ST_WARNING & g_state) == ST_WARNING);
    1818:	80 91 43 12 	lds	r24, 0x1243
    181c:	90 91 44 12 	lds	r25, 0x1244
}
    1820:	93 fb       	bst	r25, 3
    1822:	88 27       	eor	r24, r24
    1824:	80 f9       	bld	r24, 0
    1826:	08 95       	ret

00001828 <check_light_off>:

uint8_t check_light_off() {
 return ((ST_LIGHT & g_state) == ST_LIGHT);
    1828:	80 91 43 12 	lds	r24, 0x1243
    182c:	90 91 44 12 	lds	r25, 0x1244
    1830:	96 95       	lsr	r25
    1832:	87 95       	ror	r24
    1834:	92 95       	swap	r25
    1836:	82 95       	swap	r24
    1838:	8f 70       	andi	r24, 0x0F	; 15
    183a:	89 27       	eor	r24, r25
    183c:	9f 70       	andi	r25, 0x0F	; 15
    183e:	89 27       	eor	r24, r25
}
    1840:	81 70       	andi	r24, 0x01	; 1
    1842:	08 95       	ret

00001844 <check_ign_off>:

uint8_t check_ign_off() {
  return ((g_state & ~(ST_SLEEP | ST_ALARM | ST_ALARM_SETTLE)) == g_state);
    1844:	20 91 43 12 	lds	r18, 0x1243
    1848:	30 91 44 12 	lds	r19, 0x1244
    184c:	40 91 43 12 	lds	r20, 0x1243
    1850:	50 91 44 12 	lds	r21, 0x1244
    1854:	2f 7b       	andi	r18, 0xBF	; 191
    1856:	3c 7f       	andi	r19, 0xFC	; 252
    1858:	81 e0       	ldi	r24, 0x01	; 1
    185a:	24 17       	cp	r18, r20
    185c:	35 07       	cpc	r19, r21
    185e:	09 f0       	breq	.+2      	; 0x1862 <check_ign_off+0x1e>
    1860:	80 e0       	ldi	r24, 0x00	; 0
}
    1862:	08 95       	ret

00001864 <check_alarm_off>:

uint8_t check_alarm_off() {
  // alarm can't be switched off in alarm state, only explicitly in alarm_settle mode
  // or automatically when ignition is switched on
  return ((g_state & (ST_ALARM_SETTLE)) == g_state);
    1864:	20 91 43 12 	lds	r18, 0x1243
    1868:	30 91 44 12 	lds	r19, 0x1244
    186c:	40 91 43 12 	lds	r20, 0x1243
    1870:	50 91 44 12 	lds	r21, 0x1244
    1874:	22 27       	eor	r18, r18
    1876:	31 70       	andi	r19, 0x01	; 1
    1878:	81 e0       	ldi	r24, 0x01	; 1
    187a:	24 17       	cp	r18, r20
    187c:	35 07       	cpc	r19, r21
    187e:	09 f0       	breq	.+2      	; 0x1882 <check_alarm_off+0x1e>
    1880:	80 e0       	ldi	r24, 0x00	; 0
}
    1882:	08 95       	ret

00001884 <reset_ports>:
  PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
}

void reset_ports() {
  // sense pins: as input, set high and activate internal pullups
  DDR_C90_SENSE_LIGHT_RI &= ~(1 << PIN_C90_SENSE_LIGHT_RI);
    1884:	0c 98       	cbi	0x01, 4	; 1
  PORT_C90_SENSE_LIGHT_RI |= (1 << PIN_C90_SENSE_LIGHT_RI);
    1886:	04 9a       	sbi	0x00, 4	; 0
  DDR_C90_SENSE_LIGHT_LI &= ~(1 << PIN_C90_SENSE_LIGHT_LI);
    1888:	0d 98       	cbi	0x01, 5	; 1
  PORT_C90_SENSE_LIGHT_LI |= (1 << PIN_C90_SENSE_LIGHT_LI);
    188a:	05 9a       	sbi	0x00, 5	; 0
  DDR_C90_SENSE_CLAXON &= ~(1 << PIN_C90_SENSE_CLAXON);
    188c:	23 98       	cbi	0x04, 3	; 4
  PORT_C90_SENSE_CLAXON |= (1 << PIN_C90_SENSE_CLAXON);
    188e:	1b 9a       	sbi	0x03, 3	; 3
  DDR_C90_SENSE_BRAKE &= ~(1 << PIN_C90_SENSE_BRAKE);
    1890:	20 98       	cbi	0x04, 0	; 4
  PORT_C90_SENSE_BRAKE |= (1 << PIN_C90_SENSE_BRAKE);
    1892:	18 9a       	sbi	0x03, 0	; 3
  DDR_C90_SENSE_PILOT &= ~(1 << PIN_C90_SENSE_PILOT);
    1894:	0e 98       	cbi	0x01, 6	; 1
  PORT_C90_SENSE_PILOT |= (1 << PIN_C90_SENSE_PILOT);
    1896:	06 9a       	sbi	0x00, 6	; 0
  DDR_C90_SENSE_ALARM &= ~(1 << PIN_C90_SENSE_ALARM);
    1898:	21 98       	cbi	0x04, 1	; 4
  PORT_C90_SENSE_ALARM |= (1 << PIN_C90_SENSE_ALARM);
    189a:	19 9a       	sbi	0x03, 1	; 3
  DDR_C90_SENSE_LIGHT &= ~(1 << PIN_C90_SENSE_LIGHT);
    189c:	0f 98       	cbi	0x01, 7	; 1
  PORT_C90_SENSE_LIGHT |= (1 << PIN_C90_SENSE_LIGHT);
    189e:	07 9a       	sbi	0x00, 7	; 0
  DDR_C90_SENSE_IGN &= ~(1 << PIN_C90_SENSE_IGN);
    18a0:	22 98       	cbi	0x04, 2	; 4
  PORT_C90_SENSE_IGN |= (1 << PIN_C90_SENSE_IGN);
    18a2:	1a 9a       	sbi	0x03, 2	; 3
  DDR_C90_SENSE_WARNING &= ~(1 << PIN_C90_SENSE_WARNING);
    18a4:	50 98       	cbi	0x0a, 0	; 10
  PORT_C90_SENSE_WARNING |= (1 << PIN_C90_SENSE_WARNING);
    18a6:	48 9a       	sbi	0x09, 0	; 9
  DDR_C90_SENSE_RESERVE &= ~(1 << PIN_C90_SENSE_RESERVE);
    18a8:	51 98       	cbi	0x0a, 1	; 10
  PORT_C90_SENSE_RESERVE |= (1 << PIN_C90_SENSE_RESERVE);
    18aa:	49 9a       	sbi	0x09, 1	; 9
  // relay pins: as output, set low at start
  // outputs
  DDR_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    18ac:	3a 9a       	sbi	0x07, 2	; 7
  DDR_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    18ae:	3d 9a       	sbi	0x07, 5	; 7
  DDR_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
    18b0:	38 9a       	sbi	0x07, 0	; 7
  DDR_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
    18b2:	3b 9a       	sbi	0x07, 3	; 7
  DDR_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
    18b4:	39 9a       	sbi	0x07, 1	; 7
  DDR_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
    18b6:	3c 9a       	sbi	0x07, 4	; 7
  DDR_C90_CLAXON |= (1 << PIN_C90_CLAXON);
    18b8:	56 9a       	sbi	0x0a, 6	; 10
  DDR_C90_BRAKE |= (1 << PIN_C90_BRAKE);
    18ba:	3f 9a       	sbi	0x07, 7	; 7
  DDR_C90_PILOT |= (1 << PIN_C90_PILOT);
    18bc:	57 9a       	sbi	0x0a, 7	; 10
  DDR_C90_LIGHT |= (1 << PIN_C90_LIGHT);
    18be:	3e 9a       	sbi	0x07, 6	; 7
  // lows
  PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    18c0:	42 98       	cbi	0x08, 2	; 8
  PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    18c2:	45 98       	cbi	0x08, 5	; 8
  PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
    18c4:	40 98       	cbi	0x08, 0	; 8
  PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
    18c6:	43 98       	cbi	0x08, 3	; 8
  PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
    18c8:	41 98       	cbi	0x08, 1	; 8
  PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
    18ca:	44 98       	cbi	0x08, 4	; 8
  PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
    18cc:	5e 98       	cbi	0x0b, 6	; 11
  PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
    18ce:	47 98       	cbi	0x08, 7	; 8
  PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
    18d0:	5f 98       	cbi	0x0b, 7	; 11
  PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
    18d2:	46 98       	cbi	0x08, 6	; 8
  // buzzer
  DDR_C90_BUZZER |= (1 << PIN_C90_BUZZER); // output
    18d4:	55 9a       	sbi	0x0a, 5	; 10
  PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER); // low
    18d6:	5d 98       	cbi	0x0b, 5	; 11
  // heart beat led
  DDR_C90_HEARTBEAT_LED |= (1 << PIN_C90_HEARTBEAT_LED); // output
    18d8:	54 9a       	sbi	0x0a, 4	; 10
  PORT_C90_HEARTBEAT_LED |= (1 << PIN_C90_HEARTBEAT_LED); // high
    18da:	5c 9a       	sbi	0x0b, 4	; 11
  // activate all physical senses
  enable_psenses();
}

void enable_psenses() {
  g_senses = 0b11111111;
    18dc:	8f ef       	ldi	r24, 0xFF	; 255
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	90 93 2c 10 	sts	0x102C, r25
    18e4:	80 93 2b 10 	sts	0x102B, r24
  g_senses = ((g_senses << 8) | 0b11111111);
    18e8:	80 91 2b 10 	lds	r24, 0x102B
    18ec:	90 91 2c 10 	lds	r25, 0x102C
    18f0:	98 2f       	mov	r25, r24
    18f2:	88 27       	eor	r24, r24
    18f4:	8f 6f       	ori	r24, 0xFF	; 255
    18f6:	90 93 2c 10 	sts	0x102C, r25
    18fa:	80 93 2b 10 	sts	0x102B, r24
    18fe:	08 95       	ret

00001900 <process_ri_off>:
    g_buffer_tail = 0; // cycle back to start
  }
}

void process_ri_off() {
  if (FLAG_DEBOUNCE_RI) { // check for 3 positives based on 5ms timer
    1900:	80 91 c9 04 	lds	r24, 0x04C9
    1904:	88 23       	and	r24, r24
    1906:	01 f1       	breq	.+64     	; 0x1948 <process_ri_off+0x48>
    g_ri_debounce = (g_ri_debounce << 1);
    1908:	80 91 5e 04 	lds	r24, 0x045E
    190c:	88 0f       	add	r24, r24
    190e:	80 93 5e 04 	sts	0x045E, r24
    FLAG_DEBOUNCE_RI = 0; // reset to wait for next timer event
    1912:	10 92 c9 04 	sts	0x04C9, r1
    if (((g_ri_debounce & 0b00000111) << 5) == 0) {
    1916:	80 91 5e 04 	lds	r24, 0x045E
    191a:	20 e2       	ldi	r18, 0x20	; 32
    191c:	82 9f       	mul	r24, r18
    191e:	c0 01       	movw	r24, r0
    1920:	11 24       	eor	r1, r1
    1922:	99 27       	eor	r25, r25
    1924:	89 2b       	or	r24, r25
    1926:	81 f4       	brne	.+32     	; 0x1948 <process_ri_off+0x48>
static void set_substate(uint16_t st) {
  g_state |= st;
}

static void remove_substate(uint16_t st) {
  g_state &= ~st;
    1928:	80 91 43 12 	lds	r24, 0x1243
    192c:	90 91 44 12 	lds	r25, 0x1244
    1930:	8d 7f       	andi	r24, 0xFD	; 253
    1932:	90 93 44 12 	sts	0x1244, r25
    1936:	80 93 43 12 	sts	0x1243, r24
    g_ri_debounce = (g_ri_debounce << 1);
    FLAG_DEBOUNCE_RI = 0; // reset to wait for next timer event
    if (((g_ri_debounce & 0b00000111) << 5) == 0) {
      remove_substate(ST_RI); // debouncing done, remove state
      // disable indicators
      PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
    193a:	40 98       	cbi	0x08, 0	; 8
      PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
    193c:	43 98       	cbi	0x08, 3	; 8
      if (g_settings.indicator_sound) {
    193e:	80 91 6a 01 	lds	r24, 0x016A
    1942:	81 11       	cpse	r24, r1
        PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
    1944:	5d 98       	cbi	0x0b, 5	; 11
      }
      PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
    1946:	42 98       	cbi	0x08, 2	; 8
    1948:	08 95       	ret

0000194a <process_ri_on>:
    }
  }
}

void process_ri_on() {
  if (FLAG_DEBOUNCE_RI) { // check for 3 positives based on 5ms timer
    194a:	80 91 c9 04 	lds	r24, 0x04C9
    194e:	88 23       	and	r24, r24
    1950:	69 f0       	breq	.+26     	; 0x196c <process_ri_on+0x22>
    g_ri_debounce = (g_ri_debounce << 1) | 0x01;
    1952:	80 91 5e 04 	lds	r24, 0x045E
    1956:	88 0f       	add	r24, r24
    1958:	81 60       	ori	r24, 0x01	; 1
    195a:	80 93 5e 04 	sts	0x045E, r24
    FLAG_DEBOUNCE_RI = 0; // reset to wait for next timer event
    195e:	10 92 c9 04 	sts	0x04C9, r1
    if (((g_ri_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_RI)) { // blink indicators
    1962:	80 91 5e 04 	lds	r24, 0x045E
    1966:	87 70       	andi	r24, 0x07	; 7
    1968:	87 30       	cpi	r24, 0x07	; 7
    196a:	09 f0       	breq	.+2      	; 0x196e <process_ri_on+0x24>
    196c:	08 95       	ret
    196e:	80 91 d2 04 	lds	r24, 0x04D2
    1972:	88 23       	and	r24, r24
    1974:	d9 f3       	breq	.-10     	; 0x196c <process_ri_on+0x22>
      PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
    1976:	88 b1       	in	r24, 0x08	; 8
    1978:	91 e0       	ldi	r25, 0x01	; 1
    197a:	89 27       	eor	r24, r25
    197c:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
    197e:	88 b1       	in	r24, 0x08	; 8
    1980:	98 e0       	ldi	r25, 0x08	; 8
    1982:	89 27       	eor	r24, r25
    1984:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    1986:	88 b1       	in	r24, 0x08	; 8
    1988:	94 e0       	ldi	r25, 0x04	; 4
    198a:	89 27       	eor	r24, r25
    198c:	88 b9       	out	0x08, r24	; 8
      if (g_settings.indicator_sound) {
    198e:	80 91 6a 01 	lds	r24, 0x016A
    1992:	88 23       	and	r24, r24
    1994:	21 f0       	breq	.+8      	; 0x199e <process_ri_on+0x54>
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
    1996:	8b b1       	in	r24, 0x0b	; 11
    1998:	90 e2       	ldi	r25, 0x20	; 32
    199a:	89 27       	eor	r24, r25
    199c:	8b b9       	out	0x0b, r24	; 11
      }
      FLAG_BLINK_RI = 0; // reset to wait for next timer event
    199e:	10 92 d2 04 	sts	0x04D2, r1
  {check_warning_off, EV_WARNING_OFF, process_warning_off},
  {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
};

static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
    19a2:	80 91 43 12 	lds	r24, 0x1243
    19a6:	90 91 44 12 	lds	r25, 0x1244
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      if (g_settings.indicator_sound) {
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
      }
      FLAG_BLINK_RI = 0; // reset to wait for next timer event
      if (!get_substate(ST_RI)) { // first time to blink
    19aa:	81 fd       	sbrc	r24, 1
    19ac:	df cf       	rjmp	.-66     	; 0x196c <process_ri_on+0x22>
        TCNT1 = 0; // reset timer so the blink starts in an even pace
    19ae:	10 92 85 00 	sts	0x0085, r1
    19b2:	10 92 84 00 	sts	0x0084, r1
static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
}

static void set_substate(uint16_t st) {
  g_state |= st;
    19b6:	80 91 43 12 	lds	r24, 0x1243
    19ba:	90 91 44 12 	lds	r25, 0x1244
    19be:	82 60       	ori	r24, 0x02	; 2
    19c0:	90 93 44 12 	sts	0x1244, r25
    19c4:	80 93 43 12 	sts	0x1243, r24
    19c8:	08 95       	ret

000019ca <process_li_off>:
    }
  }
}

void process_li_off() {
  if (FLAG_DEBOUNCE_LI) { // check for 3 positives based on 5ms timer
    19ca:	80 91 c8 04 	lds	r24, 0x04C8
    19ce:	88 23       	and	r24, r24
    19d0:	01 f1       	breq	.+64     	; 0x1a12 <process_li_off+0x48>
    g_li_debounce = (g_li_debounce << 1);
    19d2:	80 91 5d 04 	lds	r24, 0x045D
    19d6:	88 0f       	add	r24, r24
    19d8:	80 93 5d 04 	sts	0x045D, r24
    FLAG_DEBOUNCE_LI = 0; // reset to wait for next timer event
    19dc:	10 92 c8 04 	sts	0x04C8, r1
    if (((g_li_debounce & 0b00000111) << 5) == 0) {
    19e0:	80 91 5d 04 	lds	r24, 0x045D
    19e4:	20 e2       	ldi	r18, 0x20	; 32
    19e6:	82 9f       	mul	r24, r18
    19e8:	c0 01       	movw	r24, r0
    19ea:	11 24       	eor	r1, r1
    19ec:	99 27       	eor	r25, r25
    19ee:	89 2b       	or	r24, r25
    19f0:	81 f4       	brne	.+32     	; 0x1a12 <process_li_off+0x48>
static void set_substate(uint16_t st) {
  g_state |= st;
}

static void remove_substate(uint16_t st) {
  g_state &= ~st;
    19f2:	80 91 43 12 	lds	r24, 0x1243
    19f6:	90 91 44 12 	lds	r25, 0x1244
    19fa:	8b 7f       	andi	r24, 0xFB	; 251
    19fc:	90 93 44 12 	sts	0x1244, r25
    1a00:	80 93 43 12 	sts	0x1243, r24
    g_li_debounce = (g_li_debounce << 1);
    FLAG_DEBOUNCE_LI = 0; // reset to wait for next timer event
    if (((g_li_debounce & 0b00000111) << 5) == 0) {
      remove_substate(ST_LI); // debouncing done, remove state
      // disable indicators
      PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
    1a04:	41 98       	cbi	0x08, 1	; 8
      PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
    1a06:	44 98       	cbi	0x08, 4	; 8
      if (g_settings.indicator_sound) {
    1a08:	80 91 6a 01 	lds	r24, 0x016A
    1a0c:	81 11       	cpse	r24, r1
        PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
    1a0e:	5d 98       	cbi	0x0b, 5	; 11
      }
      PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
    1a10:	42 98       	cbi	0x08, 2	; 8
    1a12:	08 95       	ret

00001a14 <process_li_on>:
    }
  }
}

void process_li_on() {
  if (FLAG_DEBOUNCE_LI) { // check for 3 positives based on 5ms timer
    1a14:	80 91 c8 04 	lds	r24, 0x04C8
    1a18:	88 23       	and	r24, r24
    1a1a:	69 f0       	breq	.+26     	; 0x1a36 <process_li_on+0x22>
    g_li_debounce = (g_li_debounce << 1) | 0x01;
    1a1c:	80 91 5d 04 	lds	r24, 0x045D
    1a20:	88 0f       	add	r24, r24
    1a22:	81 60       	ori	r24, 0x01	; 1
    1a24:	80 93 5d 04 	sts	0x045D, r24
    FLAG_DEBOUNCE_LI = 0; // reset to wait for next timer event
    1a28:	10 92 c8 04 	sts	0x04C8, r1
    if (((g_li_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_LI)) { // blink indicators
    1a2c:	80 91 5d 04 	lds	r24, 0x045D
    1a30:	87 70       	andi	r24, 0x07	; 7
    1a32:	87 30       	cpi	r24, 0x07	; 7
    1a34:	09 f0       	breq	.+2      	; 0x1a38 <process_li_on+0x24>
    1a36:	08 95       	ret
    1a38:	80 91 d1 04 	lds	r24, 0x04D1
    1a3c:	88 23       	and	r24, r24
    1a3e:	d9 f3       	breq	.-10     	; 0x1a36 <process_li_on+0x22>
      PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F); // front
    1a40:	88 b1       	in	r24, 0x08	; 8
    1a42:	92 e0       	ldi	r25, 0x02	; 2
    1a44:	89 27       	eor	r24, r25
    1a46:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B); // rear
    1a48:	88 b1       	in	r24, 0x08	; 8
    1a4a:	90 e1       	ldi	r25, 0x10	; 16
    1a4c:	89 27       	eor	r24, r25
    1a4e:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
    1a50:	88 b1       	in	r24, 0x08	; 8
    1a52:	94 e0       	ldi	r25, 0x04	; 4
    1a54:	89 27       	eor	r24, r25
    1a56:	88 b9       	out	0x08, r24	; 8
      if (g_settings.indicator_sound) {
    1a58:	80 91 6a 01 	lds	r24, 0x016A
    1a5c:	88 23       	and	r24, r24
    1a5e:	21 f0       	breq	.+8      	; 0x1a68 <process_li_on+0x54>
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
    1a60:	8b b1       	in	r24, 0x0b	; 11
    1a62:	90 e2       	ldi	r25, 0x20	; 32
    1a64:	89 27       	eor	r24, r25
    1a66:	8b b9       	out	0x0b, r24	; 11
      }
      FLAG_BLINK_LI = 0; // reset to wait for next timer event
    1a68:	10 92 d1 04 	sts	0x04D1, r1
  {check_warning_off, EV_WARNING_OFF, process_warning_off},
  {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
};

static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
    1a6c:	80 91 43 12 	lds	r24, 0x1243
    1a70:	90 91 44 12 	lds	r25, 0x1244
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
      if (g_settings.indicator_sound) {
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
      }
      FLAG_BLINK_LI = 0; // reset to wait for next timer event
      if (!get_substate(ST_LI)) { // first time to blink
    1a74:	82 fd       	sbrc	r24, 2
    1a76:	df cf       	rjmp	.-66     	; 0x1a36 <process_li_on+0x22>
        TCNT1 = 0; // set 0.5 sec timer counter explicitly to 0, so the first blink happens exactly 0.5 secs later
    1a78:	10 92 85 00 	sts	0x0085, r1
    1a7c:	10 92 84 00 	sts	0x0084, r1
static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
}

static void set_substate(uint16_t st) {
  g_state |= st;
    1a80:	80 91 43 12 	lds	r24, 0x1243
    1a84:	90 91 44 12 	lds	r25, 0x1244
    1a88:	84 60       	ori	r24, 0x04	; 4
    1a8a:	90 93 44 12 	sts	0x1244, r25
    1a8e:	80 93 43 12 	sts	0x1243, r24
    1a92:	08 95       	ret

00001a94 <process_claxon_on>:
    }
  }
}

void process_claxon_on() {
  if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
    1a94:	80 91 c7 04 	lds	r24, 0x04C7
    1a98:	88 23       	and	r24, r24
    1a9a:	69 f0       	breq	.+26     	; 0x1ab6 <process_claxon_on+0x22>
    g_claxon_debounce = (g_claxon_debounce << 1) | 0x01;
    1a9c:	80 91 5c 04 	lds	r24, 0x045C
    1aa0:	88 0f       	add	r24, r24
    1aa2:	81 60       	ori	r24, 0x01	; 1
    1aa4:	80 93 5c 04 	sts	0x045C, r24
    FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
    1aa8:	10 92 c7 04 	sts	0x04C7, r1
    if ((g_claxon_debounce & 0b00000111) == 0b00000111) { // start claxon
    1aac:	80 91 5c 04 	lds	r24, 0x045C
    1ab0:	87 70       	andi	r24, 0x07	; 7
    1ab2:	87 30       	cpi	r24, 0x07	; 7
    1ab4:	09 f0       	breq	.+2      	; 0x1ab8 <process_claxon_on+0x24>
    1ab6:	08 95       	ret
      PORT_C90_CLAXON |= (1 << PIN_C90_CLAXON);
    1ab8:	5e 9a       	sbi	0x0b, 6	; 11
  {check_warning_off, EV_WARNING_OFF, process_warning_off},
  {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
};

static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
    1aba:	80 91 43 12 	lds	r24, 0x1243
    1abe:	90 91 44 12 	lds	r25, 0x1244
  if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
    g_claxon_debounce = (g_claxon_debounce << 1) | 0x01;
    FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
    if ((g_claxon_debounce & 0b00000111) == 0b00000111) { // start claxon
      PORT_C90_CLAXON |= (1 << PIN_C90_CLAXON);
      if (!get_substate(ST_CLAXON)) {
    1ac2:	83 fd       	sbrc	r24, 3
    1ac4:	f8 cf       	rjmp	.-16     	; 0x1ab6 <process_claxon_on+0x22>
static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
}

static void set_substate(uint16_t st) {
  g_state |= st;
    1ac6:	80 91 43 12 	lds	r24, 0x1243
    1aca:	90 91 44 12 	lds	r25, 0x1244
    1ace:	88 60       	ori	r24, 0x08	; 8
    1ad0:	90 93 44 12 	sts	0x1244, r25
    1ad4:	80 93 43 12 	sts	0x1243, r24
    1ad8:	08 95       	ret

00001ada <process_claxon_off>:
    }
  }
}

void process_claxon_off() {
  if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
    1ada:	80 91 c7 04 	lds	r24, 0x04C7
    1ade:	88 23       	and	r24, r24
    1ae0:	d1 f0       	breq	.+52     	; 0x1b16 <process_claxon_off+0x3c>
    g_claxon_debounce = (g_claxon_debounce << 1);
    1ae2:	80 91 5c 04 	lds	r24, 0x045C
    1ae6:	88 0f       	add	r24, r24
    1ae8:	80 93 5c 04 	sts	0x045C, r24
    FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
    1aec:	10 92 c7 04 	sts	0x04C7, r1
    if (((g_claxon_debounce & 0b00000111) << 5) == 0) {
    1af0:	80 91 5c 04 	lds	r24, 0x045C
    1af4:	20 e2       	ldi	r18, 0x20	; 32
    1af6:	82 9f       	mul	r24, r18
    1af8:	c0 01       	movw	r24, r0
    1afa:	11 24       	eor	r1, r1
    1afc:	99 27       	eor	r25, r25
    1afe:	89 2b       	or	r24, r25
    1b00:	51 f4       	brne	.+20     	; 0x1b16 <process_claxon_off+0x3c>
static void set_substate(uint16_t st) {
  g_state |= st;
}

static void remove_substate(uint16_t st) {
  g_state &= ~st;
    1b02:	80 91 43 12 	lds	r24, 0x1243
    1b06:	90 91 44 12 	lds	r25, 0x1244
    1b0a:	87 7f       	andi	r24, 0xF7	; 247
    1b0c:	90 93 44 12 	sts	0x1244, r25
    1b10:	80 93 43 12 	sts	0x1243, r24
  if (FLAG_DEBOUNCE_CLAXON) { // check for 3 positives based on 5ms timer
    g_claxon_debounce = (g_claxon_debounce << 1);
    FLAG_DEBOUNCE_CLAXON = 0; // reset to wait for next timer event
    if (((g_claxon_debounce & 0b00000111) << 5) == 0) {
      remove_substate(ST_CLAXON); // debouncing done, remove state
      PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
    1b14:	5e 98       	cbi	0x0b, 6	; 11
    1b16:	08 95       	ret

00001b18 <process_warning_on>:
    }
  }
}

void process_warning_on() {
  if (FLAG_DEBOUNCE_WARNING) { // check for 3 positives based on 5ms timer
    1b18:	80 91 c1 04 	lds	r24, 0x04C1
    1b1c:	88 23       	and	r24, r24
    1b1e:	69 f0       	breq	.+26     	; 0x1b3a <process_warning_on+0x22>
    g_warning_debounce = (g_warning_debounce << 1) | 0x01;
    1b20:	80 91 56 04 	lds	r24, 0x0456
    1b24:	88 0f       	add	r24, r24
    1b26:	81 60       	ori	r24, 0x01	; 1
    1b28:	80 93 56 04 	sts	0x0456, r24
    FLAG_DEBOUNCE_WARNING = 0; // reset to wait for next timer event
    1b2c:	10 92 c1 04 	sts	0x04C1, r1
    if (((g_warning_debounce & 0b00000111) == 0b00000111) && (FLAG_BLINK_WARNING)) { // blink indicators
    1b30:	80 91 56 04 	lds	r24, 0x0456
    1b34:	87 70       	andi	r24, 0x07	; 7
    1b36:	87 30       	cpi	r24, 0x07	; 7
    1b38:	09 f0       	breq	.+2      	; 0x1b3c <process_warning_on+0x24>
    1b3a:	08 95       	ret
    1b3c:	80 91 d0 04 	lds	r24, 0x04D0
    1b40:	88 23       	and	r24, r24
    1b42:	d9 f3       	breq	.-10     	; 0x1b3a <process_warning_on+0x22>
      PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
    1b44:	88 b1       	in	r24, 0x08	; 8
    1b46:	91 e0       	ldi	r25, 0x01	; 1
    1b48:	89 27       	eor	r24, r25
    1b4a:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
    1b4c:	88 b1       	in	r24, 0x08	; 8
    1b4e:	98 e0       	ldi	r25, 0x08	; 8
    1b50:	89 27       	eor	r24, r25
    1b52:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
    1b54:	88 b1       	in	r24, 0x08	; 8
    1b56:	92 e0       	ldi	r25, 0x02	; 2
    1b58:	89 27       	eor	r24, r25
    1b5a:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
    1b5c:	88 b1       	in	r24, 0x08	; 8
    1b5e:	90 e1       	ldi	r25, 0x10	; 16
    1b60:	89 27       	eor	r24, r25
    1b62:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    1b64:	88 b1       	in	r24, 0x08	; 8
    1b66:	94 e0       	ldi	r25, 0x04	; 4
    1b68:	89 27       	eor	r24, r25
    1b6a:	88 b9       	out	0x08, r24	; 8
      if (g_settings.indicator_sound) {
    1b6c:	80 91 6a 01 	lds	r24, 0x016A
    1b70:	88 23       	and	r24, r24
    1b72:	21 f0       	breq	.+8      	; 0x1b7c <process_warning_on+0x64>
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
    1b74:	8b b1       	in	r24, 0x0b	; 11
    1b76:	90 e2       	ldi	r25, 0x20	; 32
    1b78:	89 27       	eor	r24, r25
    1b7a:	8b b9       	out	0x0b, r24	; 11
      }
      FLAG_BLINK_WARNING = 0; // reset to wait for next timer event
    1b7c:	10 92 d0 04 	sts	0x04D0, r1
  {check_warning_off, EV_WARNING_OFF, process_warning_off},
  {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
};

static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
    1b80:	80 91 43 12 	lds	r24, 0x1243
    1b84:	90 91 44 12 	lds	r25, 0x1244
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      if (g_settings.indicator_sound) {
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
      }
      FLAG_BLINK_WARNING = 0; // reset to wait for next timer event
      if (!get_substate(ST_WARNING)) { // first time to blink
    1b88:	93 fd       	sbrc	r25, 3
    1b8a:	d7 cf       	rjmp	.-82     	; 0x1b3a <process_warning_on+0x22>
        TCNT1 = 0; // reset timer so the blink starts in an even pace
    1b8c:	10 92 85 00 	sts	0x0085, r1
    1b90:	10 92 84 00 	sts	0x0084, r1
        // initial ON for indicators to prevent a  RI/LI ON messing with the synchronization, i.e. warning lights override indicator switches
        PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
    1b94:	40 9a       	sbi	0x08, 0	; 8
        PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
    1b96:	43 9a       	sbi	0x08, 3	; 8
        PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
    1b98:	41 9a       	sbi	0x08, 1	; 8
        PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
    1b9a:	44 9a       	sbi	0x08, 4	; 8
        PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    1b9c:	42 9a       	sbi	0x08, 2	; 8
static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
}

static void set_substate(uint16_t st) {
  g_state |= st;
    1b9e:	80 91 43 12 	lds	r24, 0x1243
    1ba2:	90 91 44 12 	lds	r25, 0x1244
    1ba6:	98 60       	ori	r25, 0x08	; 8
    1ba8:	90 93 44 12 	sts	0x1244, r25
    1bac:	80 93 43 12 	sts	0x1243, r24
    1bb0:	08 95       	ret

00001bb2 <process_warning_off>:
    }
  }
}

void process_warning_off() {
  if (FLAG_DEBOUNCE_WARNING) { // check for 3 positives based on 5ms timer
    1bb2:	80 91 c1 04 	lds	r24, 0x04C1
    1bb6:	88 23       	and	r24, r24
    1bb8:	11 f1       	breq	.+68     	; 0x1bfe <process_warning_off+0x4c>
    g_warning_debounce = (g_warning_debounce << 1);
    1bba:	80 91 56 04 	lds	r24, 0x0456
    1bbe:	88 0f       	add	r24, r24
    1bc0:	80 93 56 04 	sts	0x0456, r24
    FLAG_DEBOUNCE_WARNING = 0; // reset to wait for next timer event
    1bc4:	10 92 c1 04 	sts	0x04C1, r1
    if (((g_warning_debounce & 0b00000111) << 5) == 0) {
    1bc8:	80 91 56 04 	lds	r24, 0x0456
    1bcc:	20 e2       	ldi	r18, 0x20	; 32
    1bce:	82 9f       	mul	r24, r18
    1bd0:	c0 01       	movw	r24, r0
    1bd2:	11 24       	eor	r1, r1
    1bd4:	99 27       	eor	r25, r25
    1bd6:	89 2b       	or	r24, r25
    1bd8:	91 f4       	brne	.+36     	; 0x1bfe <process_warning_off+0x4c>
static void set_substate(uint16_t st) {
  g_state |= st;
}

static void remove_substate(uint16_t st) {
  g_state &= ~st;
    1bda:	80 91 43 12 	lds	r24, 0x1243
    1bde:	90 91 44 12 	lds	r25, 0x1244
    1be2:	97 7f       	andi	r25, 0xF7	; 247
    1be4:	90 93 44 12 	sts	0x1244, r25
    1be8:	80 93 43 12 	sts	0x1243, r24
    g_warning_debounce = (g_warning_debounce << 1);
    FLAG_DEBOUNCE_WARNING = 0; // reset to wait for next timer event
    if (((g_warning_debounce & 0b00000111) << 5) == 0) {
      remove_substate(ST_WARNING); // debouncing done, remove state
      // disable indicators
      PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
    1bec:	41 98       	cbi	0x08, 1	; 8
      PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
    1bee:	44 98       	cbi	0x08, 4	; 8
      PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
    1bf0:	40 98       	cbi	0x08, 0	; 8
      PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
    1bf2:	43 98       	cbi	0x08, 3	; 8
      if (g_settings.indicator_sound) {
    1bf4:	80 91 6a 01 	lds	r24, 0x016A
    1bf8:	81 11       	cpse	r24, r1
        PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
    1bfa:	5d 98       	cbi	0x0b, 5	; 11
      }
      PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
    1bfc:	42 98       	cbi	0x08, 2	; 8
    1bfe:	08 95       	ret

00001c00 <process_backpedal>:
  }
}

// check for an acceleration of 25cm/s, 20mV change in the negative Y-axis
void process_backpedal() {
  if (FLAG_READ_BACKPEDAL) {
    1c00:	80 91 bf 04 	lds	r24, 0x04BF
    1c04:	88 23       	and	r24, r24
    1c06:	39 f1       	breq	.+78     	; 0x1c56 <process_backpedal+0x56>
    FLAG_READ_BACKPEDAL = 0; // reset to wait for next timer event
    1c08:	10 92 bf 04 	sts	0x04BF, r1
    if ((g_adc_voltage[2] < g_settings.backpedal_thres_min) && FLAG_BLINK_BACKPEDAL) {
    1c0c:	20 91 3b 12 	lds	r18, 0x123B
    1c10:	30 91 3c 12 	lds	r19, 0x123C
    1c14:	80 91 74 01 	lds	r24, 0x0174
    1c18:	90 91 75 01 	lds	r25, 0x0175
    1c1c:	28 17       	cp	r18, r24
    1c1e:	39 07       	cpc	r19, r25
    1c20:	d8 f0       	brcs	.+54     	; 0x1c58 <process_backpedal+0x58>
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      if (g_settings.indicator_sound) {
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
      }
      FLAG_BLINK_BACKPEDAL = 0;
    } else if ((g_adc_voltage[2] >= g_settings.backpedal_thres_min) && FLAG_BACKPEDAL && FLAG_BLINK_BACKPEDAL) {
    1c22:	20 91 3b 12 	lds	r18, 0x123B
    1c26:	30 91 3c 12 	lds	r19, 0x123C
    1c2a:	28 17       	cp	r18, r24
    1c2c:	39 07       	cpc	r19, r25
    1c2e:	98 f0       	brcs	.+38     	; 0x1c56 <process_backpedal+0x56>
    1c30:	80 91 be 04 	lds	r24, 0x04BE
    1c34:	88 23       	and	r24, r24
    1c36:	79 f0       	breq	.+30     	; 0x1c56 <process_backpedal+0x56>
    1c38:	80 91 cf 04 	lds	r24, 0x04CF
    1c3c:	88 23       	and	r24, r24
    1c3e:	59 f0       	breq	.+22     	; 0x1c56 <process_backpedal+0x56>
      FLAG_BACKPEDAL = 0;
    1c40:	10 92 be 04 	sts	0x04BE, r1
      PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F); // front
    1c44:	41 98       	cbi	0x08, 1	; 8
      PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B); // rear
    1c46:	44 98       	cbi	0x08, 4	; 8
      PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F); // front
    1c48:	40 98       	cbi	0x08, 0	; 8
      PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B); // rear
    1c4a:	43 98       	cbi	0x08, 3	; 8
      if (g_settings.indicator_sound) {
    1c4c:	80 91 6a 01 	lds	r24, 0x016A
    1c50:	81 11       	cpse	r24, r1
        PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
    1c52:	5d 98       	cbi	0x0b, 5	; 11
      }
      PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT); // cockpit
    1c54:	42 98       	cbi	0x08, 2	; 8
    1c56:	08 95       	ret

// check for an acceleration of 25cm/s, 20mV change in the negative Y-axis
void process_backpedal() {
  if (FLAG_READ_BACKPEDAL) {
    FLAG_READ_BACKPEDAL = 0; // reset to wait for next timer event
    if ((g_adc_voltage[2] < g_settings.backpedal_thres_min) && FLAG_BLINK_BACKPEDAL) {
    1c58:	20 91 cf 04 	lds	r18, 0x04CF
    1c5c:	22 23       	and	r18, r18
    1c5e:	09 f3       	breq	.-62     	; 0x1c22 <process_backpedal+0x22>
      FLAG_BACKPEDAL = 1;
    1c60:	91 e0       	ldi	r25, 0x01	; 1
    1c62:	90 93 be 04 	sts	0x04BE, r25
      PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
    1c66:	88 b1       	in	r24, 0x08	; 8
    1c68:	89 27       	eor	r24, r25
    1c6a:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
    1c6c:	88 b1       	in	r24, 0x08	; 8
    1c6e:	98 e0       	ldi	r25, 0x08	; 8
    1c70:	89 27       	eor	r24, r25
    1c72:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
    1c74:	88 b1       	in	r24, 0x08	; 8
    1c76:	92 e0       	ldi	r25, 0x02	; 2
    1c78:	89 27       	eor	r24, r25
    1c7a:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
    1c7c:	88 b1       	in	r24, 0x08	; 8
    1c7e:	90 e1       	ldi	r25, 0x10	; 16
    1c80:	89 27       	eor	r24, r25
    1c82:	88 b9       	out	0x08, r24	; 8
      PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    1c84:	88 b1       	in	r24, 0x08	; 8
    1c86:	94 e0       	ldi	r25, 0x04	; 4
    1c88:	89 27       	eor	r24, r25
    1c8a:	88 b9       	out	0x08, r24	; 8
      if (g_settings.indicator_sound) {
    1c8c:	80 91 6a 01 	lds	r24, 0x016A
    1c90:	88 23       	and	r24, r24
    1c92:	21 f0       	breq	.+8      	; 0x1c9c <process_backpedal+0x9c>
        PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
    1c94:	8b b1       	in	r24, 0x0b	; 11
    1c96:	90 e2       	ldi	r25, 0x20	; 32
    1c98:	89 27       	eor	r24, r25
    1c9a:	8b b9       	out	0x0b, r24	; 11
      }
      FLAG_BLINK_BACKPEDAL = 0;
    1c9c:	10 92 cf 04 	sts	0x04CF, r1
    1ca0:	08 95       	ret

00001ca2 <process_ign_on>:
    }
  }
}

void process_ign_on() {
  if (FLAG_DEBOUNCE_IGN) { // check for 3 positives based on 5ms timer
    1ca2:	80 91 c6 04 	lds	r24, 0x04C6
    1ca6:	88 23       	and	r24, r24
    1ca8:	69 f0       	breq	.+26     	; 0x1cc4 <process_ign_on+0x22>
    g_ign_debounce= (g_ign_debounce << 1) | 0x01;
    1caa:	80 91 5b 04 	lds	r24, 0x045B
    1cae:	88 0f       	add	r24, r24
    1cb0:	81 60       	ori	r24, 0x01	; 1
    1cb2:	80 93 5b 04 	sts	0x045B, r24
    FLAG_DEBOUNCE_IGN = 0; // reset to wait for next timer event
    1cb6:	10 92 c6 04 	sts	0x04C6, r1
    if ((g_ign_debounce & 0b00000111) == 0b00000111) {
    1cba:	80 91 5b 04 	lds	r24, 0x045B
    1cbe:	87 70       	andi	r24, 0x07	; 7
    1cc0:	87 30       	cpi	r24, 0x07	; 7
    1cc2:	09 f0       	breq	.+2      	; 0x1cc6 <process_ign_on+0x24>
    1cc4:	08 95       	ret
      g_state = ST_SETTLE;
    1cc6:	80 e0       	ldi	r24, 0x00	; 0
    1cc8:	94 e0       	ldi	r25, 0x04	; 4
    1cca:	90 93 44 12 	sts	0x1244, r25
    1cce:	80 93 43 12 	sts	0x1243, r24
    1cd2:	08 95       	ret

00001cd4 <process_brake_on>:
    }
  }
}

void process_brake_on() {
  if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
    1cd4:	80 91 c4 04 	lds	r24, 0x04C4
    1cd8:	88 23       	and	r24, r24
    1cda:	69 f0       	breq	.+26     	; 0x1cf6 <process_brake_on+0x22>
    g_brake_debounce = (g_brake_debounce << 1) | 0x01;
    1cdc:	80 91 5a 04 	lds	r24, 0x045A
    1ce0:	88 0f       	add	r24, r24
    1ce2:	81 60       	ori	r24, 0x01	; 1
    1ce4:	80 93 5a 04 	sts	0x045A, r24
    FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
    1ce8:	10 92 c4 04 	sts	0x04C4, r1
    if ((g_brake_debounce & 0b00000111) == 0b00000111) { // start brake
    1cec:	80 91 5a 04 	lds	r24, 0x045A
    1cf0:	87 70       	andi	r24, 0x07	; 7
    1cf2:	87 30       	cpi	r24, 0x07	; 7
    1cf4:	09 f0       	breq	.+2      	; 0x1cf8 <process_brake_on+0x24>
    1cf6:	08 95       	ret
      PORT_C90_BRAKE |= (1 << PIN_C90_BRAKE);
    1cf8:	47 9a       	sbi	0x08, 7	; 8
  {check_warning_off, EV_WARNING_OFF, process_warning_off},
  {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
};

static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
    1cfa:	80 91 43 12 	lds	r24, 0x1243
    1cfe:	90 91 44 12 	lds	r25, 0x1244
  if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
    g_brake_debounce = (g_brake_debounce << 1) | 0x01;
    FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
    if ((g_brake_debounce & 0b00000111) == 0b00000111) { // start brake
      PORT_C90_BRAKE |= (1 << PIN_C90_BRAKE);
      if (!get_substate(ST_BRAKE)) {
    1d02:	84 fd       	sbrc	r24, 4
    1d04:	f8 cf       	rjmp	.-16     	; 0x1cf6 <process_brake_on+0x22>
static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
}

static void set_substate(uint16_t st) {
  g_state |= st;
    1d06:	80 91 43 12 	lds	r24, 0x1243
    1d0a:	90 91 44 12 	lds	r25, 0x1244
    1d0e:	80 61       	ori	r24, 0x10	; 16
    1d10:	90 93 44 12 	sts	0x1244, r25
    1d14:	80 93 43 12 	sts	0x1243, r24
    1d18:	08 95       	ret

00001d1a <process_brake_off>:
    }
  }
}

void process_brake_off() {
  if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
    1d1a:	80 91 c4 04 	lds	r24, 0x04C4
    1d1e:	88 23       	and	r24, r24
    1d20:	d1 f0       	breq	.+52     	; 0x1d56 <process_brake_off+0x3c>
    g_brake_debounce = (g_brake_debounce << 1);
    1d22:	80 91 5a 04 	lds	r24, 0x045A
    1d26:	88 0f       	add	r24, r24
    1d28:	80 93 5a 04 	sts	0x045A, r24
    FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
    1d2c:	10 92 c4 04 	sts	0x04C4, r1
    if (((g_brake_debounce & 0b00000111) << 5) == 0) {
    1d30:	80 91 5a 04 	lds	r24, 0x045A
    1d34:	20 e2       	ldi	r18, 0x20	; 32
    1d36:	82 9f       	mul	r24, r18
    1d38:	c0 01       	movw	r24, r0
    1d3a:	11 24       	eor	r1, r1
    1d3c:	99 27       	eor	r25, r25
    1d3e:	89 2b       	or	r24, r25
    1d40:	51 f4       	brne	.+20     	; 0x1d56 <process_brake_off+0x3c>
static void set_substate(uint16_t st) {
  g_state |= st;
}

static void remove_substate(uint16_t st) {
  g_state &= ~st;
    1d42:	80 91 43 12 	lds	r24, 0x1243
    1d46:	90 91 44 12 	lds	r25, 0x1244
    1d4a:	8f 7e       	andi	r24, 0xEF	; 239
    1d4c:	90 93 44 12 	sts	0x1244, r25
    1d50:	80 93 43 12 	sts	0x1243, r24
  if (FLAG_DEBOUNCE_BRAKE) { // check for 3 positives based on 5ms timer
    g_brake_debounce = (g_brake_debounce << 1);
    FLAG_DEBOUNCE_BRAKE = 0; // reset to wait for next timer event
    if (((g_brake_debounce & 0b00000111) << 5) == 0) {
      remove_substate(ST_BRAKE); // debouncing done, remove state
      PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE); // disable brake
    1d54:	47 98       	cbi	0x08, 7	; 8
    1d56:	08 95       	ret

00001d58 <process_pilot_on>:
    }
  }
}

void process_pilot_on() {
  if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
    1d58:	80 91 c3 04 	lds	r24, 0x04C3
    1d5c:	88 23       	and	r24, r24
    1d5e:	69 f0       	breq	.+26     	; 0x1d7a <process_pilot_on+0x22>
    g_pilot_debounce = (g_pilot_debounce << 1) | 0x01;
    1d60:	80 91 59 04 	lds	r24, 0x0459
    1d64:	88 0f       	add	r24, r24
    1d66:	81 60       	ori	r24, 0x01	; 1
    1d68:	80 93 59 04 	sts	0x0459, r24
    FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
    1d6c:	10 92 c3 04 	sts	0x04C3, r1
    if ((g_pilot_debounce & 0b00000111) == 0b00000111) { // start pilot
    1d70:	80 91 59 04 	lds	r24, 0x0459
    1d74:	87 70       	andi	r24, 0x07	; 7
    1d76:	87 30       	cpi	r24, 0x07	; 7
    1d78:	09 f0       	breq	.+2      	; 0x1d7c <process_pilot_on+0x24>
    1d7a:	08 95       	ret
      PORT_C90_PILOT |= (1 << PIN_C90_PILOT);
    1d7c:	5f 9a       	sbi	0x0b, 7	; 11
  {check_warning_off, EV_WARNING_OFF, process_warning_off},
  {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
};

static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
    1d7e:	80 91 43 12 	lds	r24, 0x1243
    1d82:	90 91 44 12 	lds	r25, 0x1244
  if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
    g_pilot_debounce = (g_pilot_debounce << 1) | 0x01;
    FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
    if ((g_pilot_debounce & 0b00000111) == 0b00000111) { // start pilot
      PORT_C90_PILOT |= (1 << PIN_C90_PILOT);
      if (!get_substate(ST_PILOT)) {
    1d86:	87 fd       	sbrc	r24, 7
    1d88:	f8 cf       	rjmp	.-16     	; 0x1d7a <process_pilot_on+0x22>
static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
}

static void set_substate(uint16_t st) {
  g_state |= st;
    1d8a:	80 91 43 12 	lds	r24, 0x1243
    1d8e:	90 91 44 12 	lds	r25, 0x1244
    1d92:	80 68       	ori	r24, 0x80	; 128
    1d94:	90 93 44 12 	sts	0x1244, r25
    1d98:	80 93 43 12 	sts	0x1243, r24
    1d9c:	08 95       	ret

00001d9e <process_pilot_off>:
    }
  }
}

void process_pilot_off() {
  if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
    1d9e:	80 91 c3 04 	lds	r24, 0x04C3
    1da2:	88 23       	and	r24, r24
    1da4:	d1 f0       	breq	.+52     	; 0x1dda <process_pilot_off+0x3c>
    g_pilot_debounce = (g_pilot_debounce << 1);
    1da6:	80 91 59 04 	lds	r24, 0x0459
    1daa:	88 0f       	add	r24, r24
    1dac:	80 93 59 04 	sts	0x0459, r24
    FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
    1db0:	10 92 c3 04 	sts	0x04C3, r1
    if (((g_pilot_debounce & 0b00000111) << 5) == 0) {
    1db4:	80 91 59 04 	lds	r24, 0x0459
    1db8:	20 e2       	ldi	r18, 0x20	; 32
    1dba:	82 9f       	mul	r24, r18
    1dbc:	c0 01       	movw	r24, r0
    1dbe:	11 24       	eor	r1, r1
    1dc0:	99 27       	eor	r25, r25
    1dc2:	89 2b       	or	r24, r25
    1dc4:	51 f4       	brne	.+20     	; 0x1dda <process_pilot_off+0x3c>
static void set_substate(uint16_t st) {
  g_state |= st;
}

static void remove_substate(uint16_t st) {
  g_state &= ~st;
    1dc6:	80 91 43 12 	lds	r24, 0x1243
    1dca:	90 91 44 12 	lds	r25, 0x1244
    1dce:	8f 77       	andi	r24, 0x7F	; 127
    1dd0:	90 93 44 12 	sts	0x1244, r25
    1dd4:	80 93 43 12 	sts	0x1243, r24
  if (FLAG_DEBOUNCE_PILOT) { // check for 3 positives based on 5ms timer
    g_pilot_debounce = (g_pilot_debounce << 1);
    FLAG_DEBOUNCE_PILOT = 0; // reset to wait for next timer event
    if (((g_pilot_debounce & 0b00000111) << 5) == 0) {
      remove_substate(ST_PILOT); // debouncing done, remove state
      PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT); // disable pilot
    1dd8:	5f 98       	cbi	0x0b, 7	; 11
    1dda:	08 95       	ret

00001ddc <process_light_on>:
    }
  }
}

void process_light_on() {
  if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
    1ddc:	80 91 c2 04 	lds	r24, 0x04C2
    1de0:	88 23       	and	r24, r24
    1de2:	69 f0       	breq	.+26     	; 0x1dfe <process_light_on+0x22>
    g_light_debounce = (g_light_debounce << 1) | 0x01;
    1de4:	80 91 58 04 	lds	r24, 0x0458
    1de8:	88 0f       	add	r24, r24
    1dea:	81 60       	ori	r24, 0x01	; 1
    1dec:	80 93 58 04 	sts	0x0458, r24
    FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
    1df0:	10 92 c2 04 	sts	0x04C2, r1
    if ((g_light_debounce & 0b00000111) == 0b00000111) { // start light
    1df4:	80 91 58 04 	lds	r24, 0x0458
    1df8:	87 70       	andi	r24, 0x07	; 7
    1dfa:	87 30       	cpi	r24, 0x07	; 7
    1dfc:	09 f0       	breq	.+2      	; 0x1e00 <process_light_on+0x24>
    1dfe:	08 95       	ret
      PORT_C90_LIGHT |= (1 << PIN_C90_LIGHT);
    1e00:	46 9a       	sbi	0x08, 6	; 8
  {check_warning_off, EV_WARNING_OFF, process_warning_off},
  {check_backpedal_on, EV_BACKPEDAL, process_backpedal}
};

static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
    1e02:	80 91 43 12 	lds	r24, 0x1243
    1e06:	90 91 44 12 	lds	r25, 0x1244
  if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
    g_light_debounce = (g_light_debounce << 1) | 0x01;
    FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
    if ((g_light_debounce & 0b00000111) == 0b00000111) { // start light
      PORT_C90_LIGHT |= (1 << PIN_C90_LIGHT);
      if (!get_substate(ST_LIGHT)) {
    1e0a:	85 fd       	sbrc	r24, 5
    1e0c:	f8 cf       	rjmp	.-16     	; 0x1dfe <process_light_on+0x22>
static uint16_t get_substate(uint16_t st) {
  return (g_state & st);
}

static void set_substate(uint16_t st) {
  g_state |= st;
    1e0e:	80 91 43 12 	lds	r24, 0x1243
    1e12:	90 91 44 12 	lds	r25, 0x1244
    1e16:	80 62       	ori	r24, 0x20	; 32
    1e18:	90 93 44 12 	sts	0x1244, r25
    1e1c:	80 93 43 12 	sts	0x1243, r24
    1e20:	08 95       	ret

00001e22 <process_light_off>:
    }
  }
}

void process_light_off() {
  if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
    1e22:	80 91 c2 04 	lds	r24, 0x04C2
    1e26:	88 23       	and	r24, r24
    1e28:	d1 f0       	breq	.+52     	; 0x1e5e <process_light_off+0x3c>
    g_light_debounce = (g_light_debounce << 1);
    1e2a:	80 91 58 04 	lds	r24, 0x0458
    1e2e:	88 0f       	add	r24, r24
    1e30:	80 93 58 04 	sts	0x0458, r24
    FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
    1e34:	10 92 c2 04 	sts	0x04C2, r1
    if (((g_light_debounce & 0b00000111) << 5) == 0) {
    1e38:	80 91 58 04 	lds	r24, 0x0458
    1e3c:	20 e2       	ldi	r18, 0x20	; 32
    1e3e:	82 9f       	mul	r24, r18
    1e40:	c0 01       	movw	r24, r0
    1e42:	11 24       	eor	r1, r1
    1e44:	99 27       	eor	r25, r25
    1e46:	89 2b       	or	r24, r25
    1e48:	51 f4       	brne	.+20     	; 0x1e5e <process_light_off+0x3c>
static void set_substate(uint16_t st) {
  g_state |= st;
}

static void remove_substate(uint16_t st) {
  g_state &= ~st;
    1e4a:	80 91 43 12 	lds	r24, 0x1243
    1e4e:	90 91 44 12 	lds	r25, 0x1244
    1e52:	8f 7d       	andi	r24, 0xDF	; 223
    1e54:	90 93 44 12 	sts	0x1244, r25
    1e58:	80 93 43 12 	sts	0x1243, r24
  if (FLAG_DEBOUNCE_LIGHT) { // check for 3 positives based on 5ms timer
    g_light_debounce = (g_light_debounce << 1);
    FLAG_DEBOUNCE_LIGHT = 0; // reset to wait for next timer event
    if (((g_light_debounce & 0b00000111) << 5) == 0) {
      remove_substate(ST_LIGHT); // debouncing done, remove state
      PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT); // disable light
    1e5c:	46 98       	cbi	0x08, 6	; 8
    1e5e:	08 95       	ret

00001e60 <process_alarm_on>:
    }
  }
}

void process_alarm_on() {
  if (FLAG_DEBOUNCE_ALARM) { // check for 3 positives based on 5ms timer
    1e60:	80 91 c5 04 	lds	r24, 0x04C5
    1e64:	88 23       	and	r24, r24
    1e66:	69 f0       	breq	.+26     	; 0x1e82 <process_alarm_on+0x22>
    g_alarm_debounce = (g_alarm_debounce << 1) | 0x01;
    1e68:	80 91 57 04 	lds	r24, 0x0457
    1e6c:	88 0f       	add	r24, r24
    1e6e:	81 60       	ori	r24, 0x01	; 1
    1e70:	80 93 57 04 	sts	0x0457, r24
    FLAG_DEBOUNCE_ALARM = 0; // reset to wait for next timer event
    1e74:	10 92 c5 04 	sts	0x04C5, r1
    if ((g_alarm_debounce & 0b00000111) == 0b00000111) { // start alarm
    1e78:	80 91 57 04 	lds	r24, 0x0457
    1e7c:	87 70       	andi	r24, 0x07	; 7
    1e7e:	87 30       	cpi	r24, 0x07	; 7
    1e80:	09 f0       	breq	.+2      	; 0x1e84 <process_alarm_on+0x24>
    1e82:	08 95       	ret
      FLAG_ALARM_SETTLE = 0; // reset alarm settle
    1e84:	10 92 cd 04 	sts	0x04CD, r1
      g_state = ST_ALARM_SETTLE;
    1e88:	80 e0       	ldi	r24, 0x00	; 0
    1e8a:	91 e0       	ldi	r25, 0x01	; 1
    1e8c:	90 93 44 12 	sts	0x1244, r25
    1e90:	80 93 43 12 	sts	0x1243, r24
    1e94:	08 95       	ret

00001e96 <process_battery>:
// for 12v battery readout: my voltage divider ratio: 100K -- 18K = 0.1525 * Vmeasure
// of the full voltage. 
// initial voltage
// If Vref isnt exactly 5.00v, but a bit off, tweak C90_OFFSET_ADC_READING
void process_battery() {
  if (FLAG_READ_BATT) {
    1e96:	80 91 c0 04 	lds	r24, 0x04C0
    1e9a:	88 23       	and	r24, r24
    1e9c:	d9 f0       	breq	.+54     	; 0x1ed4 <process_battery+0x3e>
    if (g_adc_voltage[0] < 370) { // battery too low
    1e9e:	80 91 37 12 	lds	r24, 0x1237
    1ea2:	90 91 38 12 	lds	r25, 0x1238
    1ea6:	82 37       	cpi	r24, 0x72	; 114
    1ea8:	91 40       	sbci	r25, 0x01	; 1
    1eaa:	a8 f4       	brcc	.+42     	; 0x1ed6 <process_battery+0x40>
      // slow blink cockpit status led
      if (g_battery_blink_counter % 100 == 0) { 
    1eac:	90 91 6b 04 	lds	r25, 0x046B
    1eb0:	89 e2       	ldi	r24, 0x29	; 41
    1eb2:	98 9f       	mul	r25, r24
    1eb4:	81 2d       	mov	r24, r1
    1eb6:	11 24       	eor	r1, r1
    1eb8:	82 95       	swap	r24
    1eba:	8f 70       	andi	r24, 0x0F	; 15
    1ebc:	24 e6       	ldi	r18, 0x64	; 100
    1ebe:	82 9f       	mul	r24, r18
    1ec0:	90 19       	sub	r25, r0
    1ec2:	11 24       	eor	r1, r1
    1ec4:	91 11       	cpse	r25, r1
    1ec6:	04 c0       	rjmp	.+8      	; 0x1ed0 <process_battery+0x3a>
        PORT_C90_LIGHT_STATUS_COCKPIT ^= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
      }
    } else if (g_adc_voltage[0] > 500) { // battery too high
      // fast blink cockpit status led
      if (g_battery_blink_counter % 50 == 0) { 
        PORT_C90_LIGHT_STATUS_COCKPIT ^= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    1ec8:	88 b1       	in	r24, 0x08	; 8
    1eca:	90 e2       	ldi	r25, 0x20	; 32
    1ecc:	89 27       	eor	r24, r25
    1ece:	88 b9       	out	0x08, r24	; 8
      }
    } else { // battery Ok
      PORT_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    }
    FLAG_READ_BATT = 0;
    1ed0:	10 92 c0 04 	sts	0x04C0, r1
    1ed4:	08 95       	ret
    if (g_adc_voltage[0] < 370) { // battery too low
      // slow blink cockpit status led
      if (g_battery_blink_counter % 100 == 0) { 
        PORT_C90_LIGHT_STATUS_COCKPIT ^= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
      }
    } else if (g_adc_voltage[0] > 500) { // battery too high
    1ed6:	80 91 37 12 	lds	r24, 0x1237
    1eda:	90 91 38 12 	lds	r25, 0x1238
    1ede:	85 3f       	cpi	r24, 0xF5	; 245
    1ee0:	91 40       	sbci	r25, 0x01	; 1
    1ee2:	80 f0       	brcs	.+32     	; 0x1f04 <process_battery+0x6e>
      // fast blink cockpit status led
      if (g_battery_blink_counter % 50 == 0) { 
    1ee4:	90 91 6b 04 	lds	r25, 0x046B
    1ee8:	89 e2       	ldi	r24, 0x29	; 41
    1eea:	98 9f       	mul	r25, r24
    1eec:	81 2d       	mov	r24, r1
    1eee:	11 24       	eor	r1, r1
    1ef0:	86 95       	lsr	r24
    1ef2:	86 95       	lsr	r24
    1ef4:	86 95       	lsr	r24
    1ef6:	22 e3       	ldi	r18, 0x32	; 50
    1ef8:	82 9f       	mul	r24, r18
    1efa:	90 19       	sub	r25, r0
    1efc:	11 24       	eor	r1, r1
    1efe:	91 11       	cpse	r25, r1
    1f00:	e7 cf       	rjmp	.-50     	; 0x1ed0 <process_battery+0x3a>
    1f02:	e2 cf       	rjmp	.-60     	; 0x1ec8 <process_battery+0x32>
        PORT_C90_LIGHT_STATUS_COCKPIT ^= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
      }
    } else { // battery Ok
      PORT_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    1f04:	45 9a       	sbi	0x08, 5	; 8
    }
    FLAG_READ_BATT = 0;
    1f06:	10 92 c0 04 	sts	0x04C0, r1
    1f0a:	e4 cf       	rjmp	.-56     	; 0x1ed4 <process_battery+0x3e>

00001f0c <process_alarm_off>:
    }
  }
}

void process_alarm_off() {
  if (FLAG_DEBOUNCE_ALARM) { // check for 3 positives based on 5ms timer
    1f0c:	80 91 c5 04 	lds	r24, 0x04C5
    1f10:	88 23       	and	r24, r24
    1f12:	81 f0       	breq	.+32     	; 0x1f34 <process_alarm_off+0x28>
    g_alarm_debounce = (g_alarm_debounce << 1);
    1f14:	80 91 57 04 	lds	r24, 0x0457
    1f18:	88 0f       	add	r24, r24
    1f1a:	80 93 57 04 	sts	0x0457, r24
    FLAG_DEBOUNCE_ALARM = 0; // reset to wait for next timer event
    1f1e:	10 92 c5 04 	sts	0x04C5, r1
    if (((g_alarm_debounce & 0b00000111) << 5) == 0) {
    1f22:	80 91 57 04 	lds	r24, 0x0457
    1f26:	20 e2       	ldi	r18, 0x20	; 32
    1f28:	82 9f       	mul	r24, r18
    1f2a:	c0 01       	movw	r24, r0
    1f2c:	11 24       	eor	r1, r1
    1f2e:	99 27       	eor	r25, r25
    1f30:	89 2b       	or	r24, r25
    1f32:	09 f0       	breq	.+2      	; 0x1f36 <process_alarm_off+0x2a>
    1f34:	08 95       	ret
  }
}

// all lighting pins go low
void all_lights_off() {
  PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    1f36:	42 98       	cbi	0x08, 2	; 8
  PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    1f38:	45 98       	cbi	0x08, 5	; 8
  PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
    1f3a:	40 98       	cbi	0x08, 0	; 8
  PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
    1f3c:	43 98       	cbi	0x08, 3	; 8
  PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
    1f3e:	41 98       	cbi	0x08, 1	; 8
  PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
    1f40:	44 98       	cbi	0x08, 4	; 8
  PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
    1f42:	47 98       	cbi	0x08, 7	; 8
  PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
    1f44:	5f 98       	cbi	0x0b, 7	; 11
  PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
    1f46:	46 98       	cbi	0x08, 6	; 8
  PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
    1f48:	5e 98       	cbi	0x0b, 6	; 11
  if (FLAG_DEBOUNCE_ALARM) { // check for 3 positives based on 5ms timer
    g_alarm_debounce = (g_alarm_debounce << 1);
    FLAG_DEBOUNCE_ALARM = 0; // reset to wait for next timer event
    if (((g_alarm_debounce & 0b00000111) << 5) == 0) {
      all_lights_off();
      FLAG_ALARM_SETTLE = 0; // reset alarm settle
    1f4a:	10 92 cd 04 	sts	0x04CD, r1
      g_state = ST_SLEEP;
    1f4e:	80 e0       	ldi	r24, 0x00	; 0
    1f50:	92 e0       	ldi	r25, 0x02	; 2
    1f52:	90 93 44 12 	sts	0x1244, r25
    1f56:	80 93 43 12 	sts	0x1243, r24
    1f5a:	08 95       	ret

00001f5c <process_ign_off>:
    }
  }
}

void process_ign_off() {
  if (FLAG_DEBOUNCE_IGN) { // check for 3 positives based on 5ms timer
    1f5c:	80 91 c6 04 	lds	r24, 0x04C6
    1f60:	88 23       	and	r24, r24
    1f62:	81 f0       	breq	.+32     	; 0x1f84 <process_ign_off+0x28>
    g_ign_debounce = (g_ign_debounce << 1);
    1f64:	80 91 5b 04 	lds	r24, 0x045B
    1f68:	88 0f       	add	r24, r24
    1f6a:	80 93 5b 04 	sts	0x045B, r24
    FLAG_DEBOUNCE_IGN = 0; // reset to wait for next timer event
    1f6e:	10 92 c6 04 	sts	0x04C6, r1
    if (((g_ign_debounce & 0b00000111) << 5) == 0) {
    1f72:	80 91 5b 04 	lds	r24, 0x045B
    1f76:	20 e2       	ldi	r18, 0x20	; 32
    1f78:	82 9f       	mul	r24, r18
    1f7a:	c0 01       	movw	r24, r0
    1f7c:	11 24       	eor	r1, r1
    1f7e:	99 27       	eor	r25, r25
    1f80:	89 2b       	or	r24, r25
    1f82:	09 f0       	breq	.+2      	; 0x1f86 <process_ign_off+0x2a>
    1f84:	08 95       	ret
  }
}

// all lighting pins go low
void all_lights_off() {
  PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    1f86:	42 98       	cbi	0x08, 2	; 8
  PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    1f88:	45 98       	cbi	0x08, 5	; 8
  PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
    1f8a:	40 98       	cbi	0x08, 0	; 8
  PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
    1f8c:	43 98       	cbi	0x08, 3	; 8
  PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
    1f8e:	41 98       	cbi	0x08, 1	; 8
  PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
    1f90:	44 98       	cbi	0x08, 4	; 8
  PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
    1f92:	47 98       	cbi	0x08, 7	; 8
  PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
    1f94:	5f 98       	cbi	0x0b, 7	; 11
  PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
    1f96:	46 98       	cbi	0x08, 6	; 8
  PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
    1f98:	5e 98       	cbi	0x0b, 6	; 11
  if (FLAG_DEBOUNCE_IGN) { // check for 3 positives based on 5ms timer
    g_ign_debounce = (g_ign_debounce << 1);
    FLAG_DEBOUNCE_IGN = 0; // reset to wait for next timer event
    if (((g_ign_debounce & 0b00000111) << 5) == 0) {
      all_lights_off();
      PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER); // buzzer off
    1f9a:	5d 98       	cbi	0x0b, 5	; 11
      FLAG_SETTLE = 0; // reset settle
    1f9c:	10 92 ce 04 	sts	0x04CE, r1
      g_state = ST_SLEEP;
    1fa0:	80 e0       	ldi	r24, 0x00	; 0
    1fa2:	92 e0       	ldi	r25, 0x02	; 2
    1fa4:	90 93 44 12 	sts	0x1244, r25
    1fa8:	80 93 43 12 	sts	0x1243, r24
    1fac:	08 95       	ret

00001fae <__vector_24>:

void disable_adc() {
  ADCSRA &= ~(1 << ADEN);
}

ISR(ADC_vect) {
    1fae:	1f 92       	push	r1
    1fb0:	0f 92       	push	r0
    1fb2:	0f b6       	in	r0, 0x3f	; 63
    1fb4:	0f 92       	push	r0
    1fb6:	11 24       	eor	r1, r1
    1fb8:	0b b6       	in	r0, 0x3b	; 59
    1fba:	0f 92       	push	r0
    1fbc:	2f 93       	push	r18
    1fbe:	8f 93       	push	r24
    1fc0:	9f 93       	push	r25
    1fc2:	af 93       	push	r26
    1fc4:	bf 93       	push	r27
    1fc6:	ef 93       	push	r30
    1fc8:	ff 93       	push	r31
  // first read ADCL, then ADCH to keep it an atomic operation
  g_adc_voltage[g_adc_read_pin] = ADCL;
    1fca:	e0 91 72 04 	lds	r30, 0x0472
    1fce:	f0 e0       	ldi	r31, 0x00	; 0
    1fd0:	80 91 78 00 	lds	r24, 0x0078
    1fd4:	90 e0       	ldi	r25, 0x00	; 0
    1fd6:	ee 0f       	add	r30, r30
    1fd8:	ff 1f       	adc	r31, r31
    1fda:	e9 5c       	subi	r30, 0xC9	; 201
    1fdc:	fd 4e       	sbci	r31, 0xED	; 237
    1fde:	91 83       	std	Z+1, r25	; 0x01
    1fe0:	80 83       	st	Z, r24
  g_adc_voltage[g_adc_read_pin] = (g_adc_voltage[g_adc_read_pin] | (ADCH << 8));
    1fe2:	e0 91 72 04 	lds	r30, 0x0472
    1fe6:	f0 e0       	ldi	r31, 0x00	; 0
    1fe8:	a0 91 72 04 	lds	r26, 0x0472
    1fec:	b0 e0       	ldi	r27, 0x00	; 0
    1fee:	aa 0f       	add	r26, r26
    1ff0:	bb 1f       	adc	r27, r27
    1ff2:	a9 5c       	subi	r26, 0xC9	; 201
    1ff4:	bd 4e       	sbci	r27, 0xED	; 237
    1ff6:	8d 91       	ld	r24, X+
    1ff8:	9c 91       	ld	r25, X
    1ffa:	20 91 79 00 	lds	r18, 0x0079
    1ffe:	92 2b       	or	r25, r18
    2000:	ee 0f       	add	r30, r30
    2002:	ff 1f       	adc	r31, r31
    2004:	e9 5c       	subi	r30, 0xC9	; 201
    2006:	fd 4e       	sbci	r31, 0xED	; 237
    2008:	91 83       	std	Z+1, r25	; 0x01
    200a:	80 83       	st	Z, r24
  g_adc_voltage[g_adc_read_pin] += C90_OFFSET_ADC_READING;
    200c:	e0 91 72 04 	lds	r30, 0x0472
    2010:	f0 e0       	ldi	r31, 0x00	; 0
    2012:	ee 0f       	add	r30, r30
    2014:	ff 1f       	adc	r31, r31
    2016:	e9 5c       	subi	r30, 0xC9	; 201
    2018:	fd 4e       	sbci	r31, 0xED	; 237
    201a:	80 81       	ld	r24, Z
    201c:	91 81       	ldd	r25, Z+1	; 0x01
    201e:	01 96       	adiw	r24, 0x01	; 1
    2020:	91 83       	std	Z+1, r25	; 0x01
    2022:	80 83       	st	Z, r24
  g_adc_read_pin++;
    2024:	80 91 72 04 	lds	r24, 0x0472
    2028:	8f 5f       	subi	r24, 0xFF	; 255
    202a:	80 93 72 04 	sts	0x0472, r24
  if (g_adc_read_pin > 3) {
    202e:	80 91 72 04 	lds	r24, 0x0472
    2032:	84 30       	cpi	r24, 0x04	; 4
    2034:	10 f0       	brcs	.+4      	; 0x203a <__vector_24+0x8c>
    g_adc_read_pin = 0;
    2036:	10 92 72 04 	sts	0x0472, r1
  }
  ADMUX = (ADMUX & 0xF8) | g_adc_read_pin;
    203a:	80 91 7c 00 	lds	r24, 0x007C
    203e:	90 91 72 04 	lds	r25, 0x0472
    2042:	88 7f       	andi	r24, 0xF8	; 248
    2044:	89 2b       	or	r24, r25
    2046:	80 93 7c 00 	sts	0x007C, r24
  ADCSRA |= (1 << ADSC); // start another conversion again
    204a:	80 91 7a 00 	lds	r24, 0x007A
    204e:	80 64       	ori	r24, 0x40	; 64
    2050:	80 93 7a 00 	sts	0x007A, r24
}
    2054:	ff 91       	pop	r31
    2056:	ef 91       	pop	r30
    2058:	bf 91       	pop	r27
    205a:	af 91       	pop	r26
    205c:	9f 91       	pop	r25
    205e:	8f 91       	pop	r24
    2060:	2f 91       	pop	r18
    2062:	0f 90       	pop	r0
    2064:	0b be       	out	0x3b, r0	; 59
    2066:	0f 90       	pop	r0
    2068:	0f be       	out	0x3f, r0	; 63
    206a:	0f 90       	pop	r0
    206c:	1f 90       	pop	r1
    206e:	18 95       	reti

00002070 <__vector_16>:
  OCR3A = 68; // Set CTC compare value, approx. 4600hz: with a square wave that is a 2400hz tone
}

// runs every 5ms
ISR(TIMER0_COMPA_vect)
{
    2070:	1f 92       	push	r1
    2072:	0f 92       	push	r0
    2074:	0f b6       	in	r0, 0x3f	; 63
    2076:	0f 92       	push	r0
    2078:	11 24       	eor	r1, r1
    207a:	8f 93       	push	r24
    207c:	9f 93       	push	r25
  FLAG_DEBOUNCE_RI = 1;
    207e:	81 e0       	ldi	r24, 0x01	; 1
    2080:	80 93 c9 04 	sts	0x04C9, r24
  FLAG_DEBOUNCE_LI = 1;
    2084:	80 93 c8 04 	sts	0x04C8, r24
  FLAG_DEBOUNCE_CLAXON = 1;
    2088:	80 93 c7 04 	sts	0x04C7, r24
  FLAG_DEBOUNCE_IGN = 1;
    208c:	80 93 c6 04 	sts	0x04C6, r24
  FLAG_DEBOUNCE_BRAKE = 1;
    2090:	80 93 c4 04 	sts	0x04C4, r24
  FLAG_DEBOUNCE_PILOT = 1;
    2094:	80 93 c3 04 	sts	0x04C3, r24
  FLAG_DEBOUNCE_LIGHT = 1;
    2098:	80 93 c2 04 	sts	0x04C2, r24
  FLAG_DEBOUNCE_ALARM = 1;
    209c:	80 93 c5 04 	sts	0x04C5, r24
  FLAG_DEBOUNCE_WARNING = 1;
    20a0:	80 93 c1 04 	sts	0x04C1, r24
  FLAG_READ_BATT = 1;
    20a4:	80 93 c0 04 	sts	0x04C0, r24
  FLAG_READ_BACKPEDAL = 1;
    20a8:	80 93 bf 04 	sts	0x04BF, r24
  if (g_battery_blink_counter > 200) {
    20ac:	80 91 6b 04 	lds	r24, 0x046B
    20b0:	89 3c       	cpi	r24, 0xC9	; 201
    20b2:	10 f0       	brcs	.+4      	; 0x20b8 <__vector_16+0x48>
    g_battery_blink_counter = 0;
    20b4:	10 92 6b 04 	sts	0x046B, r1
  }
  g_battery_blink_counter++;
    20b8:	80 91 6b 04 	lds	r24, 0x046B
    20bc:	8f 5f       	subi	r24, 0xFF	; 255
    20be:	80 93 6b 04 	sts	0x046B, r24
  if (g_current_settle_time) {
    20c2:	80 91 79 04 	lds	r24, 0x0479
    20c6:	90 91 7a 04 	lds	r25, 0x047A
    20ca:	89 2b       	or	r24, r25
    20cc:	49 f0       	breq	.+18     	; 0x20e0 <__vector_16+0x70>
    g_current_settle_time--;
    20ce:	80 91 79 04 	lds	r24, 0x0479
    20d2:	90 91 7a 04 	lds	r25, 0x047A
    20d6:	01 97       	sbiw	r24, 0x01	; 1
    20d8:	90 93 7a 04 	sts	0x047A, r25
    20dc:	80 93 79 04 	sts	0x0479, r24
  }
  if (g_current_alarm_settle_time) {
    20e0:	80 91 77 04 	lds	r24, 0x0477
    20e4:	90 91 78 04 	lds	r25, 0x0478
    20e8:	89 2b       	or	r24, r25
    20ea:	49 f0       	breq	.+18     	; 0x20fe <__vector_16+0x8e>
    g_current_alarm_settle_time--;
    20ec:	80 91 77 04 	lds	r24, 0x0477
    20f0:	90 91 78 04 	lds	r25, 0x0478
    20f4:	01 97       	sbiw	r24, 0x01	; 1
    20f6:	90 93 78 04 	sts	0x0478, r25
    20fa:	80 93 77 04 	sts	0x0477, r24
  }
  if (g_music_duration) {
    20fe:	80 91 d4 04 	lds	r24, 0x04D4
    2102:	90 91 d5 04 	lds	r25, 0x04D5
    2106:	89 2b       	or	r24, r25
    2108:	49 f0       	breq	.+18     	; 0x211c <__vector_16+0xac>
    g_music_duration--;
    210a:	80 91 d4 04 	lds	r24, 0x04D4
    210e:	90 91 d5 04 	lds	r25, 0x04D5
    2112:	01 97       	sbiw	r24, 0x01	; 1
    2114:	90 93 d5 04 	sts	0x04D5, r25
    2118:	80 93 d4 04 	sts	0x04D4, r24
  }
}
    211c:	9f 91       	pop	r25
    211e:	8f 91       	pop	r24
    2120:	0f 90       	pop	r0
    2122:	0f be       	out	0x3f, r0	; 63
    2124:	0f 90       	pop	r0
    2126:	1f 90       	pop	r1
    2128:	18 95       	reti

0000212a <__vector_13>:

// indicator on/off pace, runs every 0.5 secs by default
ISR(TIMER1_COMPA_vect)
{
    212a:	1f 92       	push	r1
    212c:	0f 92       	push	r0
    212e:	0f b6       	in	r0, 0x3f	; 63
    2130:	0f 92       	push	r0
    2132:	11 24       	eor	r1, r1
    2134:	8f 93       	push	r24
    2136:	9f 93       	push	r25
  FLAG_BLINK_RI = 1;
    2138:	81 e0       	ldi	r24, 0x01	; 1
    213a:	80 93 d2 04 	sts	0x04D2, r24
  FLAG_BLINK_LI = 1;
    213e:	80 93 d1 04 	sts	0x04D1, r24
  FLAG_ALARM_BLINK = 1;
    2142:	80 93 cc 04 	sts	0x04CC, r24
  FLAG_BLINK_WARNING = 1;
    2146:	80 93 d0 04 	sts	0x04D0, r24
  FLAG_BLINK_BACKPEDAL = 1;
    214a:	80 93 cf 04 	sts	0x04CF, r24
  if (g_sleep_counter) {
    214e:	80 91 60 04 	lds	r24, 0x0460
    2152:	90 91 61 04 	lds	r25, 0x0461
    2156:	89 2b       	or	r24, r25
    2158:	49 f0       	breq	.+18     	; 0x216c <__vector_13+0x42>
    g_sleep_counter--;
    215a:	80 91 60 04 	lds	r24, 0x0460
    215e:	90 91 61 04 	lds	r25, 0x0461
    2162:	01 97       	sbiw	r24, 0x01	; 1
    2164:	90 93 61 04 	sts	0x0461, r25
    2168:	80 93 60 04 	sts	0x0460, r24
  }
  g_alarm_blink_counter++;
    216c:	80 91 6a 04 	lds	r24, 0x046A
    2170:	8f 5f       	subi	r24, 0xFF	; 255
    2172:	80 93 6a 04 	sts	0x046A, r24
}
    2176:	9f 91       	pop	r25
    2178:	8f 91       	pop	r24
    217a:	0f 90       	pop	r0
    217c:	0f be       	out	0x3f, r0	; 63
    217e:	0f 90       	pop	r0
    2180:	1f 90       	pop	r1
    2182:	18 95       	reti

00002184 <__vector_32>:

ISR(TIMER3_COMPA_vect)
{
    2184:	1f 92       	push	r1
    2186:	0f 92       	push	r0
    2188:	0f b6       	in	r0, 0x3f	; 63
    218a:	0f 92       	push	r0
    218c:	11 24       	eor	r1, r1
    218e:	8f 93       	push	r24
    2190:	9f 93       	push	r25
  // toggle buzzer pin to create a 50% duty cycle
  PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
    2192:	8b b1       	in	r24, 0x0b	; 11
    2194:	90 e2       	ldi	r25, 0x20	; 32
    2196:	89 27       	eor	r24, r25
    2198:	8b b9       	out	0x0b, r24	; 11
}
    219a:	9f 91       	pop	r25
    219c:	8f 91       	pop	r24
    219e:	0f 90       	pop	r0
    21a0:	0f be       	out	0x3f, r0	; 63
    21a2:	0f 90       	pop	r0
    21a4:	1f 90       	pop	r1
    21a6:	18 95       	reti

000021a8 <main>:
// length is normally 1, 2, 4, 8 or 16 parts of a full note
uint16_t calc_note_duration(const uint16_t length) {
  return 200*60/g_music_tempo*g_music_denominator/length;
}

int main(void) {
    21a8:	cf 93       	push	r28
    21aa:	df 93       	push	r29
    21ac:	cd b7       	in	r28, 0x3d	; 61
    21ae:	de b7       	in	r29, 0x3e	; 62
    21b0:	a0 97       	sbiw	r28, 0x20	; 32
    21b2:	0f b6       	in	r0, 0x3f	; 63
    21b4:	f8 94       	cli
    21b6:	de bf       	out	0x3e, r29	; 62
    21b8:	0f be       	out	0x3f, r0	; 63
    21ba:	cd bf       	out	0x3d, r28	; 61
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  sleep_mode();         
}

void initialize() {
  MCUCR = 0x80; // disable JTAG at runtime (2 calls in a row needed)
    21bc:	80 e8       	ldi	r24, 0x80	; 128
    21be:	85 bf       	out	0x35, r24	; 53
  MCUCR = 0x80;
    21c0:	85 bf       	out	0x35, r24	; 53
  wdt_enable(WDTO_2S);  // enable 2 sec watchdog
    21c2:	2f e0       	ldi	r18, 0x0F	; 15
    21c4:	88 e1       	ldi	r24, 0x18	; 24
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	a8 95       	wdr
    21ce:	80 93 60 00 	sts	0x0060, r24
    21d2:	0f be       	out	0x3f, r0	; 63
    21d4:	20 93 60 00 	sts	0x0060, r18
  sei(); //  enable global interrupts
    21d8:	78 94       	sei
  g_senses = 0;
}

// setup the ADC in free running mode, so we can select the read channels ourselves
void enable_adc() {
  ADMUX = (ADMUX & 0xF8) | g_adc_read_pin; // clear the bottom 3 bits before setting new pin
    21da:	80 91 7c 00 	lds	r24, 0x007C
    21de:	90 91 72 04 	lds	r25, 0x0472
    21e2:	88 7f       	andi	r24, 0xF8	; 248
    21e4:	89 2b       	or	r24, r25
    21e6:	80 93 7c 00 	sts	0x007C, r24
  ADMUX |= (1 << REFS0); // voltage reference = AVcc
    21ea:	80 91 7c 00 	lds	r24, 0x007C
    21ee:	80 64       	ori	r24, 0x40	; 64
    21f0:	80 93 7c 00 	sts	0x007C, r24
  DIDR0 = 0x0F;  // disable digital inputs for ADC0-ADC3 
    21f4:	8f e0       	ldi	r24, 0x0F	; 15
    21f6:	80 93 7e 00 	sts	0x007E, r24
  ADCSRA |= (1 << ADEN); // enable ADC
    21fa:	80 91 7a 00 	lds	r24, 0x007A
    21fe:	80 68       	ori	r24, 0x80	; 128
    2200:	80 93 7a 00 	sts	0x007A, r24
  ADCSRA |= (1 << ADPS2) | (1 << ADPS1 ) | (1 << ADPS0); // prescaler = 128
    2204:	80 91 7a 00 	lds	r24, 0x007A
    2208:	87 60       	ori	r24, 0x07	; 7
    220a:	80 93 7a 00 	sts	0x007A, r24
  ADCSRA |= (1 << ADIE); // enable interrupt
    220e:	80 91 7a 00 	lds	r24, 0x007A
    2212:	88 60       	ori	r24, 0x08	; 8
    2214:	80 93 7a 00 	sts	0x007A, r24
  ADCSRA |= (1 << ADSC); // start a conversion
    2218:	80 91 7a 00 	lds	r24, 0x007A
    221c:	80 64       	ori	r24, 0x40	; 64
    221e:	80 93 7a 00 	sts	0x007A, r24
  MCUCR = 0x80; // disable JTAG at runtime (2 calls in a row needed)
  MCUCR = 0x80;
  wdt_enable(WDTO_2S);  // enable 2 sec watchdog
  sei(); //  enable global interrupts
  enable_adc();
  g_state = ST_SLEEP; // always start in sleep mode
    2222:	80 e0       	ldi	r24, 0x00	; 0
    2224:	92 e0       	ldi	r25, 0x02	; 2
    2226:	90 93 44 12 	sts	0x1244, r25
    222a:	80 93 43 12 	sts	0x1243, r24
  g_buffer_head = g_buffer_tail = 0; // init event buffer
    222e:	10 92 7b 04 	sts	0x047B, r1
    2232:	10 92 7c 04 	sts	0x047C, r1
  // init settings
  if (eeprom_read_word(&g_rom_settings.deep_sleep_counter) != g_settings.deep_sleep_counter) {
    2236:	80 e0       	ldi	r24, 0x00	; 0
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	0e 94 06 28 	call	0x500c	; 0x500c <__eerd_word_m1284p>
    223e:	20 91 64 01 	lds	r18, 0x0164
    2242:	30 91 65 01 	lds	r19, 0x0165
    2246:	82 17       	cp	r24, r18
    2248:	93 07       	cpc	r25, r19
    224a:	21 f0       	breq	.+8      	; 0x2254 <main+0xac>
    g_settings.deep_sleep_counter = eeprom_read_word(&g_rom_settings.deep_sleep_counter);
    224c:	90 93 65 01 	sts	0x0165, r25
    2250:	80 93 64 01 	sts	0x0164, r24
  }
  if (eeprom_read_word(&g_rom_settings.settle_time) != g_settings.settle_time) {
    2254:	82 e0       	ldi	r24, 0x02	; 2
    2256:	90 e0       	ldi	r25, 0x00	; 0
    2258:	0e 94 06 28 	call	0x500c	; 0x500c <__eerd_word_m1284p>
    225c:	20 91 66 01 	lds	r18, 0x0166
    2260:	30 91 67 01 	lds	r19, 0x0167
    2264:	82 17       	cp	r24, r18
    2266:	93 07       	cpc	r25, r19
    2268:	21 f0       	breq	.+8      	; 0x2272 <main+0xca>
    g_settings.settle_time = eeprom_read_word(&g_rom_settings.settle_time);
    226a:	90 93 67 01 	sts	0x0167, r25
    226e:	80 93 66 01 	sts	0x0166, r24
  }
  if (eeprom_read_word(&g_rom_settings.alarm_settle_time) != g_settings.alarm_settle_time) {
    2272:	84 e0       	ldi	r24, 0x04	; 4
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	0e 94 06 28 	call	0x500c	; 0x500c <__eerd_word_m1284p>
    227a:	20 91 68 01 	lds	r18, 0x0168
    227e:	30 91 69 01 	lds	r19, 0x0169
    2282:	82 17       	cp	r24, r18
    2284:	93 07       	cpc	r25, r19
    2286:	21 f0       	breq	.+8      	; 0x2290 <main+0xe8>
    g_settings.alarm_settle_time = eeprom_read_word(&g_rom_settings.alarm_settle_time);
    2288:	90 93 69 01 	sts	0x0169, r25
    228c:	80 93 68 01 	sts	0x0168, r24
  }
  if (eeprom_read_byte(&g_rom_settings.indicator_sound) != g_settings.indicator_sound) {
    2290:	86 e0       	ldi	r24, 0x06	; 6
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    2298:	90 91 6a 01 	lds	r25, 0x016A
    229c:	89 13       	cpse	r24, r25
    g_settings.indicator_sound = eeprom_read_byte(&g_rom_settings.indicator_sound);
    229e:	80 93 6a 01 	sts	0x016A, r24
  }
  if (eeprom_read_word(&g_rom_settings.blink_speed) != g_settings.blink_speed) {
    22a2:	87 e0       	ldi	r24, 0x07	; 7
    22a4:	90 e0       	ldi	r25, 0x00	; 0
    22a6:	0e 94 06 28 	call	0x500c	; 0x500c <__eerd_word_m1284p>
    22aa:	20 91 6b 01 	lds	r18, 0x016B
    22ae:	30 91 6c 01 	lds	r19, 0x016C
    22b2:	82 17       	cp	r24, r18
    22b4:	93 07       	cpc	r25, r19
    22b6:	21 f0       	breq	.+8      	; 0x22c0 <main+0x118>
    g_settings.blink_speed = eeprom_read_word(&g_rom_settings.blink_speed);
    22b8:	90 93 6c 01 	sts	0x016C, r25
    22bc:	80 93 6b 01 	sts	0x016B, r24
  }
  if (eeprom_read_byte(&g_rom_settings.alarm_counter) != g_settings.alarm_counter) {
    22c0:	89 e0       	ldi	r24, 0x09	; 9
    22c2:	90 e0       	ldi	r25, 0x00	; 0
    22c4:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    22c8:	90 91 6d 01 	lds	r25, 0x016D
    22cc:	89 13       	cpse	r24, r25
    g_settings.alarm_counter = eeprom_read_byte(&g_rom_settings.alarm_counter);
    22ce:	80 93 6d 01 	sts	0x016D, r24
  }
  if (eeprom_read_byte(&g_rom_settings.alarm_trigger) != g_settings.alarm_trigger) {
    22d2:	8a e0       	ldi	r24, 0x0A	; 10
    22d4:	90 e0       	ldi	r25, 0x00	; 0
    22d6:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    22da:	90 91 6e 01 	lds	r25, 0x016E
    22de:	89 13       	cpse	r24, r25
    g_settings.alarm_trigger = eeprom_read_byte(&g_rom_settings.alarm_trigger);
    22e0:	80 93 6e 01 	sts	0x016E, r24
  }
  if (eeprom_read_byte(&g_rom_settings.alarm_trigger_counter) != g_settings.alarm_trigger_counter) {
    22e4:	8b e0       	ldi	r24, 0x0B	; 11
    22e6:	90 e0       	ldi	r25, 0x00	; 0
    22e8:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    22ec:	90 91 6f 01 	lds	r25, 0x016F
    22f0:	89 13       	cpse	r24, r25
    g_settings.alarm_trigger_counter = eeprom_read_byte(&g_rom_settings.alarm_trigger_counter);
    22f2:	80 93 6f 01 	sts	0x016F, r24
  }
  if (eeprom_read_byte(&g_rom_settings.alarm_thres_min) != g_settings.alarm_thres_min) {
    22f6:	8c e0       	ldi	r24, 0x0C	; 12
    22f8:	90 e0       	ldi	r25, 0x00	; 0
    22fa:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    22fe:	90 91 70 01 	lds	r25, 0x0170
    2302:	89 13       	cpse	r24, r25
    g_settings.alarm_thres_min = eeprom_read_byte(&g_rom_settings.alarm_thres_min);
    2304:	80 93 70 01 	sts	0x0170, r24
  }
  if (eeprom_read_word(&g_rom_settings.alarm_thres_max) != g_settings.alarm_thres_max) {
    2308:	8d e0       	ldi	r24, 0x0D	; 13
    230a:	90 e0       	ldi	r25, 0x00	; 0
    230c:	0e 94 06 28 	call	0x500c	; 0x500c <__eerd_word_m1284p>
    2310:	20 91 71 01 	lds	r18, 0x0171
    2314:	30 91 72 01 	lds	r19, 0x0172
    2318:	82 17       	cp	r24, r18
    231a:	93 07       	cpc	r25, r19
    231c:	21 f0       	breq	.+8      	; 0x2326 <main+0x17e>
    g_settings.alarm_thres_max = eeprom_read_word(&g_rom_settings.alarm_thres_max);
    231e:	90 93 72 01 	sts	0x0172, r25
    2322:	80 93 71 01 	sts	0x0171, r24
  }
  if (eeprom_read_byte(&g_rom_settings.backpedal) != g_settings.backpedal) {
    2326:	8f e0       	ldi	r24, 0x0F	; 15
    2328:	90 e0       	ldi	r25, 0x00	; 0
    232a:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    232e:	90 91 73 01 	lds	r25, 0x0173
    2332:	89 13       	cpse	r24, r25
    g_settings.backpedal = eeprom_read_byte(&g_rom_settings.backpedal);
    2334:	80 93 73 01 	sts	0x0173, r24
  }
  if (eeprom_read_word(&g_rom_settings.backpedal_thres_min) != g_settings.backpedal_thres_min) {
    2338:	80 e1       	ldi	r24, 0x10	; 16
    233a:	90 e0       	ldi	r25, 0x00	; 0
    233c:	0e 94 06 28 	call	0x500c	; 0x500c <__eerd_word_m1284p>
    2340:	20 91 74 01 	lds	r18, 0x0174
    2344:	30 91 75 01 	lds	r19, 0x0175
    2348:	82 17       	cp	r24, r18
    234a:	93 07       	cpc	r25, r19
    234c:	21 f0       	breq	.+8      	; 0x2356 <main+0x1ae>
    g_settings.backpedal_thres_min = eeprom_read_word(&g_rom_settings.backpedal_thres_min);
    234e:	90 93 75 01 	sts	0x0175, r25
    2352:	80 93 74 01 	sts	0x0174, r24
  }
  if (eeprom_read_byte(&g_rom_settings.startup_sound) != g_settings.startup_sound) {
    2356:	82 e1       	ldi	r24, 0x12	; 18
    2358:	90 e0       	ldi	r25, 0x00	; 0
    235a:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    235e:	90 91 76 01 	lds	r25, 0x0176
    2362:	89 13       	cpse	r24, r25
    g_settings.startup_sound = eeprom_read_byte(&g_rom_settings.startup_sound);
    2364:	80 93 76 01 	sts	0x0176, r24
  }
  if (eeprom_read_byte(&g_rom_settings.alarm_sound) != g_settings.alarm_sound) {
    2368:	83 e1       	ldi	r24, 0x13	; 19
    236a:	90 e0       	ldi	r25, 0x00	; 0
    236c:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <__eerd_byte_m1284p>
    2370:	90 91 77 01 	lds	r25, 0x0177
    2374:	89 13       	cpse	r24, r25
    g_settings.alarm_sound = eeprom_read_byte(&g_rom_settings.alarm_sound);
    2376:	80 93 77 01 	sts	0x0177, r24
  }
  char passwd[32];
  eeprom_read_block((void*)passwd, (const void*)g_rom_settings.passwd, 32);
    237a:	40 e2       	ldi	r20, 0x20	; 32
    237c:	50 e0       	ldi	r21, 0x00	; 0
    237e:	64 e1       	ldi	r22, 0x14	; 20
    2380:	70 e0       	ldi	r23, 0x00	; 0
    2382:	ce 01       	movw	r24, r28
    2384:	01 96       	adiw	r24, 0x01	; 1
    2386:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <__eerd_block_m1284p>
  if (strcmp(passwd, g_settings.passwd) != 0) {
    238a:	68 e7       	ldi	r22, 0x78	; 120
    238c:	71 e0       	ldi	r23, 0x01	; 1
    238e:	ce 01       	movw	r24, r28
    2390:	01 96       	adiw	r24, 0x01	; 1
    2392:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    2396:	89 2b       	or	r24, r25
    2398:	39 f0       	breq	.+14     	; 0x23a8 <main+0x200>
    strcpy(g_settings.passwd, passwd);
    239a:	be 01       	movw	r22, r28
    239c:	6f 5f       	subi	r22, 0xFF	; 255
    239e:	7f 4f       	sbci	r23, 0xFF	; 255
    23a0:	88 e7       	ldi	r24, 0x78	; 120
    23a2:	91 e0       	ldi	r25, 0x01	; 1
    23a4:	0e 94 a4 27 	call	0x4f48	; 0x4f48 <strcpy>
  }
  g_sleep_counter = g_settings.deep_sleep_counter;
    23a8:	80 91 64 01 	lds	r24, 0x0164
    23ac:	90 91 65 01 	lds	r25, 0x0165
    23b0:	90 93 61 04 	sts	0x0461, r25
    23b4:	80 93 60 04 	sts	0x0460, r24
  reset_ports();
    23b8:	65 da       	rcall	.-2870   	; 0x1884 <reset_ports>
    23ba:	85 b5       	in	r24, 0x25	; 37
}

void start_sense_timer()
{
  // Configure timer 0 (8-bit) for CTC mode (Clear on Timer Compare)
  TCCR0B |= (1 << WGM02); // CTC Mode
    23bc:	88 60       	ori	r24, 0x08	; 8
    23be:	85 bd       	out	0x25, r24	; 37
    23c0:	84 b5       	in	r24, 0x24	; 36
  TCCR0A |= (1 << WGM01) | (0 << WGM00); // CTC Mode
    23c2:	82 60       	ori	r24, 0x02	; 2
    23c4:	84 bd       	out	0x24, r24	; 36
    23c6:	85 b5       	in	r24, 0x25	; 37
  TCCR0B |= ((1 << CS00) | (1 << CS02)); // prescale 1024
    23c8:	85 60       	ori	r24, 0x05	; 5
    23ca:	85 bd       	out	0x25, r24	; 37
    23cc:	85 b5       	in	r24, 0x25	; 37
  TCCR0B &= ~(1 << CS01); // prescale 1024
    23ce:	8d 7f       	andi	r24, 0xFD	; 253
    23d0:	85 bd       	out	0x25, r24	; 37
    23d2:	80 91 6e 00 	lds	r24, 0x006E
  TIMSK0 |= (1 << OCIE0A); // Enable CTC interrupt
    23d6:	82 60       	ori	r24, 0x02	; 2
    23d8:	80 93 6e 00 	sts	0x006E, r24
    23dc:	81 e6       	ldi	r24, 0x61	; 97
  OCR0A = 97; // Set CTC compare value, approx. 5 ms -> 200 times/sec
    23de:	87 bd       	out	0x27, r24	; 39
    23e0:	80 91 80 00 	lds	r24, 0x0080
}

void start_blink_timer()
{
  // Configure timer 1 (16-bit) for CTC mode (Clear on Timer Compare)
  TCCR1A &= ~((1 << WGM11) | (1 << WGM10)); // CTC Mode
    23e4:	8c 7f       	andi	r24, 0xFC	; 252
    23e6:	80 93 80 00 	sts	0x0080, r24
    23ea:	80 91 81 00 	lds	r24, 0x0081
  TCCR1B |= (1 << WGM12); // CTC Mode
    23ee:	88 60       	ori	r24, 0x08	; 8
    23f0:	80 93 81 00 	sts	0x0081, r24
    23f4:	80 91 81 00 	lds	r24, 0x0081
  TCCR1B |= ((1 << CS10) | (1 << CS12)); // prescale 1024
    23f8:	85 60       	ori	r24, 0x05	; 5
    23fa:	80 93 81 00 	sts	0x0081, r24
    23fe:	80 91 81 00 	lds	r24, 0x0081
  TCCR1B &= ~(1 << CS11); // prescale 1024
    2402:	8d 7f       	andi	r24, 0xFD	; 253
    2404:	80 93 81 00 	sts	0x0081, r24
    2408:	80 91 6f 00 	lds	r24, 0x006F
  TIMSK1 |= (1 << OCIE1A); // Enable Compare A interrupt
    240c:	82 60       	ori	r24, 0x02	; 2
    240e:	80 93 6f 00 	sts	0x006F, r24
    2412:	80 91 6b 01 	lds	r24, 0x016B
  OCR1A = g_settings.blink_speed; // Set CTC compare value, default approx. 0.5 secs
    2416:	90 91 6c 01 	lds	r25, 0x016C
    241a:	90 93 89 00 	sts	0x0089, r25
    241e:	80 93 88 00 	sts	0x0088, r24
    2422:	80 91 90 00 	lds	r24, 0x0090
}

void start_buzzer_timer(uint8_t isr_on) {
  // Configure timer 3 (16-bit) for CTC mode (Clear on Timer Compare)
  TCCR3A &= ~((1 << WGM31) | (1 << WGM30)); // CTC Mode
    2426:	8c 7f       	andi	r24, 0xFC	; 252
    2428:	80 93 90 00 	sts	0x0090, r24
    242c:	80 91 91 00 	lds	r24, 0x0091
  TCCR3B |= (1 << WGM32); // CTC Mode
    2430:	88 60       	ori	r24, 0x08	; 8
    2432:	80 93 91 00 	sts	0x0091, r24
    2436:	80 91 91 00 	lds	r24, 0x0091
  TCCR3B |= ((1 << CS31) | (1 << CS30)); // prescale 64
    243a:	83 60       	ori	r24, 0x03	; 3
    243c:	80 93 91 00 	sts	0x0091, r24
    2440:	80 91 91 00 	lds	r24, 0x0091
  TCCR3B &= ~(1 << CS32); // prescale 64
    2444:	8b 7f       	andi	r24, 0xFB	; 251
    2446:	80 93 91 00 	sts	0x0091, r24
    244a:	84 e4       	ldi	r24, 0x44	; 68
  if (isr_on) {
    TIMSK3 |= (1 << OCIE3A); // Enable Compare A interrupt
  }
  OCR3A = 68; // Set CTC compare value, approx. 4600hz: with a square wave that is a 2400hz tone
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	90 93 99 00 	sts	0x0099, r25
    2452:	80 93 98 00 	sts	0x0098, r24
    2456:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <uart_init>
  g_sleep_counter = g_settings.deep_sleep_counter;
  reset_ports();
  start_sense_timer();
  start_blink_timer();
  start_buzzer_timer(0);
  uart_init();
    245a:	6b e4       	ldi	r22, 0x4B	; 75
  command_init(command_usart_input, command_usart_output);
    245c:	74 e2       	ldi	r23, 0x24	; 36
    245e:	8b e0       	ldi	r24, 0x0B	; 11
    2460:	94 e2       	ldi	r25, 0x24	; 36
    2462:	0e 94 a6 1c 	call	0x394c	; 0x394c <command_init>
    2466:	0e 94 e8 1e 	call	0x3dd0	; 0x3dd0 <register_commands>
  register_commands();
    246a:	69 e0       	ldi	r22, 0x09	; 9
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    246c:	c6 2e       	mov	r12, r22
    246e:	78 e0       	ldi	r23, 0x08	; 8
    2470:	d7 2e       	mov	r13, r23
    2472:	e9 e9       	ldi	r30, 0x99	; 153
      // check voltage and activate according sound
      g_music_duration = 0;
      // check for random startup song
      if (song_idx == 0) {
        srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda random seed
        song_idx = 2 + (uint8_t)(rand() / (RAND_MAX / 5));
    2474:	8e 2e       	mov	r8, r30
    2476:	e9 e1       	ldi	r30, 0x19	; 25
    2478:	9e 2e       	mov	r9, r30
    247a:	f0 ee       	ldi	r31, 0xE0	; 224

// duration of note based on the 5ms timer counter
// 200x 5ms ticks * 60sec/tempo in bmp * (beat note type / length)
// length is normally 1, 2, 4, 8 or 16 parts of a full note
uint16_t calc_note_duration(const uint16_t length) {
  return 200*60/g_music_tempo*g_music_denominator/length;
    247c:	2f 2e       	mov	r2, r31
    247e:	fe e2       	ldi	r31, 0x2E	; 46
    2480:	3f 2e       	mov	r3, r31
    2482:	a5 e5       	ldi	r26, 0x55	; 85
    if (!FLAG_ALARM_SETTLE) { // first time in alarm settle mode
      uint8_t song_idx = g_settings.alarm_sound;
      // check for random startup song
      if (song_idx == 0) {
        srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda random seed
        song_idx = 1 + (uint8_t)(rand() / (RAND_MAX / 6));
    2484:	4a 2e       	mov	r4, r26
    2486:	a5 e1       	ldi	r26, 0x15	; 21
    2488:	5a 2e       	mov	r5, r26
    248a:	61 2c       	mov	r6, r1
        PORT_C90_CLAXON ^= (1 << PIN_C90_CLAXON);
        g_alarm_counter--;
        if (!g_alarm_counter) {
          all_lights_off();
          FLAG_ALARM_TRIGGER = 0; // reset alarm trigger
          g_state = ST_ALARM_SETTLE; // go back to new alarm settle mode
    248c:	77 24       	eor	r7, r7
    248e:	73 94       	inc	r7
    2490:	0e 94 af 1c 	call	0x395e	; 0x395e <command_process>
}

int main(void) {
  initialize();
  while(1) {
    command_process();
    2494:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_brake() {
  // pin senses
  if ((g_senses & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
    2498:	90 91 2c 10 	lds	r25, 0x102C
    249c:	84 ff       	sbrs	r24, 4
    249e:	04 c0       	rjmp	.+8      	; 0x24a8 <main+0x300>
    24a0:	18 9b       	sbis	0x03, 0	; 3
    if (~STATUS_C90_SENSE_BRAKE) {
    24a2:	0f c6       	rjmp	.+3102   	; 0x30c2 <main+0xf1a>
    24a4:	18 99       	sbic	0x03, 0	; 3
      set_event(EV_BRAKE_ON);
    }
    if (STATUS_C90_SENSE_BRAKE) {
    24a6:	ed c5       	rjmp	.+3034   	; 0x3082 <main+0xeda>
    24a8:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_BRAKE_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
    24ac:	90 91 40 12 	lds	r25, 0x1240
    24b0:	84 ff       	sbrs	r24, 4
    24b2:	24 c0       	rjmp	.+72     	; 0x24fc <main+0x354>
    24b4:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
    24b8:	90 91 42 12 	lds	r25, 0x1242
    24bc:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    24c0:	f0 e0       	ldi	r31, 0x00	; 0
    24c2:	e3 58       	subi	r30, 0x83	; 131
    24c4:	fb 4f       	sbci	r31, 0xFB	; 251
    24c6:	84 fd       	sbrc	r24, 4
      set_event(EV_BRAKE_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
    if ((g_dyn_senses_status & FLAG_SENSE_BRAKE) == FLAG_SENSE_BRAKE) {
    24c8:	dd c4       	rjmp	.+2490   	; 0x2e84 <main+0xcdc>
    24ca:	d0 82       	st	Z, r13
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    24cc:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    24d0:	8f 5f       	subi	r24, 0xFF	; 255
    24d2:	80 93 7c 04 	sts	0x047C, r24
    24d6:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    24da:	80 34       	cpi	r24, 0x40	; 64
    24dc:	10 f0       	brcs	.+4      	; 0x24e2 <main+0x33a>
    24de:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    24e2:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    24e6:	80 91 7b 04 	lds	r24, 0x047B
    24ea:	98 17       	cp	r25, r24
    24ec:	09 f4       	brne	.+2      	; 0x24f0 <main+0x348>
    24ee:	75 c5       	rjmp	.+2794   	; 0x2fda <main+0xe32>
    24f0:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    24f4:	80 34       	cpi	r24, 0x40	; 64
    24f6:	10 f0       	brcs	.+4      	; 0x24fc <main+0x354>
    24f8:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    24fc:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_claxon() {
  // pin senses
  if ((g_senses & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
    2500:	90 91 2c 10 	lds	r25, 0x102C
    2504:	87 ff       	sbrs	r24, 7
    2506:	04 c0       	rjmp	.+8      	; 0x2510 <main+0x368>
    2508:	1b 9b       	sbis	0x03, 3	; 3
    if (~STATUS_C90_SENSE_CLAXON) {
    250a:	94 c5       	rjmp	.+2856   	; 0x3034 <main+0xe8c>
    250c:	1b 99       	sbic	0x03, 3	; 3
      set_event(EV_CLAXON_ON);
    }
    if (STATUS_C90_SENSE_CLAXON) {
    250e:	71 c5       	rjmp	.+2786   	; 0x2ff2 <main+0xe4a>
    2510:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_CLAXON_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
    2514:	90 91 40 12 	lds	r25, 0x1240
    2518:	87 ff       	sbrs	r24, 7
    251a:	25 c0       	rjmp	.+74     	; 0x2566 <main+0x3be>
    251c:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
    2520:	90 91 42 12 	lds	r25, 0x1242
    2524:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2528:	f0 e0       	ldi	r31, 0x00	; 0
    252a:	e3 58       	subi	r30, 0x83	; 131
    252c:	fb 4f       	sbci	r31, 0xFB	; 251
    252e:	87 fd       	sbrc	r24, 7
      set_event(EV_CLAXON_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
    if ((g_dyn_senses_status & FLAG_SENSE_CLAXON) == FLAG_SENSE_CLAXON) {
    2530:	ab c4       	rjmp	.+2390   	; 0x2e88 <main+0xce0>
    2532:	86 e0       	ldi	r24, 0x06	; 6
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2534:	80 83       	st	Z, r24
    2536:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    253a:	8f 5f       	subi	r24, 0xFF	; 255
    253c:	80 93 7c 04 	sts	0x047C, r24
    2540:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    2544:	80 34       	cpi	r24, 0x40	; 64
    2546:	10 f0       	brcs	.+4      	; 0x254c <main+0x3a4>
    2548:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    254c:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    2550:	80 91 7b 04 	lds	r24, 0x047B
    2554:	98 17       	cp	r25, r24
    2556:	09 f4       	brne	.+2      	; 0x255a <main+0x3b2>
    2558:	46 c5       	rjmp	.+2700   	; 0x2fe6 <main+0xe3e>
    255a:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    255e:	80 34       	cpi	r24, 0x40	; 64
    2560:	10 f0       	brcs	.+4      	; 0x2566 <main+0x3be>
    2562:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    2566:	80 91 2b 10 	lds	r24, 0x102B
  return ((g_state & (ST_ALARM_SETTLE)) == g_state);
}

void check_ri() {
  // pin senses
  if ((g_senses & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) {
    256a:	90 91 2c 10 	lds	r25, 0x102C
    256e:	80 ff       	sbrs	r24, 0
    2570:	04 c0       	rjmp	.+8      	; 0x257a <main+0x3d2>
    2572:	04 9b       	sbis	0x00, 4	; 0
    if (~STATUS_C90_SENSE_LIGHT_RI) { // low, RI on
    2574:	0e c6       	rjmp	.+3100   	; 0x3192 <main+0xfea>
    2576:	04 99       	sbic	0x00, 4	; 0
      set_event(EV_RI_ON);
    }
    if (STATUS_C90_SENSE_LIGHT_RI) { // RI off
    2578:	e5 c5       	rjmp	.+3018   	; 0x3144 <main+0xf9c>
    257a:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_RI_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) {
    257e:	90 91 40 12 	lds	r25, 0x1240
    2582:	80 ff       	sbrs	r24, 0
    2584:	25 c0       	rjmp	.+74     	; 0x25d0 <main+0x428>
    2586:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) { // high, RI off
    258a:	90 91 42 12 	lds	r25, 0x1242
    258e:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2592:	f0 e0       	ldi	r31, 0x00	; 0
    2594:	e3 58       	subi	r30, 0x83	; 131
    2596:	fb 4f       	sbci	r31, 0xFB	; 251
    2598:	80 fd       	sbrc	r24, 0
      set_event(EV_RI_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) {
    if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_RI) == FLAG_SENSE_LIGHT_RI) { // high, RI off
    259a:	78 c4       	rjmp	.+2288   	; 0x2e8c <main+0xce4>
    259c:	82 e0       	ldi	r24, 0x02	; 2
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    259e:	80 83       	st	Z, r24
    25a0:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    25a4:	8f 5f       	subi	r24, 0xFF	; 255
    25a6:	80 93 7c 04 	sts	0x047C, r24
    25aa:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    25ae:	80 34       	cpi	r24, 0x40	; 64
    25b0:	10 f0       	brcs	.+4      	; 0x25b6 <main+0x40e>
    25b2:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    25b6:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    25ba:	80 91 7b 04 	lds	r24, 0x047B
    25be:	98 17       	cp	r25, r24
    25c0:	09 f4       	brne	.+2      	; 0x25c4 <main+0x41c>
    25c2:	59 c5       	rjmp	.+2738   	; 0x3076 <main+0xece>
    25c4:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    25c8:	80 34       	cpi	r24, 0x40	; 64
    25ca:	10 f0       	brcs	.+4      	; 0x25d0 <main+0x428>
    25cc:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    25d0:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_li() {
  // pin senses
  if ((g_senses & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) {
    25d4:	90 91 2c 10 	lds	r25, 0x102C
    25d8:	81 ff       	sbrs	r24, 1
    25da:	04 c0       	rjmp	.+8      	; 0x25e4 <main+0x43c>
    25dc:	05 9b       	sbis	0x00, 5	; 0
    if (~STATUS_C90_SENSE_LIGHT_LI) { // low, LI on
    25de:	fa c5       	rjmp	.+3060   	; 0x31d4 <main+0x102c>
    25e0:	05 99       	sbic	0x00, 5	; 0
      set_event(EV_LI_ON);
    }
    if (STATUS_C90_SENSE_LIGHT_LI) { // LI off
    25e2:	8f c5       	rjmp	.+2846   	; 0x3102 <main+0xf5a>
    25e4:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_LI_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) {
    25e8:	90 91 40 12 	lds	r25, 0x1240
    25ec:	81 ff       	sbrs	r24, 1
    25ee:	25 c0       	rjmp	.+74     	; 0x263a <main+0x492>
    25f0:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) { // high, LI off
    25f4:	90 91 42 12 	lds	r25, 0x1242
    25f8:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    25fc:	f0 e0       	ldi	r31, 0x00	; 0
    25fe:	e3 58       	subi	r30, 0x83	; 131
    2600:	fb 4f       	sbci	r31, 0xFB	; 251
    2602:	81 fd       	sbrc	r24, 1
      set_event(EV_LI_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) {
    if ((g_dyn_senses_status & FLAG_SENSE_LIGHT_LI) == FLAG_SENSE_LIGHT_LI) { // high, LI off
    2604:	45 c4       	rjmp	.+2186   	; 0x2e90 <main+0xce8>
    2606:	83 e0       	ldi	r24, 0x03	; 3
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2608:	80 83       	st	Z, r24
    260a:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    260e:	8f 5f       	subi	r24, 0xFF	; 255
    2610:	80 93 7c 04 	sts	0x047C, r24
    2614:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    2618:	80 34       	cpi	r24, 0x40	; 64
    261a:	10 f0       	brcs	.+4      	; 0x2620 <main+0x478>
    261c:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    2620:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    2624:	80 91 7b 04 	lds	r24, 0x047B
    2628:	98 17       	cp	r25, r24
    262a:	09 f4       	brne	.+2      	; 0x262e <main+0x486>
    262c:	ac c5       	rjmp	.+2904   	; 0x3186 <main+0xfde>
    262e:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    2632:	80 34       	cpi	r24, 0x40	; 64
    2634:	10 f0       	brcs	.+4      	; 0x263a <main+0x492>
    2636:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    263a:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_light() {
  // pin senses
  if ((g_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
    263e:	90 91 2c 10 	lds	r25, 0x102C
    2642:	83 ff       	sbrs	r24, 3
    2644:	23 c0       	rjmp	.+70     	; 0x268c <main+0x4e4>
    2646:	07 99       	sbic	0x00, 7	; 0
    if (~STATUS_C90_SENSE_LIGHT) {
    2648:	1f c0       	rjmp	.+62     	; 0x2688 <main+0x4e0>
    264a:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    264e:	f0 e0       	ldi	r31, 0x00	; 0
    2650:	e3 58       	subi	r30, 0x83	; 131
    2652:	fb 4f       	sbci	r31, 0xFB	; 251
    2654:	8c e0       	ldi	r24, 0x0C	; 12
    2656:	80 83       	st	Z, r24
    2658:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    265c:	8f 5f       	subi	r24, 0xFF	; 255
    265e:	80 93 7c 04 	sts	0x047C, r24
    2662:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    2666:	80 34       	cpi	r24, 0x40	; 64
    2668:	10 f0       	brcs	.+4      	; 0x266e <main+0x4c6>
    266a:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    266e:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    2672:	80 91 7b 04 	lds	r24, 0x047B
    2676:	98 17       	cp	r25, r24
    2678:	09 f4       	brne	.+2      	; 0x267c <main+0x4d4>
    267a:	ed c6       	rjmp	.+3546   	; 0x3456 <main+0x12ae>
    267c:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    2680:	80 34       	cpi	r24, 0x40	; 64
    2682:	10 f0       	brcs	.+4      	; 0x2688 <main+0x4e0>
    2684:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    2688:	07 99       	sbic	0x00, 7	; 0
  // pin senses
  if ((g_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
    if (~STATUS_C90_SENSE_LIGHT) {
      set_event(EV_LIGHT_ON);
    }
    if (STATUS_C90_SENSE_LIGHT) {
    268a:	f4 c6       	rjmp	.+3560   	; 0x3474 <main+0x12cc>
    268c:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_LIGHT_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
    2690:	90 91 40 12 	lds	r25, 0x1240
    2694:	83 ff       	sbrs	r24, 3
    2696:	25 c0       	rjmp	.+74     	; 0x26e2 <main+0x53a>
    2698:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
    269c:	90 91 42 12 	lds	r25, 0x1242
    26a0:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    26a4:	f0 e0       	ldi	r31, 0x00	; 0
    26a6:	e3 58       	subi	r30, 0x83	; 131
    26a8:	fb 4f       	sbci	r31, 0xFB	; 251
    26aa:	83 fd       	sbrc	r24, 3
      set_event(EV_LIGHT_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
    if ((g_dyn_senses_status & FLAG_SENSE_LIGHT) == FLAG_SENSE_LIGHT) {
    26ac:	f3 c3       	rjmp	.+2022   	; 0x2e94 <main+0xcec>
    26ae:	8c e0       	ldi	r24, 0x0C	; 12
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    26b0:	80 83       	st	Z, r24
    26b2:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    26b6:	8f 5f       	subi	r24, 0xFF	; 255
    26b8:	80 93 7c 04 	sts	0x047C, r24
    26bc:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    26c0:	80 34       	cpi	r24, 0x40	; 64
    26c2:	10 f0       	brcs	.+4      	; 0x26c8 <main+0x520>
    26c4:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    26c8:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    26cc:	80 91 7b 04 	lds	r24, 0x047B
    26d0:	98 17       	cp	r25, r24
    26d2:	09 f4       	brne	.+2      	; 0x26d6 <main+0x52e>
    26d4:	a6 c5       	rjmp	.+2892   	; 0x3222 <main+0x107a>
    26d6:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    26da:	80 34       	cpi	r24, 0x40	; 64
    26dc:	10 f0       	brcs	.+4      	; 0x26e2 <main+0x53a>
    26de:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    26e2:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_pilot() {
  // pin senses
  if ((g_senses & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
    26e6:	90 91 2c 10 	lds	r25, 0x102C
    26ea:	82 ff       	sbrs	r24, 2
    26ec:	04 c0       	rjmp	.+8      	; 0x26f6 <main+0x54e>
    26ee:	06 9b       	sbis	0x00, 6	; 0
    if (~STATUS_C90_SENSE_PILOT) {
    26f0:	c5 c5       	rjmp	.+2954   	; 0x327c <main+0x10d4>
    26f2:	06 99       	sbic	0x00, 6	; 0
      set_event(EV_PILOT_ON);
    }
    if (STATUS_C90_SENSE_PILOT) {
    26f4:	a2 c5       	rjmp	.+2884   	; 0x323a <main+0x1092>
    26f6:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_PILOT_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
    26fa:	90 91 40 12 	lds	r25, 0x1240
    26fe:	82 ff       	sbrs	r24, 2
    2700:	25 c0       	rjmp	.+74     	; 0x274c <main+0x5a4>
    2702:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
    2706:	90 91 42 12 	lds	r25, 0x1242
    270a:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    270e:	f0 e0       	ldi	r31, 0x00	; 0
    2710:	e3 58       	subi	r30, 0x83	; 131
    2712:	fb 4f       	sbci	r31, 0xFB	; 251
    2714:	82 fd       	sbrc	r24, 2
      set_event(EV_PILOT_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
    if ((g_dyn_senses_status & FLAG_SENSE_PILOT) == FLAG_SENSE_PILOT) {
    2716:	c0 c3       	rjmp	.+1920   	; 0x2e98 <main+0xcf0>
    2718:	8a e0       	ldi	r24, 0x0A	; 10
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    271a:	80 83       	st	Z, r24
    271c:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    2720:	8f 5f       	subi	r24, 0xFF	; 255
    2722:	80 93 7c 04 	sts	0x047C, r24
    2726:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    272a:	80 34       	cpi	r24, 0x40	; 64
    272c:	10 f0       	brcs	.+4      	; 0x2732 <main+0x58a>
    272e:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    2732:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    2736:	80 91 7b 04 	lds	r24, 0x047B
    273a:	98 17       	cp	r25, r24
    273c:	09 f4       	brne	.+2      	; 0x2740 <main+0x598>
    273e:	77 c5       	rjmp	.+2798   	; 0x322e <main+0x1086>
    2740:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    2744:	80 34       	cpi	r24, 0x40	; 64
    2746:	10 f0       	brcs	.+4      	; 0x274c <main+0x5a4>
    2748:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    274c:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_ign() {
  // pin senses
  if ((g_senses & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
    2750:	90 91 2c 10 	lds	r25, 0x102C
    2754:	86 ff       	sbrs	r24, 6
    2756:	04 c0       	rjmp	.+8      	; 0x2760 <main+0x5b8>
    2758:	1a 9b       	sbis	0x03, 2	; 3
    if (~STATUS_C90_SENSE_IGN) {
    275a:	d8 c5       	rjmp	.+2992   	; 0x330c <main+0x1164>
    275c:	1a 99       	sbic	0x03, 2	; 3
      set_event(EV_IGN_ON);
    }
    if (STATUS_C90_SENSE_IGN) {
    275e:	af c5       	rjmp	.+2910   	; 0x32be <main+0x1116>
    2760:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_IGN_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
    2764:	90 91 40 12 	lds	r25, 0x1240
    2768:	86 ff       	sbrs	r24, 6
    276a:	25 c0       	rjmp	.+74     	; 0x27b6 <main+0x60e>
    276c:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
    2770:	90 91 42 12 	lds	r25, 0x1242
    2774:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2778:	f0 e0       	ldi	r31, 0x00	; 0
    277a:	e3 58       	subi	r30, 0x83	; 131
    277c:	fb 4f       	sbci	r31, 0xFB	; 251
    277e:	86 fd       	sbrc	r24, 6
      set_event(EV_IGN_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
    if ((g_dyn_senses_status & FLAG_SENSE_IGN) == FLAG_SENSE_IGN) {
    2780:	8d c3       	rjmp	.+1818   	; 0x2e9c <main+0xcf4>
    2782:	82 e1       	ldi	r24, 0x12	; 18
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2784:	80 83       	st	Z, r24
    2786:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    278a:	8f 5f       	subi	r24, 0xFF	; 255
    278c:	80 93 7c 04 	sts	0x047C, r24
    2790:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    2794:	80 34       	cpi	r24, 0x40	; 64
    2796:	10 f0       	brcs	.+4      	; 0x279c <main+0x5f4>
    2798:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    279c:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    27a0:	80 91 7b 04 	lds	r24, 0x047B
    27a4:	98 17       	cp	r25, r24
    27a6:	09 f4       	brne	.+2      	; 0x27aa <main+0x602>
    27a8:	36 c5       	rjmp	.+2668   	; 0x3216 <main+0x106e>
    27aa:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    27ae:	80 34       	cpi	r24, 0x40	; 64
    27b0:	10 f0       	brcs	.+4      	; 0x27b6 <main+0x60e>
    27b2:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    27b6:	80 91 43 12 	lds	r24, 0x1243
    }
  }
}

void check_settle() {
  if (g_state == ST_SETTLE) {
    27ba:	90 91 44 12 	lds	r25, 0x1244
    27be:	81 15       	cp	r24, r1
    27c0:	94 40       	sbci	r25, 0x04	; 4
    27c2:	09 f4       	brne	.+2      	; 0x27c6 <main+0x61e>
    27c4:	ba c2       	rjmp	.+1396   	; 0x2d3a <main+0xb92>
    27c6:	80 91 ca 04 	lds	r24, 0x04CA
  // toggle buzzer pin to create a 50% duty cycle
  PORT_C90_BUZZER ^= (1 << PIN_C90_BUZZER);
}

void check_sound() {
  if (FLAG_MUSIC) {
    27ca:	88 23       	and	r24, r24
    27cc:	09 f4       	brne	.+2      	; 0x27d0 <main+0x628>
    27ce:	55 c0       	rjmp	.+170    	; 0x287a <main+0x6d2>
    27d0:	80 91 d4 04 	lds	r24, 0x04D4
    if (!g_music_duration) {
    27d4:	90 91 d5 04 	lds	r25, 0x04D5
    27d8:	89 2b       	or	r24, r25
    27da:	09 f0       	breq	.+2      	; 0x27de <main+0x636>
    27dc:	4e c0       	rjmp	.+156    	; 0x287a <main+0x6d2>
    27de:	80 91 73 04 	lds	r24, 0x0473
      if (pgm_read_word(g_current_music)) { // get note data until MUSIC_END
    27e2:	90 91 74 04 	lds	r25, 0x0474
    27e6:	fc 01       	movw	r30, r24
    27e8:	25 91       	lpm	r18, Z+
    27ea:	34 91       	lpm	r19, Z
    27ec:	21 15       	cp	r18, r1
    27ee:	31 05       	cpc	r19, r1
    27f0:	09 f4       	brne	.+2      	; 0x27f4 <main+0x64c>
    27f2:	bf c3       	rjmp	.+1918   	; 0x2f72 <main+0xdca>
    27f4:	40 91 75 04 	lds	r20, 0x0475
        if (g_current_music == g_selected_music) { // still at start: first byte is the tempo
    27f8:	50 91 76 04 	lds	r21, 0x0476
    27fc:	84 17       	cp	r24, r20
    27fe:	95 07       	cpc	r25, r21
    2800:	09 f4       	brne	.+2      	; 0x2804 <main+0x65c>
    2802:	79 c6       	rjmp	.+3314   	; 0x34f6 <main+0x134e>
    2804:	60 91 d3 04 	lds	r22, 0x04D3
    2808:	9c 01       	movw	r18, r24
    280a:	fc 01       	movw	r30, r24
          g_music_tempo = pgm_read_word(g_current_music);
          g_current_music++;
        }
        g_music_duration = calc_note_duration(pgm_read_word(g_current_music));
    280c:	e5 90       	lpm	r14, Z+
    280e:	f4 90       	lpm	r15, Z
    2810:	70 e0       	ldi	r23, 0x00	; 0

// duration of note based on the 5ms timer counter
// 200x 5ms ticks * 60sec/tempo in bmp * (beat note type / length)
// length is normally 1, 2, 4, 8 or 16 parts of a full note
uint16_t calc_note_duration(const uint16_t length) {
  return 200*60/g_music_tempo*g_music_denominator/length;
    2812:	c1 01       	movw	r24, r2
    2814:	0e 94 96 24 	call	0x492c	; 0x492c <__divmodhi4>
    2818:	cb 01       	movw	r24, r22
    281a:	88 0f       	add	r24, r24
    281c:	99 1f       	adc	r25, r25
    281e:	88 0f       	add	r24, r24
    2820:	99 1f       	adc	r25, r25
    2822:	b7 01       	movw	r22, r14
    2824:	0e 94 82 24 	call	0x4904	; 0x4904 <__udivmodhi4>
    2828:	70 93 d5 04 	sts	0x04D5, r23
      if (pgm_read_word(g_current_music)) { // get note data until MUSIC_END
        if (g_current_music == g_selected_music) { // still at start: first byte is the tempo
          g_music_tempo = pgm_read_word(g_current_music);
          g_current_music++;
        }
        g_music_duration = calc_note_duration(pgm_read_word(g_current_music));
    282c:	60 93 d4 04 	sts	0x04D4, r22
    2830:	2e 5f       	subi	r18, 0xFE	; 254
        g_current_music++;
    2832:	3f 4f       	sbci	r19, 0xFF	; 255
    2834:	30 93 74 04 	sts	0x0474, r19
    2838:	20 93 73 04 	sts	0x0473, r18
    283c:	f9 01       	movw	r30, r18
        if (pgm_read_word(g_current_music) == MUSIC_P) { // pause check (silence for a certain time)
    283e:	85 91       	lpm	r24, Z+
    2840:	94 91       	lpm	r25, Z
    2842:	01 97       	sbiw	r24, 0x01	; 1
    2844:	09 f4       	brne	.+2      	; 0x2848 <main+0x6a0>
    2846:	0d c6       	rjmp	.+3098   	; 0x3462 <main+0x12ba>
    2848:	80 91 71 00 	lds	r24, 0x0071
          TIMSK3 &= ~(1 << OCIE3A); // disable interrupt
          PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
        } else {
          TIMSK3 |= (1 << OCIE3A); // enable interrupt
    284c:	82 60       	ori	r24, 0x02	; 2
    284e:	80 93 71 00 	sts	0x0071, r24
    2852:	80 91 73 04 	lds	r24, 0x0473
        }
        OCR3A = pgm_read_word(g_current_music);
    2856:	90 91 74 04 	lds	r25, 0x0474
    285a:	fc 01       	movw	r30, r24
    285c:	25 91       	lpm	r18, Z+
    285e:	34 91       	lpm	r19, Z
    2860:	30 93 99 00 	sts	0x0099, r19
    2864:	20 93 98 00 	sts	0x0098, r18
    2868:	10 92 95 00 	sts	0x0095, r1
        TCNT3 = 0;
    286c:	10 92 94 00 	sts	0x0094, r1
    2870:	02 96       	adiw	r24, 0x02	; 2
        g_current_music++;
    2872:	90 93 74 04 	sts	0x0474, r25
    2876:	80 93 73 04 	sts	0x0473, r24
    287a:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_alarm() {
  // pin senses
  if ((g_senses & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
    287e:	90 91 2c 10 	lds	r25, 0x102C
    2882:	85 ff       	sbrs	r24, 5
    2884:	04 c0       	rjmp	.+8      	; 0x288e <main+0x6e6>
    2886:	19 9b       	sbis	0x03, 1	; 3
    if (~STATUS_C90_SENSE_ALARM) {
    2888:	c5 c5       	rjmp	.+2954   	; 0x3414 <main+0x126c>
    288a:	19 99       	sbic	0x03, 1	; 3
      set_event(EV_ALARM_ON);
    }
    if (STATUS_C90_SENSE_ALARM) {
    288c:	81 c5       	rjmp	.+2818   	; 0x3390 <main+0x11e8>
    288e:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_ALARM_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
    2892:	90 91 40 12 	lds	r25, 0x1240
    2896:	85 ff       	sbrs	r24, 5
    2898:	25 c0       	rjmp	.+74     	; 0x28e4 <main+0x73c>
    289a:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
    289e:	90 91 42 12 	lds	r25, 0x1242
    28a2:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    28a6:	f0 e0       	ldi	r31, 0x00	; 0
    28a8:	e3 58       	subi	r30, 0x83	; 131
    28aa:	fb 4f       	sbci	r31, 0xFB	; 251
    28ac:	85 fd       	sbrc	r24, 5
      set_event(EV_ALARM_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
    if ((g_dyn_senses_status & FLAG_SENSE_ALARM) == FLAG_SENSE_ALARM) {
    28ae:	e8 c2       	rjmp	.+1488   	; 0x2e80 <main+0xcd8>
    28b0:	8e e0       	ldi	r24, 0x0E	; 14
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    28b2:	80 83       	st	Z, r24
    28b4:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    28b8:	8f 5f       	subi	r24, 0xFF	; 255
    28ba:	80 93 7c 04 	sts	0x047C, r24
    28be:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    28c2:	80 34       	cpi	r24, 0x40	; 64
    28c4:	10 f0       	brcs	.+4      	; 0x28ca <main+0x722>
    28c6:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    28ca:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    28ce:	80 91 7b 04 	lds	r24, 0x047B
    28d2:	98 17       	cp	r25, r24
    28d4:	09 f4       	brne	.+2      	; 0x28d8 <main+0x730>
    28d6:	14 c5       	rjmp	.+2600   	; 0x3300 <main+0x1158>
    28d8:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    28dc:	80 34       	cpi	r24, 0x40	; 64
    28de:	10 f0       	brcs	.+4      	; 0x28e4 <main+0x73c>
    28e0:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    28e4:	80 91 43 12 	lds	r24, 0x1243
    }
  }
}

void check_alarm_settle() {
  if (g_state == ST_ALARM_SETTLE) {
    28e8:	90 91 44 12 	lds	r25, 0x1244
    28ec:	81 15       	cp	r24, r1
    28ee:	91 40       	sbci	r25, 0x01	; 1
    28f0:	09 f4       	brne	.+2      	; 0x28f4 <main+0x74c>
    28f2:	2e c1       	rjmp	.+604    	; 0x2b50 <main+0x9a8>
    28f4:	80 91 43 12 	lds	r24, 0x1243

// triggers alarm if movement (voltage change) is high enough 
// 1.5g setting:  Sensitivity: 800 mV/g  -1g = 850mV  0g = 1650mV 1g = 2450mV
// 1 degree tilt is about 9mv, so by default: if the voltage differs 90mv (~10 degrees), for a certain period, the alarm will trigger
void check_alarm_trigger() {
  if (g_state == ST_ALARM) {
    28f8:	90 91 44 12 	lds	r25, 0x1244
    28fc:	80 34       	cpi	r24, 0x40	; 64
    28fe:	91 05       	cpc	r25, r1
    2900:	09 f4       	brne	.+2      	; 0x2904 <main+0x75c>
    2902:	e7 c0       	rjmp	.+462    	; 0x2ad2 <main+0x92a>
    2904:	80 91 43 12 	lds	r24, 0x1243
    check_backpedal();
  }
}

uint8_t check_battery_read() {
  return ((g_state & ~(ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state);
    2908:	90 91 44 12 	lds	r25, 0x1244
    290c:	20 91 43 12 	lds	r18, 0x1243
    2910:	30 91 44 12 	lds	r19, 0x1244
    2914:	8f 7b       	andi	r24, 0xBF	; 191
    2916:	98 7f       	andi	r25, 0xF8	; 248
    2918:	82 17       	cp	r24, r18
    }
  }
}

void check_battery() {
  if (check_battery_read()) {
    291a:	93 07       	cpc	r25, r19
    291c:	09 f4       	brne	.+2      	; 0x2920 <main+0x778>
    291e:	32 c3       	rjmp	.+1636   	; 0x2f84 <main+0xddc>
    2920:	80 91 2b 10 	lds	r24, 0x102B
  }
}

void check_warning() {
  // pin senses
  if ((g_senses & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
    2924:	90 91 2c 10 	lds	r25, 0x102C
    2928:	90 ff       	sbrs	r25, 0
    292a:	04 c0       	rjmp	.+8      	; 0x2934 <main+0x78c>
    292c:	48 9b       	sbis	0x09, 0	; 9
    if (~STATUS_C90_SENSE_WARNING) {
    292e:	51 c5       	rjmp	.+2722   	; 0x33d2 <main+0x122a>
    2930:	48 99       	sbic	0x09, 0	; 9
      set_event(EV_WARNING_ON);
    }
    if (STATUS_C90_SENSE_WARNING) {
    2932:	0d c5       	rjmp	.+2586   	; 0x334e <main+0x11a6>
    2934:	80 91 3f 12 	lds	r24, 0x123F
      set_event(EV_WARNING_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
    2938:	90 91 40 12 	lds	r25, 0x1240
    293c:	90 ff       	sbrs	r25, 0
    293e:	25 c0       	rjmp	.+74     	; 0x298a <main+0x7e2>
    2940:	80 91 41 12 	lds	r24, 0x1241
    if ((g_dyn_senses_status & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
    2944:	90 91 42 12 	lds	r25, 0x1242
    2948:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    294c:	f0 e0       	ldi	r31, 0x00	; 0
    294e:	e3 58       	subi	r30, 0x83	; 131
    2950:	fb 4f       	sbci	r31, 0xFB	; 251
    2952:	90 fd       	sbrc	r25, 0
      set_event(EV_WARNING_OFF);
    }
  }
  // dynamic senses
  if ((g_dyn_senses & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
    if ((g_dyn_senses_status & FLAG_SENSE_WARNING) == FLAG_SENSE_WARNING) {
    2954:	93 c2       	rjmp	.+1318   	; 0x2e7c <main+0xcd4>
    2956:	84 e1       	ldi	r24, 0x14	; 20
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2958:	80 83       	st	Z, r24
    295a:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    295e:	8f 5f       	subi	r24, 0xFF	; 255
    2960:	80 93 7c 04 	sts	0x047C, r24
    2964:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    2968:	80 34       	cpi	r24, 0x40	; 64
    296a:	10 f0       	brcs	.+4      	; 0x2970 <main+0x7c8>
    296c:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    2970:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    2974:	80 91 7b 04 	lds	r24, 0x047B
    2978:	98 17       	cp	r25, r24
    297a:	09 f4       	brne	.+2      	; 0x297e <main+0x7d6>
    297c:	28 c3       	rjmp	.+1616   	; 0x2fce <main+0xe26>
    297e:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    2982:	80 34       	cpi	r24, 0x40	; 64
    2984:	10 f0       	brcs	.+4      	; 0x298a <main+0x7e2>
    2986:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    298a:	80 91 43 12 	lds	r24, 0x1243
    set_event(EV_READ_BATT);
  }
}

void check_sleep() {
  if (g_state == ST_SLEEP) {
    298e:	90 91 44 12 	lds	r25, 0x1244
    2992:	81 15       	cp	r24, r1
    2994:	92 40       	sbci	r25, 0x02	; 2
    2996:	09 f4       	brne	.+2      	; 0x299a <main+0x7f2>
    2998:	3d c2       	rjmp	.+1146   	; 0x2e14 <main+0xc6c>
    299a:	80 91 64 01 	lds	r24, 0x0164
    if (g_sleep_counter == 0) {
      sleep_now();
    }
  } else {
    g_sleep_counter = g_settings.deep_sleep_counter;
    299e:	90 91 65 01 	lds	r25, 0x0165
    29a2:	90 93 61 04 	sts	0x0461, r25
    29a6:	80 93 60 04 	sts	0x0460, r24
    29aa:	80 91 73 01 	lds	r24, 0x0173
  check_alarm_settle();
  check_alarm_trigger();
  check_battery();
  check_warning();
  check_sleep();
  if (g_settings.backpedal) {
    29ae:	81 11       	cpse	r24, r1
    29b0:	53 c0       	rjmp	.+166    	; 0x2a58 <main+0x8b0>
    29b2:	90 91 7b 04 	lds	r25, 0x047B
  }
}

uint8_t get_event() {
  uint8_t ev;
  if (g_buffer_tail != g_buffer_head) { // not empty
    29b6:	80 91 7c 04 	lds	r24, 0x047C
    29ba:	98 17       	cp	r25, r24
    29bc:	09 f4       	brne	.+2      	; 0x29c0 <main+0x818>
    29be:	44 c0       	rjmp	.+136    	; 0x2a48 <main+0x8a0>
    29c0:	e0 91 7b 04 	lds	r30, 0x047B
    ev = g_event_buffer[g_buffer_tail];
    29c4:	f0 e0       	ldi	r31, 0x00	; 0
    29c6:	e3 58       	subi	r30, 0x83	; 131
    29c8:	fb 4f       	sbci	r31, 0xFB	; 251
    29ca:	90 81       	ld	r25, Z
    29cc:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++;
    29d0:	8f 5f       	subi	r24, 0xFF	; 255
    29d2:	80 93 7b 04 	sts	0x047B, r24
    29d6:	80 91 7b 04 	lds	r24, 0x047B
    if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    29da:	80 34       	cpi	r24, 0x40	; 64
    29dc:	10 f0       	brcs	.+4      	; 0x29e2 <main+0x83a>
    29de:	10 92 7b 04 	sts	0x047B, r1
      g_buffer_tail = 0;
    29e2:	90 93 bd 04 	sts	0x04BD, r25
int main(void) {
  initialize();
  while(1) {
    command_process();
    dispatch_events();
    while ((g_event = get_event()) != EV_VOID) { // handle the complete event queue in one go
    29e6:	99 23       	and	r25, r25
    29e8:	89 f1       	breq	.+98     	; 0x2a4c <main+0x8a4>
    29ea:	02 e0       	ldi	r16, 0x02	; 2
    29ec:	11 e0       	ldi	r17, 0x01	; 1
    29ee:	a1 2c       	mov	r10, r1
    29f0:	b1 2c       	mov	r11, r1
    29f2:	09 c0       	rjmp	.+18     	; 0x2a06 <main+0x85e>
    29f4:	ff ef       	ldi	r31, 0xFF	; 255
    29f6:	af 1a       	sub	r10, r31
    29f8:	bf 0a       	sbc	r11, r31
    29fa:	0b 5f       	subi	r16, 0xFB	; 251
    29fc:	1f 4f       	sbci	r17, 0xFF	; 255
    29fe:	24 e1       	ldi	r18, 0x14	; 20
      for (uint8_t i=0; i<TR_CNT; i++) {
    2a00:	a2 16       	cp	r10, r18
    2a02:	b1 04       	cpc	r11, r1
    2a04:	b1 f2       	breq	.-84     	; 0x29b2 <main+0x80a>
    2a06:	f8 01       	movw	r30, r16
    2a08:	32 97       	sbiw	r30, 0x02	; 2
    2a0a:	01 90       	ld	r0, Z+
        if (g_trans[i].check_func()) { // check if state matches
    2a0c:	f0 81       	ld	r31, Z
    2a0e:	e0 2d       	mov	r30, r0
    2a10:	09 95       	icall
    2a12:	88 23       	and	r24, r24
    2a14:	79 f3       	breq	.-34     	; 0x29f4 <main+0x84c>
    2a16:	80 91 bd 04 	lds	r24, 0x04BD
          if (g_event == g_trans[i].event) { // check if event matches
    2a1a:	f8 01       	movw	r30, r16
    2a1c:	90 81       	ld	r25, Z
    2a1e:	98 13       	cpse	r25, r24
    2a20:	e9 cf       	rjmp	.-46     	; 0x29f4 <main+0x84c>
    2a22:	f5 01       	movw	r30, r10
            g_trans[i].process_func(); // call event handler
    2a24:	ee 0f       	add	r30, r30
    2a26:	ff 1f       	adc	r31, r31
    2a28:	ee 0f       	add	r30, r30
    2a2a:	ff 1f       	adc	r31, r31
    2a2c:	ea 0d       	add	r30, r10
    2a2e:	fb 1d       	adc	r31, r11
    2a30:	e0 50       	subi	r30, 0x00	; 0
    2a32:	ff 4f       	sbci	r31, 0xFF	; 255
    2a34:	03 80       	ldd	r0, Z+3	; 0x03
    2a36:	f4 81       	ldd	r31, Z+4	; 0x04
    2a38:	e0 2d       	mov	r30, r0
    2a3a:	09 95       	icall
    2a3c:	90 91 7b 04 	lds	r25, 0x047B
  }
}

uint8_t get_event() {
  uint8_t ev;
  if (g_buffer_tail != g_buffer_head) { // not empty
    2a40:	80 91 7c 04 	lds	r24, 0x047C
    2a44:	98 13       	cpse	r25, r24
    2a46:	bc cf       	rjmp	.-136    	; 0x29c0 <main+0x818>
    2a48:	10 92 bd 04 	sts	0x04BD, r1
int main(void) {
  initialize();
  while(1) {
    command_process();
    dispatch_events();
    while ((g_event = get_event()) != EV_VOID) { // handle the complete event queue in one go
    2a4c:	80 91 36 12 	lds	r24, 0x1236
            break;
          }
        }
      }
    }
    if (!g_mcu_reset) { 
    2a50:	81 11       	cpse	r24, r1
    2a52:	1e cd       	rjmp	.-1476   	; 0x2490 <main+0x2e8>
    2a54:	a8 95       	wdr
      wdt_reset(); // reset the watchdog, i.e. don't reset the mcu
    2a56:	1c cd       	rjmp	.-1480   	; 0x2490 <main+0x2e8>
    2a58:	80 91 43 12 	lds	r24, 0x1243
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_backpedal_on() {
  return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
    2a5c:	90 91 44 12 	lds	r25, 0x1244
    2a60:	20 91 43 12 	lds	r18, 0x1243
    2a64:	30 91 44 12 	lds	r19, 0x1244
    2a68:	89 7b       	andi	r24, 0xB9	; 185
    2a6a:	99 27       	eor	r25, r25
    2a6c:	82 17       	cp	r24, r18
    2a6e:	93 07       	cpc	r25, r19
    2a70:	09 f0       	breq	.+2      	; 0x2a74 <main+0x8cc>
    2a72:	9f cf       	rjmp	.-194    	; 0x29b2 <main+0x80a>
    2a74:	80 91 43 12 	lds	r24, 0x1243
        ((g_state & ~(ST_WARNING | ST_RI | ST_LI | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
    2a78:	90 91 44 12 	lds	r25, 0x1244
    2a7c:	20 91 43 12 	lds	r18, 0x1243
    2a80:	30 91 44 12 	lds	r19, 0x1244
    2a84:	89 7b       	andi	r24, 0xB9	; 185
    2a86:	90 7f       	andi	r25, 0xF0	; 240
    2a88:	82 17       	cp	r24, r18
  return (((g_state & (ST_NORMAL | ST_RI | ST_LI | ST_CLAXON | ST_PILOT | ST_BRAKE | ST_WARNING)) == g_state) &&
        ((g_state & ~(ST_LIGHT | ST_ALARM | ST_ALARM_SETTLE | ST_SETTLE | ST_SLEEP)) == g_state));
}

uint8_t check_backpedal_on() {
  return (((g_state & (ST_NORMAL | ST_LIGHT | ST_CLAXON | ST_PILOT | ST_BRAKE )) == g_state) &&
    2a8a:	93 07       	cpc	r25, r19
    2a8c:	09 f0       	breq	.+2      	; 0x2a90 <main+0x8e8>
    2a8e:	91 cf       	rjmp	.-222    	; 0x29b2 <main+0x80a>
    2a90:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2a94:	f0 e0       	ldi	r31, 0x00	; 0
    2a96:	e3 58       	subi	r30, 0x83	; 131
    2a98:	fb 4f       	sbci	r31, 0xFB	; 251
    2a9a:	86 e1       	ldi	r24, 0x16	; 22
    2a9c:	80 83       	st	Z, r24
    2a9e:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    2aa2:	8f 5f       	subi	r24, 0xFF	; 255
    2aa4:	80 93 7c 04 	sts	0x047C, r24
    2aa8:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    2aac:	80 34       	cpi	r24, 0x40	; 64
    2aae:	10 f0       	brcs	.+4      	; 0x2ab4 <main+0x90c>
    2ab0:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    2ab4:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    2ab8:	80 91 7b 04 	lds	r24, 0x047B
    2abc:	98 17       	cp	r25, r24
    2abe:	09 f4       	brne	.+2      	; 0x2ac2 <main+0x91a>
    2ac0:	fe c4       	rjmp	.+2556   	; 0x34be <main+0x1316>
    2ac2:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    2ac6:	80 34       	cpi	r24, 0x40	; 64
    2ac8:	08 f4       	brcc	.+2      	; 0x2acc <main+0x924>
    2aca:	73 cf       	rjmp	.-282    	; 0x29b2 <main+0x80a>
    2acc:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    2ad0:	70 cf       	rjmp	.-288    	; 0x29b2 <main+0x80a>
    2ad2:	80 91 cb 04 	lds	r24, 0x04CB
// triggers alarm if movement (voltage change) is high enough 
// 1.5g setting:  Sensitivity: 800 mV/g  -1g = 850mV  0g = 1650mV 1g = 2450mV
// 1 degree tilt is about 9mv, so by default: if the voltage differs 90mv (~10 degrees), for a certain period, the alarm will trigger
void check_alarm_trigger() {
  if (g_state == ST_ALARM) {
    if (FLAG_ALARM_TRIGGER) {
    2ad6:	88 23       	and	r24, r24
    2ad8:	09 f4       	brne	.+2      	; 0x2adc <main+0x934>
    2ada:	fd c1       	rjmp	.+1018   	; 0x2ed6 <main+0xd2e>
    2adc:	80 91 cc 04 	lds	r24, 0x04CC
      if (FLAG_ALARM_BLINK) {
    2ae0:	88 23       	and	r24, r24
    2ae2:	09 f4       	brne	.+2      	; 0x2ae6 <main+0x93e>
    2ae4:	0f cf       	rjmp	.-482    	; 0x2904 <main+0x75c>
    2ae6:	10 92 cc 04 	sts	0x04CC, r1
        FLAG_ALARM_BLINK = 0;
    2aea:	88 b1       	in	r24, 0x08	; 8
        PORT_C90_LIGHT_RI_F ^= (1 << PIN_C90_LIGHT_RI_F);
    2aec:	91 e0       	ldi	r25, 0x01	; 1
    2aee:	89 27       	eor	r24, r25
    2af0:	88 b9       	out	0x08, r24	; 8
    2af2:	88 b1       	in	r24, 0x08	; 8
        PORT_C90_LIGHT_RI_B ^= (1 << PIN_C90_LIGHT_RI_B);
    2af4:	8d 25       	eor	r24, r13
    2af6:	88 b9       	out	0x08, r24	; 8
    2af8:	88 b1       	in	r24, 0x08	; 8
        PORT_C90_LIGHT_LI_F ^= (1 << PIN_C90_LIGHT_LI_F);
    2afa:	92 e0       	ldi	r25, 0x02	; 2
    2afc:	89 27       	eor	r24, r25
    2afe:	88 b9       	out	0x08, r24	; 8
    2b00:	88 b1       	in	r24, 0x08	; 8
        PORT_C90_LIGHT_LI_B ^= (1 << PIN_C90_LIGHT_LI_B);
    2b02:	90 e1       	ldi	r25, 0x10	; 16
    2b04:	89 27       	eor	r24, r25
    2b06:	88 b9       	out	0x08, r24	; 8
    2b08:	88 b1       	in	r24, 0x08	; 8
        PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    2b0a:	94 e0       	ldi	r25, 0x04	; 4
    2b0c:	89 27       	eor	r24, r25
    2b0e:	88 b9       	out	0x08, r24	; 8
    2b10:	8b b1       	in	r24, 0x0b	; 11
        PORT_C90_CLAXON ^= (1 << PIN_C90_CLAXON);
    2b12:	90 e4       	ldi	r25, 0x40	; 64
    2b14:	89 27       	eor	r24, r25
    2b16:	8b b9       	out	0x0b, r24	; 11
    2b18:	80 91 69 04 	lds	r24, 0x0469
        g_alarm_counter--;
    2b1c:	81 50       	subi	r24, 0x01	; 1
    2b1e:	80 93 69 04 	sts	0x0469, r24
    2b22:	80 91 69 04 	lds	r24, 0x0469
        if (!g_alarm_counter) {
    2b26:	81 11       	cpse	r24, r1
    2b28:	ed ce       	rjmp	.-550    	; 0x2904 <main+0x75c>
    2b2a:	42 98       	cbi	0x08, 2	; 8
  }
}

// all lighting pins go low
void all_lights_off() {
  PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    2b2c:	45 98       	cbi	0x08, 5	; 8
  PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    2b2e:	40 98       	cbi	0x08, 0	; 8
  PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
    2b30:	43 98       	cbi	0x08, 3	; 8
  PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
    2b32:	41 98       	cbi	0x08, 1	; 8
  PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
    2b34:	44 98       	cbi	0x08, 4	; 8
  PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
    2b36:	47 98       	cbi	0x08, 7	; 8
  PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
    2b38:	5f 98       	cbi	0x0b, 7	; 11
  PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
    2b3a:	46 98       	cbi	0x08, 6	; 8
  PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
    2b3c:	5e 98       	cbi	0x0b, 6	; 11
  PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
    2b3e:	10 92 cb 04 	sts	0x04CB, r1
        PORT_C90_LIGHT_INDICATOR_COCKPIT ^= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
        PORT_C90_CLAXON ^= (1 << PIN_C90_CLAXON);
        g_alarm_counter--;
        if (!g_alarm_counter) {
          all_lights_off();
          FLAG_ALARM_TRIGGER = 0; // reset alarm trigger
    2b42:	70 92 44 12 	sts	0x1244, r7
          g_state = ST_ALARM_SETTLE; // go back to new alarm settle mode
    2b46:	60 92 43 12 	sts	0x1243, r6
    2b4a:	10 92 cd 04 	sts	0x04CD, r1
          FLAG_ALARM_SETTLE = 0; // reset alarm settle
    2b4e:	da ce       	rjmp	.-588    	; 0x2904 <main+0x75c>
    2b50:	80 91 cd 04 	lds	r24, 0x04CD
  }
}

void check_alarm_settle() {
  if (g_state == ST_ALARM_SETTLE) {
    if (!FLAG_ALARM_SETTLE) { // first time in alarm settle mode
    2b54:	81 11       	cpse	r24, r1
    2b56:	55 c0       	rjmp	.+170    	; 0x2c02 <main+0xa5a>
    2b58:	80 91 77 01 	lds	r24, 0x0177
      uint8_t song_idx = g_settings.alarm_sound;
    2b5c:	81 11       	cpse	r24, r1
      // check for random startup song
      if (song_idx == 0) {
    2b5e:	1f c0       	rjmp	.+62     	; 0x2b9e <main+0x9f6>
    2b60:	60 91 37 12 	lds	r22, 0x1237
        srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda random seed
    2b64:	70 91 38 12 	lds	r23, 0x1238
    2b68:	80 91 39 12 	lds	r24, 0x1239
    2b6c:	90 91 3a 12 	lds	r25, 0x123A
    2b70:	40 91 3b 12 	lds	r20, 0x123B
    2b74:	50 91 3c 12 	lds	r21, 0x123C
    2b78:	20 91 3d 12 	lds	r18, 0x123D
    2b7c:	30 91 3e 12 	lds	r19, 0x123E
    2b80:	86 0f       	add	r24, r22
    2b82:	97 1f       	adc	r25, r23
    2b84:	84 0f       	add	r24, r20
    2b86:	95 1f       	adc	r25, r21
    2b88:	82 0f       	add	r24, r18
    2b8a:	93 1f       	adc	r25, r19
    2b8c:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <srand>
    2b90:	0e 94 19 26 	call	0x4c32	; 0x4c32 <rand>
        song_idx = 1 + (uint8_t)(rand() / (RAND_MAX / 6));
    2b94:	b2 01       	movw	r22, r4
    2b96:	0e 94 96 24 	call	0x492c	; 0x492c <__divmodhi4>
    2b9a:	81 e0       	ldi	r24, 0x01	; 1
    2b9c:	86 0f       	add	r24, r22
    2b9e:	21 e0       	ldi	r18, 0x01	; 1
      }
      FLAG_ALARM_SETTLE = 1;
    2ba0:	20 93 cd 04 	sts	0x04CD, r18
    2ba4:	42 9a       	sbi	0x08, 2	; 8
      // activate indicators
      PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    2ba6:	40 9a       	sbi	0x08, 0	; 8
      PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
    2ba8:	43 9a       	sbi	0x08, 3	; 8
      PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
    2baa:	41 9a       	sbi	0x08, 1	; 8
      PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
    2bac:	44 9a       	sbi	0x08, 4	; 8
      PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
    2bae:	10 92 d5 04 	sts	0x04D5, r1
      g_music_duration = 0;
    2bb2:	10 92 d4 04 	sts	0x04D4, r1
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
      g_current_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
    2bb8:	88 0f       	add	r24, r24
    2bba:	99 1f       	adc	r25, r25
    2bbc:	86 54       	subi	r24, 0x46	; 70
    2bbe:	9d 4e       	sbci	r25, 0xED	; 237
    2bc0:	fc 01       	movw	r30, r24
    2bc2:	85 91       	lpm	r24, Z+
    2bc4:	94 91       	lpm	r25, Z
    2bc6:	90 93 74 04 	sts	0x0474, r25
    2bca:	80 93 73 04 	sts	0x0473, r24
    2bce:	90 93 76 04 	sts	0x0476, r25
      g_selected_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
    2bd2:	80 93 75 04 	sts	0x0475, r24
    2bd6:	20 93 ca 04 	sts	0x04CA, r18
      FLAG_MUSIC = 1;
    2bda:	80 91 68 01 	lds	r24, 0x0168
      g_current_alarm_settle_time = g_settings.alarm_settle_time;
    2bde:	90 91 69 01 	lds	r25, 0x0169
    2be2:	90 93 78 04 	sts	0x0478, r25
    2be6:	80 93 77 04 	sts	0x0477, r24
    2bea:	10 92 64 04 	sts	0x0464, r1
      g_alarm_snapshot[0] = 0;
    2bee:	10 92 63 04 	sts	0x0463, r1
    2bf2:	10 92 66 04 	sts	0x0466, r1
      g_alarm_snapshot[1] = 0;
    2bf6:	10 92 65 04 	sts	0x0465, r1
    2bfa:	10 92 68 04 	sts	0x0468, r1
      g_alarm_snapshot[2] = 0;
    2bfe:	10 92 67 04 	sts	0x0467, r1
    2c02:	80 91 63 04 	lds	r24, 0x0463
    }
    // save the AVERAGE accelerometer values as the alarm trigger reference during the settlement
    if (g_alarm_snapshot[0]) {
    2c06:	90 91 64 04 	lds	r25, 0x0464
    2c0a:	89 2b       	or	r24, r25
    2c0c:	09 f4       	brne	.+2      	; 0x2c10 <main+0xa68>
    2c0e:	5a c1       	rjmp	.+692    	; 0x2ec4 <main+0xd1c>
    2c10:	20 91 63 04 	lds	r18, 0x0463
      g_alarm_snapshot[0] = ((g_alarm_snapshot[0] + g_adc_voltage[1])/2);
    2c14:	30 91 64 04 	lds	r19, 0x0464
    2c18:	80 91 39 12 	lds	r24, 0x1239
    2c1c:	90 91 3a 12 	lds	r25, 0x123A
    2c20:	82 0f       	add	r24, r18
    2c22:	93 1f       	adc	r25, r19
    2c24:	96 95       	lsr	r25
    2c26:	87 95       	ror	r24
    2c28:	90 93 64 04 	sts	0x0464, r25
    2c2c:	80 93 63 04 	sts	0x0463, r24
    2c30:	80 91 65 04 	lds	r24, 0x0465
    } else {
      g_alarm_snapshot[0] = g_adc_voltage[1];
    }
    if (g_alarm_snapshot[1]) {
    2c34:	90 91 66 04 	lds	r25, 0x0466
    2c38:	89 2b       	or	r24, r25
    2c3a:	09 f4       	brne	.+2      	; 0x2c3e <main+0xa96>
    2c3c:	3a c1       	rjmp	.+628    	; 0x2eb2 <main+0xd0a>
    2c3e:	20 91 65 04 	lds	r18, 0x0465
      g_alarm_snapshot[1] = ((g_alarm_snapshot[1] + g_adc_voltage[2])/2);
    2c42:	30 91 66 04 	lds	r19, 0x0466
    2c46:	80 91 3b 12 	lds	r24, 0x123B
    2c4a:	90 91 3c 12 	lds	r25, 0x123C
    2c4e:	82 0f       	add	r24, r18
    2c50:	93 1f       	adc	r25, r19
    2c52:	96 95       	lsr	r25
    2c54:	87 95       	ror	r24
    2c56:	90 93 66 04 	sts	0x0466, r25
    2c5a:	80 93 65 04 	sts	0x0465, r24
    2c5e:	80 91 67 04 	lds	r24, 0x0467
    } else {
      g_alarm_snapshot[1] = g_adc_voltage[2];
    }
    if (g_alarm_snapshot[2]) {
    2c62:	90 91 68 04 	lds	r25, 0x0468
    2c66:	89 2b       	or	r24, r25
    2c68:	09 f4       	brne	.+2      	; 0x2c6c <main+0xac4>
    2c6a:	1a c1       	rjmp	.+564    	; 0x2ea0 <main+0xcf8>
    2c6c:	20 91 67 04 	lds	r18, 0x0467
      g_alarm_snapshot[2] = ((g_alarm_snapshot[2] + g_adc_voltage[3])/2);
    2c70:	30 91 68 04 	lds	r19, 0x0468
    2c74:	80 91 3d 12 	lds	r24, 0x123D
    2c78:	90 91 3e 12 	lds	r25, 0x123E
    2c7c:	82 0f       	add	r24, r18
    2c7e:	93 1f       	adc	r25, r19
    2c80:	96 95       	lsr	r25
    2c82:	87 95       	ror	r24
    2c84:	90 93 68 04 	sts	0x0468, r25
    2c88:	80 93 67 04 	sts	0x0467, r24
    2c8c:	80 91 77 04 	lds	r24, 0x0477
    } else {
      g_alarm_snapshot[2] = g_adc_voltage[3];
    }
    // alarm settle time is over: only start alarm with valid accelerometer voltages
    if ((!g_current_alarm_settle_time) && ((g_alarm_snapshot[0] > g_settings.alarm_thres_min) && (g_alarm_snapshot[0] < g_settings.alarm_thres_max)) &&
    2c90:	90 91 78 04 	lds	r25, 0x0478
    2c94:	89 2b       	or	r24, r25
    2c96:	09 f0       	breq	.+2      	; 0x2c9a <main+0xaf2>
    2c98:	2d ce       	rjmp	.-934    	; 0x28f4 <main+0x74c>
    2c9a:	80 91 63 04 	lds	r24, 0x0463
    2c9e:	90 91 64 04 	lds	r25, 0x0464
    2ca2:	20 91 70 01 	lds	r18, 0x0170
    2ca6:	30 e0       	ldi	r19, 0x00	; 0
    2ca8:	28 17       	cp	r18, r24
    2caa:	39 07       	cpc	r19, r25
    2cac:	08 f0       	brcs	.+2      	; 0x2cb0 <main+0xb08>
    2cae:	22 ce       	rjmp	.-956    	; 0x28f4 <main+0x74c>
    2cb0:	40 91 63 04 	lds	r20, 0x0463
    2cb4:	50 91 64 04 	lds	r21, 0x0464
    2cb8:	80 91 71 01 	lds	r24, 0x0171
    2cbc:	90 91 72 01 	lds	r25, 0x0172
    2cc0:	48 17       	cp	r20, r24
    2cc2:	59 07       	cpc	r21, r25
    2cc4:	08 f0       	brcs	.+2      	; 0x2cc8 <main+0xb20>
    2cc6:	16 ce       	rjmp	.-980    	; 0x28f4 <main+0x74c>
    2cc8:	40 91 65 04 	lds	r20, 0x0465
       ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.alarm_thres_max)) &&
    2ccc:	50 91 66 04 	lds	r21, 0x0466
    2cd0:	24 17       	cp	r18, r20
      g_alarm_snapshot[2] = ((g_alarm_snapshot[2] + g_adc_voltage[3])/2);
    } else {
      g_alarm_snapshot[2] = g_adc_voltage[3];
    }
    // alarm settle time is over: only start alarm with valid accelerometer voltages
    if ((!g_current_alarm_settle_time) && ((g_alarm_snapshot[0] > g_settings.alarm_thres_min) && (g_alarm_snapshot[0] < g_settings.alarm_thres_max)) &&
    2cd2:	35 07       	cpc	r19, r21
    2cd4:	08 f0       	brcs	.+2      	; 0x2cd8 <main+0xb30>
    2cd6:	0e ce       	rjmp	.-996    	; 0x28f4 <main+0x74c>
    2cd8:	40 91 65 04 	lds	r20, 0x0465
       ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.alarm_thres_max)) &&
    2cdc:	50 91 66 04 	lds	r21, 0x0466
    2ce0:	48 17       	cp	r20, r24
    2ce2:	59 07       	cpc	r21, r25
    2ce4:	08 f0       	brcs	.+2      	; 0x2ce8 <main+0xb40>
    2ce6:	06 ce       	rjmp	.-1012   	; 0x28f4 <main+0x74c>
    2ce8:	40 91 67 04 	lds	r20, 0x0467
       ((g_alarm_snapshot[2] > g_settings.alarm_thres_min) && (g_alarm_snapshot[2] < g_settings.alarm_thres_max))) {
    2cec:	50 91 68 04 	lds	r21, 0x0468
    2cf0:	24 17       	cp	r18, r20
    } else {
      g_alarm_snapshot[2] = g_adc_voltage[3];
    }
    // alarm settle time is over: only start alarm with valid accelerometer voltages
    if ((!g_current_alarm_settle_time) && ((g_alarm_snapshot[0] > g_settings.alarm_thres_min) && (g_alarm_snapshot[0] < g_settings.alarm_thres_max)) &&
       ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.alarm_thres_max)) &&
    2cf2:	35 07       	cpc	r19, r21
    2cf4:	08 f0       	brcs	.+2      	; 0x2cf8 <main+0xb50>
    2cf6:	fe cd       	rjmp	.-1028   	; 0x28f4 <main+0x74c>
    2cf8:	20 91 67 04 	lds	r18, 0x0467
       ((g_alarm_snapshot[2] > g_settings.alarm_thres_min) && (g_alarm_snapshot[2] < g_settings.alarm_thres_max))) {
    2cfc:	30 91 68 04 	lds	r19, 0x0468
    2d00:	28 17       	cp	r18, r24
    2d02:	39 07       	cpc	r19, r25
    2d04:	08 f0       	brcs	.+2      	; 0x2d08 <main+0xb60>
    2d06:	f6 cd       	rjmp	.-1044   	; 0x28f4 <main+0x74c>
    2d08:	10 92 cd 04 	sts	0x04CD, r1
      // prepare for alarm mode
      FLAG_ALARM_SETTLE = 0;
    2d0c:	42 98       	cbi	0x08, 2	; 8
  }
}

// all lighting pins go low
void all_lights_off() {
  PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    2d0e:	45 98       	cbi	0x08, 5	; 8
  PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    2d10:	40 98       	cbi	0x08, 0	; 8
  PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
    2d12:	43 98       	cbi	0x08, 3	; 8
  PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
    2d14:	41 98       	cbi	0x08, 1	; 8
  PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
    2d16:	44 98       	cbi	0x08, 4	; 8
  PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
    2d18:	47 98       	cbi	0x08, 7	; 8
  PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
    2d1a:	5f 98       	cbi	0x0b, 7	; 11
  PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
    2d1c:	46 98       	cbi	0x08, 6	; 8
  PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
    2d1e:	5e 98       	cbi	0x0b, 6	; 11
  PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // claxon too
    2d20:	80 91 6d 01 	lds	r24, 0x016D
       ((g_alarm_snapshot[1] > g_settings.alarm_thres_min) && (g_alarm_snapshot[1] < g_settings.alarm_thres_max)) &&
       ((g_alarm_snapshot[2] > g_settings.alarm_thres_min) && (g_alarm_snapshot[2] < g_settings.alarm_thres_max))) {
      // prepare for alarm mode
      FLAG_ALARM_SETTLE = 0;
      all_lights_off();
      g_alarm_counter = g_settings.alarm_counter;
    2d24:	80 93 69 04 	sts	0x0469, r24
    2d28:	10 92 5f 04 	sts	0x045F, r1
      g_trigger_counter = 0;
    2d2c:	80 e4       	ldi	r24, 0x40	; 64
      g_state = ST_ALARM;
    2d2e:	90 e0       	ldi	r25, 0x00	; 0
    2d30:	90 93 44 12 	sts	0x1244, r25
    2d34:	80 93 43 12 	sts	0x1243, r24
    2d38:	dd cd       	rjmp	.-1094   	; 0x28f4 <main+0x74c>
    2d3a:	80 91 ce 04 	lds	r24, 0x04CE
  }
}

void check_settle() {
  if (g_state == ST_SETTLE) {
    if (!FLAG_SETTLE) { // first time in settle mode
    2d3e:	81 11       	cpse	r24, r1
    2d40:	4f c0       	rjmp	.+158    	; 0x2de0 <main+0xc38>
    2d42:	80 91 76 01 	lds	r24, 0x0176
      uint8_t song_idx = g_settings.startup_sound;
    2d46:	91 e0       	ldi	r25, 0x01	; 1
      FLAG_SETTLE = 1;
    2d48:	90 93 ce 04 	sts	0x04CE, r25
    2d4c:	42 9a       	sbi	0x08, 2	; 8
      // activate all lights
      PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    2d4e:	45 9a       	sbi	0x08, 5	; 8
      PORT_C90_LIGHT_STATUS_COCKPIT |= (1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    2d50:	40 9a       	sbi	0x08, 0	; 8
      PORT_C90_LIGHT_RI_F |= (1 << PIN_C90_LIGHT_RI_F);
    2d52:	43 9a       	sbi	0x08, 3	; 8
      PORT_C90_LIGHT_RI_B |= (1 << PIN_C90_LIGHT_RI_B);
    2d54:	41 9a       	sbi	0x08, 1	; 8
      PORT_C90_LIGHT_LI_F |= (1 << PIN_C90_LIGHT_LI_F);
    2d56:	44 9a       	sbi	0x08, 4	; 8
      PORT_C90_LIGHT_LI_B |= (1 << PIN_C90_LIGHT_LI_B);
    2d58:	47 9a       	sbi	0x08, 7	; 8
      PORT_C90_BRAKE |= (1 << PIN_C90_BRAKE);
    2d5a:	5f 9a       	sbi	0x0b, 7	; 11
      PORT_C90_PILOT |= (1 << PIN_C90_PILOT);
    2d5c:	46 9a       	sbi	0x08, 6	; 8
      PORT_C90_LIGHT |= (1 << PIN_C90_LIGHT);
    2d5e:	5e 98       	cbi	0x0b, 6	; 11
      PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON); // silence a possible claxon from the alarm
    2d60:	10 92 d5 04 	sts	0x04D5, r1
      // check voltage and activate according sound
      g_music_duration = 0;
    2d64:	10 92 d4 04 	sts	0x04D4, r1
    2d68:	81 11       	cpse	r24, r1
      // check for random startup song
      if (song_idx == 0) {
    2d6a:	1f c0       	rjmp	.+62     	; 0x2daa <main+0xc02>
    2d6c:	60 91 37 12 	lds	r22, 0x1237
        srand(g_adc_voltage[0] + g_adc_voltage[1] + g_adc_voltage[2] + g_adc_voltage[3]); // kinda random seed
    2d70:	70 91 38 12 	lds	r23, 0x1238
    2d74:	80 91 39 12 	lds	r24, 0x1239
    2d78:	90 91 3a 12 	lds	r25, 0x123A
    2d7c:	40 91 3b 12 	lds	r20, 0x123B
    2d80:	50 91 3c 12 	lds	r21, 0x123C
    2d84:	20 91 3d 12 	lds	r18, 0x123D
    2d88:	30 91 3e 12 	lds	r19, 0x123E
    2d8c:	86 0f       	add	r24, r22
    2d8e:	97 1f       	adc	r25, r23
    2d90:	84 0f       	add	r24, r20
    2d92:	95 1f       	adc	r25, r21
    2d94:	82 0f       	add	r24, r18
    2d96:	93 1f       	adc	r25, r19
    2d98:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <srand>
    2d9c:	0e 94 19 26 	call	0x4c32	; 0x4c32 <rand>
        song_idx = 2 + (uint8_t)(rand() / (RAND_MAX / 5));
    2da0:	b4 01       	movw	r22, r8
    2da2:	0e 94 96 24 	call	0x492c	; 0x492c <__divmodhi4>
    2da6:	82 e0       	ldi	r24, 0x02	; 2
    2da8:	86 0f       	add	r24, r22
    2daa:	90 e0       	ldi	r25, 0x00	; 0
      }
      g_current_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
    2dac:	88 0f       	add	r24, r24
    2dae:	99 1f       	adc	r25, r25
    2db0:	86 54       	subi	r24, 0x46	; 70
    2db2:	9d 4e       	sbci	r25, 0xED	; 237
    2db4:	fc 01       	movw	r30, r24
    2db6:	85 91       	lpm	r24, Z+
    2db8:	94 91       	lpm	r25, Z
    2dba:	90 93 74 04 	sts	0x0474, r25
    2dbe:	80 93 73 04 	sts	0x0473, r24
    2dc2:	90 93 76 04 	sts	0x0476, r25
      g_selected_music = (uint16_t*)pgm_read_word(&g_music[song_idx-1]);
    2dc6:	80 93 75 04 	sts	0x0475, r24
    2dca:	81 e0       	ldi	r24, 0x01	; 1
      FLAG_MUSIC = 1;
    2dcc:	80 93 ca 04 	sts	0x04CA, r24
    2dd0:	80 91 66 01 	lds	r24, 0x0166
      g_current_settle_time = g_settings.settle_time;
    2dd4:	90 91 67 01 	lds	r25, 0x0167
    2dd8:	90 93 7a 04 	sts	0x047A, r25
    2ddc:	80 93 79 04 	sts	0x0479, r24
    2de0:	80 91 79 04 	lds	r24, 0x0479
    }
    if (!g_current_settle_time) { // settle time is over
    2de4:	90 91 7a 04 	lds	r25, 0x047A
    2de8:	89 2b       	or	r24, r25
    2dea:	09 f0       	breq	.+2      	; 0x2dee <main+0xc46>
    2dec:	ec cc       	rjmp	.-1576   	; 0x27c6 <main+0x61e>
    2dee:	10 92 ce 04 	sts	0x04CE, r1
      FLAG_SETTLE = 0; // reset settle
    2df2:	81 e0       	ldi	r24, 0x01	; 1
      g_state = ST_NORMAL;
    2df4:	90 e0       	ldi	r25, 0x00	; 0
    2df6:	90 93 44 12 	sts	0x1244, r25
    2dfa:	80 93 43 12 	sts	0x1243, r24
    2dfe:	42 98       	cbi	0x08, 2	; 8
      PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    2e00:	45 98       	cbi	0x08, 5	; 8
      PORT_C90_LIGHT_STATUS_COCKPIT &= ~(1 << PIN_C90_LIGHT_STATUS_COCKPIT);
    2e02:	40 98       	cbi	0x08, 0	; 8
      PORT_C90_LIGHT_RI_F &= ~(1 << PIN_C90_LIGHT_RI_F);
    2e04:	43 98       	cbi	0x08, 3	; 8
      PORT_C90_LIGHT_RI_B &= ~(1 << PIN_C90_LIGHT_RI_B);
    2e06:	41 98       	cbi	0x08, 1	; 8
      PORT_C90_LIGHT_LI_F &= ~(1 << PIN_C90_LIGHT_LI_F);
    2e08:	44 98       	cbi	0x08, 4	; 8
      PORT_C90_LIGHT_LI_B &= ~(1 << PIN_C90_LIGHT_LI_B);
    2e0a:	5e 98       	cbi	0x0b, 6	; 11
      PORT_C90_CLAXON &= ~(1 << PIN_C90_CLAXON);
    2e0c:	47 98       	cbi	0x08, 7	; 8
      PORT_C90_BRAKE &= ~(1 << PIN_C90_BRAKE);
    2e0e:	5f 98       	cbi	0x0b, 7	; 11
      PORT_C90_PILOT &= ~(1 << PIN_C90_PILOT);
    2e10:	46 98       	cbi	0x08, 6	; 8
      PORT_C90_LIGHT &= ~(1 << PIN_C90_LIGHT);
    2e12:	d9 cc       	rjmp	.-1614   	; 0x27c6 <main+0x61e>
    2e14:	80 91 60 04 	lds	r24, 0x0460
  }
}

void check_sleep() {
  if (g_state == ST_SLEEP) {
    if (g_sleep_counter == 0) {
    2e18:	90 91 61 04 	lds	r25, 0x0461
    2e1c:	89 2b       	or	r24, r25
    2e1e:	09 f0       	breq	.+2      	; 0x2e22 <main+0xc7a>
    2e20:	c4 cd       	rjmp	.-1144   	; 0x29aa <main+0x802>
    2e22:	0e 94 42 0c 	call	0x1884	; 0x1884 <reset_ports>
    }
  }
}

void sleep_now() {
  reset_ports();
    2e26:	80 91 7a 00 	lds	r24, 0x007A
  ADCSRA |= (1 << ADIE); // enable interrupt
  ADCSRA |= (1 << ADSC); // start a conversion
}

void disable_adc() {
  ADCSRA &= ~(1 << ADEN);
    2e2a:	8f 77       	andi	r24, 0x7F	; 127
    2e2c:	80 93 7a 00 	sts	0x007A, r24
    2e30:	11 b8       	out	0x01, r1	; 1
}

void sleep_now() {
  reset_ports();
  disable_adc();
  DDRA = 0;
    2e32:	8f ef       	ldi	r24, 0xFF	; 255
  PORTA = 0xff;
    2e34:	82 b9       	out	0x02, r24	; 2
    2e36:	88 e1       	ldi	r24, 0x18	; 24
  wdt_disable();
    2e38:	0f b6       	in	r0, 0x3f	; 63
    2e3a:	f8 94       	cli
    2e3c:	80 93 60 00 	sts	0x0060, r24
    2e40:	10 92 60 00 	sts	0x0060, r1
    2e44:	0f be       	out	0x3f, r0	; 63
    2e46:	5c 98       	cbi	0x0b, 4	; 11
  PORT_C90_HEARTBEAT_LED &= ~(1 << PIN_C90_HEARTBEAT_LED); // low
    2e48:	10 92 2c 10 	sts	0x102C, r1
  g_senses = 0b11111111;
  g_senses = ((g_senses << 8) | 0b11111111);
}

void disable_psenses() {
  g_senses = 0;
    2e4c:	10 92 2b 10 	sts	0x102B, r1
    2e50:	80 91 64 00 	lds	r24, 0x0064
  DDRA = 0;
  PORTA = 0xff;
  wdt_disable();
  PORT_C90_HEARTBEAT_LED &= ~(1 << PIN_C90_HEARTBEAT_LED); // low
  disable_psenses();
  power_all_disable();
    2e54:	8f ef       	ldi	r24, 0xFF	; 255
    2e56:	80 93 64 00 	sts	0x0064, r24
    2e5a:	80 91 65 00 	lds	r24, 0x0065
    2e5e:	81 60       	ori	r24, 0x01	; 1
    2e60:	80 93 65 00 	sts	0x0065, r24
    2e64:	83 b7       	in	r24, 0x33	; 51
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    2e66:	81 7f       	andi	r24, 0xF1	; 241
    2e68:	84 60       	ori	r24, 0x04	; 4
    2e6a:	83 bf       	out	0x33, r24	; 51
    2e6c:	83 b7       	in	r24, 0x33	; 51
  sleep_mode();         
    2e6e:	81 60       	ori	r24, 0x01	; 1
    2e70:	83 bf       	out	0x33, r24	; 51
    2e72:	88 95       	sleep
    2e74:	83 b7       	in	r24, 0x33	; 51
    2e76:	8e 7f       	andi	r24, 0xFE	; 254
    2e78:	83 bf       	out	0x33, r24	; 51
    2e7a:	97 cd       	rjmp	.-1234   	; 0x29aa <main+0x802>
    2e7c:	85 e1       	ldi	r24, 0x15	; 21
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2e7e:	6c cd       	rjmp	.-1320   	; 0x2958 <main+0x7b0>
    2e80:	8f e0       	ldi	r24, 0x0F	; 15
    2e82:	17 cd       	rjmp	.-1490   	; 0x28b2 <main+0x70a>
    2e84:	c0 82       	st	Z, r12
    2e86:	22 cb       	rjmp	.-2492   	; 0x24cc <main+0x324>
    2e88:	87 e0       	ldi	r24, 0x07	; 7
    2e8a:	54 cb       	rjmp	.-2392   	; 0x2534 <main+0x38c>
    2e8c:	84 e0       	ldi	r24, 0x04	; 4
    2e8e:	87 cb       	rjmp	.-2290   	; 0x259e <main+0x3f6>
    2e90:	85 e0       	ldi	r24, 0x05	; 5
    2e92:	ba cb       	rjmp	.-2188   	; 0x2608 <main+0x460>
    2e94:	8d e0       	ldi	r24, 0x0D	; 13
    2e96:	0c cc       	rjmp	.-2024   	; 0x26b0 <main+0x508>
    2e98:	8b e0       	ldi	r24, 0x0B	; 11
    2e9a:	3f cc       	rjmp	.-1922   	; 0x271a <main+0x572>
    2e9c:	83 e1       	ldi	r24, 0x13	; 19
    2e9e:	72 cc       	rjmp	.-1820   	; 0x2784 <main+0x5dc>
    2ea0:	80 91 3d 12 	lds	r24, 0x123D
      g_alarm_snapshot[1] = g_adc_voltage[2];
    }
    if (g_alarm_snapshot[2]) {
      g_alarm_snapshot[2] = ((g_alarm_snapshot[2] + g_adc_voltage[3])/2);
    } else {
      g_alarm_snapshot[2] = g_adc_voltage[3];
    2ea4:	90 91 3e 12 	lds	r25, 0x123E
    2ea8:	90 93 68 04 	sts	0x0468, r25
    2eac:	80 93 67 04 	sts	0x0467, r24
    2eb0:	ed ce       	rjmp	.-550    	; 0x2c8c <main+0xae4>
    2eb2:	80 91 3b 12 	lds	r24, 0x123B
      g_alarm_snapshot[0] = g_adc_voltage[1];
    }
    if (g_alarm_snapshot[1]) {
      g_alarm_snapshot[1] = ((g_alarm_snapshot[1] + g_adc_voltage[2])/2);
    } else {
      g_alarm_snapshot[1] = g_adc_voltage[2];
    2eb6:	90 91 3c 12 	lds	r25, 0x123C
    2eba:	90 93 66 04 	sts	0x0466, r25
    2ebe:	80 93 65 04 	sts	0x0465, r24
    2ec2:	cd ce       	rjmp	.-614    	; 0x2c5e <main+0xab6>
    2ec4:	80 91 39 12 	lds	r24, 0x1239
    }
    // save the AVERAGE accelerometer values as the alarm trigger reference during the settlement
    if (g_alarm_snapshot[0]) {
      g_alarm_snapshot[0] = ((g_alarm_snapshot[0] + g_adc_voltage[1])/2);
    } else {
      g_alarm_snapshot[0] = g_adc_voltage[1];
    2ec8:	90 91 3a 12 	lds	r25, 0x123A
    2ecc:	90 93 64 04 	sts	0x0464, r25
    2ed0:	80 93 63 04 	sts	0x0463, r24
    2ed4:	ad ce       	rjmp	.-678    	; 0x2c30 <main+0xa88>
    2ed6:	80 91 cc 04 	lds	r24, 0x04CC
          FLAG_ALARM_TRIGGER = 0; // reset alarm trigger
          g_state = ST_ALARM_SETTLE; // go back to new alarm settle mode
          FLAG_ALARM_SETTLE = 0; // reset alarm settle
        }
      }
    } else if (FLAG_ALARM_BLINK) {
    2eda:	88 23       	and	r24, r24
    2edc:	09 f4       	brne	.+2      	; 0x2ee0 <main+0xd38>
    2ede:	12 cd       	rjmp	.-1500   	; 0x2904 <main+0x75c>
    2ee0:	10 92 cc 04 	sts	0x04CC, r1
      FLAG_ALARM_BLINK = 0;
    2ee4:	80 91 6a 04 	lds	r24, 0x046A
      if (g_alarm_blink_counter % 4 == 0) { // blink for 1 tick every timer1 4 counts
    2ee8:	83 70       	andi	r24, 0x03	; 3
    2eea:	09 f0       	breq	.+2      	; 0x2eee <main+0xd46>
    2eec:	c1 c2       	rjmp	.+1410   	; 0x3470 <main+0x12c8>
    2eee:	42 9a       	sbi	0x08, 2	; 8
        PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    2ef0:	80 91 39 12 	lds	r24, 0x1239
      } else {
        PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      }
      if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
    2ef4:	90 91 3a 12 	lds	r25, 0x123A
    2ef8:	40 91 63 04 	lds	r20, 0x0463
    2efc:	50 91 64 04 	lds	r21, 0x0464
    2f00:	20 91 6e 01 	lds	r18, 0x016E
    2f04:	30 e0       	ldi	r19, 0x00	; 0
    2f06:	84 1b       	sub	r24, r20
    2f08:	95 0b       	sbc	r25, r21
    2f0a:	97 fd       	sbrc	r25, 7
    2f0c:	f0 c2       	rjmp	.+1504   	; 0x34ee <main+0x1346>
    2f0e:	28 17       	cp	r18, r24
    2f10:	39 07       	cpc	r19, r25
    2f12:	fc f0       	brlt	.+62     	; 0x2f52 <main+0xdaa>
    2f14:	80 91 3b 12 	lds	r24, 0x123B
       (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
    2f18:	90 91 3c 12 	lds	r25, 0x123C
    2f1c:	40 91 65 04 	lds	r20, 0x0465
    2f20:	50 91 66 04 	lds	r21, 0x0466
    2f24:	84 1b       	sub	r24, r20
    2f26:	95 0b       	sbc	r25, r21
    2f28:	97 fd       	sbrc	r25, 7
    2f2a:	3d c3       	rjmp	.+1658   	; 0x35a6 <main+0x13fe>
    2f2c:	28 17       	cp	r18, r24
      if (g_alarm_blink_counter % 4 == 0) { // blink for 1 tick every timer1 4 counts
        PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      } else {
        PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      }
      if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
    2f2e:	39 07       	cpc	r19, r25
    2f30:	84 f0       	brlt	.+32     	; 0x2f52 <main+0xdaa>
    2f32:	80 91 3d 12 	lds	r24, 0x123D
       (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
       (abs(g_adc_voltage[3] - g_alarm_snapshot[2]) > g_settings.alarm_trigger)) {
    2f36:	90 91 3e 12 	lds	r25, 0x123E
    2f3a:	40 91 67 04 	lds	r20, 0x0467
    2f3e:	50 91 68 04 	lds	r21, 0x0468
    2f42:	84 1b       	sub	r24, r20
    2f44:	95 0b       	sbc	r25, r21
    2f46:	97 fd       	sbrc	r25, 7
    2f48:	2a c3       	rjmp	.+1620   	; 0x359e <main+0x13f6>
    2f4a:	28 17       	cp	r18, r24
        PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      } else {
        PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      }
      if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
       (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
    2f4c:	39 07       	cpc	r19, r25
    2f4e:	0c f0       	brlt	.+2      	; 0x2f52 <main+0xdaa>
    2f50:	d9 cc       	rjmp	.-1614   	; 0x2904 <main+0x75c>
    2f52:	80 91 5f 04 	lds	r24, 0x045F
       (abs(g_adc_voltage[3] - g_alarm_snapshot[2]) > g_settings.alarm_trigger)) {
        g_trigger_counter++;
    2f56:	8f 5f       	subi	r24, 0xFF	; 255
    2f58:	80 93 5f 04 	sts	0x045F, r24
    2f5c:	80 91 5f 04 	lds	r24, 0x045F
        if (g_trigger_counter >= g_settings.alarm_trigger_counter) {
    2f60:	90 91 6f 01 	lds	r25, 0x016F
    2f64:	89 17       	cp	r24, r25
    2f66:	08 f4       	brcc	.+2      	; 0x2f6a <main+0xdc2>
    2f68:	cd cc       	rjmp	.-1638   	; 0x2904 <main+0x75c>
    2f6a:	81 e0       	ldi	r24, 0x01	; 1
          FLAG_ALARM_TRIGGER = 1;
    2f6c:	80 93 cb 04 	sts	0x04CB, r24
    2f70:	c9 cc       	rjmp	.-1646   	; 0x2904 <main+0x75c>
    2f72:	10 92 ca 04 	sts	0x04CA, r1
        }
        OCR3A = pgm_read_word(g_current_music);
        TCNT3 = 0;
        g_current_music++;
      } else { // the end of song
        FLAG_MUSIC = 0;
    2f76:	80 91 71 00 	lds	r24, 0x0071
        TIMSK3 &= ~(1 << OCIE3A); // disable interrupt
    2f7a:	8d 7f       	andi	r24, 0xFD	; 253
    2f7c:	80 93 71 00 	sts	0x0071, r24
    2f80:	5d 98       	cbi	0x0b, 5	; 11
        PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
    2f82:	7b cc       	rjmp	.-1802   	; 0x287a <main+0x6d2>
    2f84:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2f88:	f0 e0       	ldi	r31, 0x00	; 0
    2f8a:	e3 58       	subi	r30, 0x83	; 131
    2f8c:	fb 4f       	sbci	r31, 0xFB	; 251
    2f8e:	80 e1       	ldi	r24, 0x10	; 16
    2f90:	80 83       	st	Z, r24
    2f92:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    2f96:	8f 5f       	subi	r24, 0xFF	; 255
    2f98:	80 93 7c 04 	sts	0x047C, r24
    2f9c:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    2fa0:	80 34       	cpi	r24, 0x40	; 64
    2fa2:	10 f0       	brcs	.+4      	; 0x2fa8 <main+0xe00>
    2fa4:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    2fa8:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    2fac:	80 91 7b 04 	lds	r24, 0x047B
    2fb0:	98 13       	cpse	r25, r24
    2fb2:	05 c0       	rjmp	.+10     	; 0x2fbe <main+0xe16>
    2fb4:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    2fb8:	8f 5f       	subi	r24, 0xFF	; 255
    2fba:	80 93 7b 04 	sts	0x047B, r24
    2fbe:	80 91 7b 04 	lds	r24, 0x047B
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    2fc2:	80 34       	cpi	r24, 0x40	; 64
    2fc4:	08 f4       	brcc	.+2      	; 0x2fc8 <main+0xe20>
    2fc6:	ac cc       	rjmp	.-1704   	; 0x2920 <main+0x778>
    2fc8:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    2fcc:	a9 cc       	rjmp	.-1710   	; 0x2920 <main+0x778>
    2fce:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    2fd2:	8f 5f       	subi	r24, 0xFF	; 255
    2fd4:	80 93 7b 04 	sts	0x047B, r24
    2fd8:	d2 cc       	rjmp	.-1628   	; 0x297e <main+0x7d6>
    2fda:	80 91 7b 04 	lds	r24, 0x047B
    2fde:	8f 5f       	subi	r24, 0xFF	; 255
    2fe0:	80 93 7b 04 	sts	0x047B, r24
    2fe4:	85 ca       	rjmp	.-2806   	; 0x24f0 <main+0x348>
    2fe6:	80 91 7b 04 	lds	r24, 0x047B
    2fea:	8f 5f       	subi	r24, 0xFF	; 255
    2fec:	80 93 7b 04 	sts	0x047B, r24
    2ff0:	b4 ca       	rjmp	.-2712   	; 0x255a <main+0x3b2>
    2ff2:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    2ff6:	f0 e0       	ldi	r31, 0x00	; 0
    2ff8:	e3 58       	subi	r30, 0x83	; 131
    2ffa:	fb 4f       	sbci	r31, 0xFB	; 251
    2ffc:	27 e0       	ldi	r18, 0x07	; 7
    2ffe:	20 83       	st	Z, r18
    3000:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3004:	8f 5f       	subi	r24, 0xFF	; 255
    3006:	80 93 7c 04 	sts	0x047C, r24
    300a:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    300e:	80 34       	cpi	r24, 0x40	; 64
    3010:	10 f0       	brcs	.+4      	; 0x3016 <main+0xe6e>
    3012:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3016:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    301a:	80 91 7b 04 	lds	r24, 0x047B
    301e:	98 17       	cp	r25, r24
    3020:	09 f4       	brne	.+2      	; 0x3024 <main+0xe7c>
    3022:	6f c2       	rjmp	.+1246   	; 0x3502 <main+0x135a>
    3024:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    3028:	80 34       	cpi	r24, 0x40	; 64
    302a:	08 f4       	brcc	.+2      	; 0x302e <main+0xe86>
    302c:	71 ca       	rjmp	.-2846   	; 0x2510 <main+0x368>
    302e:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3032:	6e ca       	rjmp	.-2852   	; 0x2510 <main+0x368>
    3034:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3038:	f0 e0       	ldi	r31, 0x00	; 0
    303a:	e3 58       	subi	r30, 0x83	; 131
    303c:	fb 4f       	sbci	r31, 0xFB	; 251
    303e:	86 e0       	ldi	r24, 0x06	; 6
    3040:	80 83       	st	Z, r24
    3042:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3046:	8f 5f       	subi	r24, 0xFF	; 255
    3048:	80 93 7c 04 	sts	0x047C, r24
    304c:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    3050:	80 34       	cpi	r24, 0x40	; 64
    3052:	10 f0       	brcs	.+4      	; 0x3058 <main+0xeb0>
    3054:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3058:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    305c:	80 91 7b 04 	lds	r24, 0x047B
    3060:	98 17       	cp	r25, r24
    3062:	09 f4       	brne	.+2      	; 0x3066 <main+0xebe>
    3064:	5a c2       	rjmp	.+1204   	; 0x351a <main+0x1372>
    3066:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    306a:	80 34       	cpi	r24, 0x40	; 64
    306c:	08 f4       	brcc	.+2      	; 0x3070 <main+0xec8>
    306e:	4e ca       	rjmp	.-2916   	; 0x250c <main+0x364>
    3070:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3074:	4b ca       	rjmp	.-2922   	; 0x250c <main+0x364>
    3076:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    307a:	8f 5f       	subi	r24, 0xFF	; 255
    307c:	80 93 7b 04 	sts	0x047B, r24
    3080:	a1 ca       	rjmp	.-2750   	; 0x25c4 <main+0x41c>
    3082:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3086:	f0 e0       	ldi	r31, 0x00	; 0
    3088:	e3 58       	subi	r30, 0x83	; 131
    308a:	fb 4f       	sbci	r31, 0xFB	; 251
    308c:	c0 82       	st	Z, r12
    308e:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3092:	8f 5f       	subi	r24, 0xFF	; 255
    3094:	80 93 7c 04 	sts	0x047C, r24
    3098:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    309c:	80 34       	cpi	r24, 0x40	; 64
    309e:	10 f0       	brcs	.+4      	; 0x30a4 <main+0xefc>
    30a0:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    30a4:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    30a8:	80 91 7b 04 	lds	r24, 0x047B
    30ac:	98 17       	cp	r25, r24
    30ae:	09 f4       	brne	.+2      	; 0x30b2 <main+0xf0a>
    30b0:	2e c2       	rjmp	.+1116   	; 0x350e <main+0x1366>
    30b2:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    30b6:	80 34       	cpi	r24, 0x40	; 64
    30b8:	08 f4       	brcc	.+2      	; 0x30bc <main+0xf14>
    30ba:	f6 c9       	rjmp	.-3092   	; 0x24a8 <main+0x300>
    30bc:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    30c0:	f3 c9       	rjmp	.-3098   	; 0x24a8 <main+0x300>
    30c2:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    30c6:	f0 e0       	ldi	r31, 0x00	; 0
    30c8:	e3 58       	subi	r30, 0x83	; 131
    30ca:	fb 4f       	sbci	r31, 0xFB	; 251
    30cc:	d0 82       	st	Z, r13
    30ce:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    30d2:	8f 5f       	subi	r24, 0xFF	; 255
    30d4:	80 93 7c 04 	sts	0x047C, r24
    30d8:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    30dc:	80 34       	cpi	r24, 0x40	; 64
    30de:	10 f0       	brcs	.+4      	; 0x30e4 <main+0xf3c>
    30e0:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    30e4:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    30e8:	80 91 7b 04 	lds	r24, 0x047B
    30ec:	98 17       	cp	r25, r24
    30ee:	09 f4       	brne	.+2      	; 0x30f2 <main+0xf4a>
    30f0:	20 c2       	rjmp	.+1088   	; 0x3532 <main+0x138a>
    30f2:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    30f6:	80 34       	cpi	r24, 0x40	; 64
    30f8:	08 f4       	brcc	.+2      	; 0x30fc <main+0xf54>
    30fa:	d4 c9       	rjmp	.-3160   	; 0x24a4 <main+0x2fc>
    30fc:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3100:	d1 c9       	rjmp	.-3166   	; 0x24a4 <main+0x2fc>
    3102:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3106:	f0 e0       	ldi	r31, 0x00	; 0
    3108:	e3 58       	subi	r30, 0x83	; 131
    310a:	fb 4f       	sbci	r31, 0xFB	; 251
    310c:	85 e0       	ldi	r24, 0x05	; 5
    310e:	80 83       	st	Z, r24
    3110:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3114:	8f 5f       	subi	r24, 0xFF	; 255
    3116:	80 93 7c 04 	sts	0x047C, r24
    311a:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    311e:	80 34       	cpi	r24, 0x40	; 64
    3120:	10 f0       	brcs	.+4      	; 0x3126 <main+0xf7e>
    3122:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3126:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    312a:	80 91 7b 04 	lds	r24, 0x047B
    312e:	98 17       	cp	r25, r24
    3130:	09 f4       	brne	.+2      	; 0x3134 <main+0xf8c>
    3132:	d1 c1       	rjmp	.+930    	; 0x34d6 <main+0x132e>
    3134:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    3138:	80 34       	cpi	r24, 0x40	; 64
    313a:	08 f4       	brcc	.+2      	; 0x313e <main+0xf96>
    313c:	53 ca       	rjmp	.-2906   	; 0x25e4 <main+0x43c>
    313e:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3142:	50 ca       	rjmp	.-2912   	; 0x25e4 <main+0x43c>
    3144:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3148:	f0 e0       	ldi	r31, 0x00	; 0
    314a:	e3 58       	subi	r30, 0x83	; 131
    314c:	fb 4f       	sbci	r31, 0xFB	; 251
    314e:	84 e0       	ldi	r24, 0x04	; 4
    3150:	80 83       	st	Z, r24
    3152:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3156:	8f 5f       	subi	r24, 0xFF	; 255
    3158:	80 93 7c 04 	sts	0x047C, r24
    315c:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    3160:	80 34       	cpi	r24, 0x40	; 64
    3162:	10 f0       	brcs	.+4      	; 0x3168 <main+0xfc0>
    3164:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3168:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    316c:	80 91 7b 04 	lds	r24, 0x047B
    3170:	98 17       	cp	r25, r24
    3172:	09 f4       	brne	.+2      	; 0x3176 <main+0xfce>
    3174:	d8 c1       	rjmp	.+944    	; 0x3526 <main+0x137e>
    3176:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    317a:	80 34       	cpi	r24, 0x40	; 64
    317c:	08 f4       	brcc	.+2      	; 0x3180 <main+0xfd8>
    317e:	fd c9       	rjmp	.-3078   	; 0x257a <main+0x3d2>
    3180:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3184:	fa c9       	rjmp	.-3084   	; 0x257a <main+0x3d2>
    3186:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    318a:	8f 5f       	subi	r24, 0xFF	; 255
    318c:	80 93 7b 04 	sts	0x047B, r24
    3190:	4e ca       	rjmp	.-2916   	; 0x262e <main+0x486>
    3192:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3196:	f0 e0       	ldi	r31, 0x00	; 0
    3198:	e3 58       	subi	r30, 0x83	; 131
    319a:	fb 4f       	sbci	r31, 0xFB	; 251
    319c:	82 e0       	ldi	r24, 0x02	; 2
    319e:	80 83       	st	Z, r24
    31a0:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    31a4:	8f 5f       	subi	r24, 0xFF	; 255
    31a6:	80 93 7c 04 	sts	0x047C, r24
    31aa:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    31ae:	80 34       	cpi	r24, 0x40	; 64
    31b0:	10 f0       	brcs	.+4      	; 0x31b6 <main+0x100e>
    31b2:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    31b6:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    31ba:	80 91 7b 04 	lds	r24, 0x047B
    31be:	98 17       	cp	r25, r24
    31c0:	09 f4       	brne	.+2      	; 0x31c4 <main+0x101c>
    31c2:	bd c1       	rjmp	.+890    	; 0x353e <main+0x1396>
    31c4:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    31c8:	80 34       	cpi	r24, 0x40	; 64
    31ca:	08 f4       	brcc	.+2      	; 0x31ce <main+0x1026>
    31cc:	d4 c9       	rjmp	.-3160   	; 0x2576 <main+0x3ce>
    31ce:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    31d2:	d1 c9       	rjmp	.-3166   	; 0x2576 <main+0x3ce>
    31d4:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    31d8:	f0 e0       	ldi	r31, 0x00	; 0
    31da:	e3 58       	subi	r30, 0x83	; 131
    31dc:	fb 4f       	sbci	r31, 0xFB	; 251
    31de:	83 e0       	ldi	r24, 0x03	; 3
    31e0:	80 83       	st	Z, r24
    31e2:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    31e6:	8f 5f       	subi	r24, 0xFF	; 255
    31e8:	80 93 7c 04 	sts	0x047C, r24
    31ec:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    31f0:	80 34       	cpi	r24, 0x40	; 64
    31f2:	10 f0       	brcs	.+4      	; 0x31f8 <main+0x1050>
    31f4:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    31f8:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    31fc:	80 91 7b 04 	lds	r24, 0x047B
    3200:	98 17       	cp	r25, r24
    3202:	09 f4       	brne	.+2      	; 0x3206 <main+0x105e>
    3204:	ba c1       	rjmp	.+884    	; 0x357a <main+0x13d2>
    3206:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    320a:	80 34       	cpi	r24, 0x40	; 64
    320c:	08 f4       	brcc	.+2      	; 0x3210 <main+0x1068>
    320e:	e8 c9       	rjmp	.-3120   	; 0x25e0 <main+0x438>
    3210:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3214:	e5 c9       	rjmp	.-3126   	; 0x25e0 <main+0x438>
    3216:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    321a:	8f 5f       	subi	r24, 0xFF	; 255
    321c:	80 93 7b 04 	sts	0x047B, r24
    3220:	c4 ca       	rjmp	.-2680   	; 0x27aa <main+0x602>
    3222:	80 91 7b 04 	lds	r24, 0x047B
    3226:	8f 5f       	subi	r24, 0xFF	; 255
    3228:	80 93 7b 04 	sts	0x047B, r24
    322c:	54 ca       	rjmp	.-2904   	; 0x26d6 <main+0x52e>
    322e:	80 91 7b 04 	lds	r24, 0x047B
    3232:	8f 5f       	subi	r24, 0xFF	; 255
    3234:	80 93 7b 04 	sts	0x047B, r24
    3238:	83 ca       	rjmp	.-2810   	; 0x2740 <main+0x598>
    323a:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    323e:	f0 e0       	ldi	r31, 0x00	; 0
    3240:	e3 58       	subi	r30, 0x83	; 131
    3242:	fb 4f       	sbci	r31, 0xFB	; 251
    3244:	8b e0       	ldi	r24, 0x0B	; 11
    3246:	80 83       	st	Z, r24
    3248:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    324c:	8f 5f       	subi	r24, 0xFF	; 255
    324e:	80 93 7c 04 	sts	0x047C, r24
    3252:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    3256:	80 34       	cpi	r24, 0x40	; 64
    3258:	10 f0       	brcs	.+4      	; 0x325e <main+0x10b6>
    325a:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    325e:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    3262:	80 91 7b 04 	lds	r24, 0x047B
    3266:	98 17       	cp	r25, r24
    3268:	09 f4       	brne	.+2      	; 0x326c <main+0x10c4>
    326a:	3b c1       	rjmp	.+630    	; 0x34e2 <main+0x133a>
    326c:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    3270:	80 34       	cpi	r24, 0x40	; 64
    3272:	08 f4       	brcc	.+2      	; 0x3276 <main+0x10ce>
    3274:	40 ca       	rjmp	.-2944   	; 0x26f6 <main+0x54e>
    3276:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    327a:	3d ca       	rjmp	.-2950   	; 0x26f6 <main+0x54e>
    327c:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3280:	f0 e0       	ldi	r31, 0x00	; 0
    3282:	e3 58       	subi	r30, 0x83	; 131
    3284:	fb 4f       	sbci	r31, 0xFB	; 251
    3286:	8a e0       	ldi	r24, 0x0A	; 10
    3288:	80 83       	st	Z, r24
    328a:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    328e:	8f 5f       	subi	r24, 0xFF	; 255
    3290:	80 93 7c 04 	sts	0x047C, r24
    3294:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    3298:	80 34       	cpi	r24, 0x40	; 64
    329a:	10 f0       	brcs	.+4      	; 0x32a0 <main+0x10f8>
    329c:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    32a0:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    32a4:	80 91 7b 04 	lds	r24, 0x047B
    32a8:	98 17       	cp	r25, r24
    32aa:	09 f4       	brne	.+2      	; 0x32ae <main+0x1106>
    32ac:	4e c1       	rjmp	.+668    	; 0x354a <main+0x13a2>
    32ae:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    32b2:	80 34       	cpi	r24, 0x40	; 64
    32b4:	08 f4       	brcc	.+2      	; 0x32b8 <main+0x1110>
    32b6:	1d ca       	rjmp	.-3014   	; 0x26f2 <main+0x54a>
    32b8:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    32bc:	1a ca       	rjmp	.-3020   	; 0x26f2 <main+0x54a>
    32be:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    32c2:	f0 e0       	ldi	r31, 0x00	; 0
    32c4:	e3 58       	subi	r30, 0x83	; 131
    32c6:	fb 4f       	sbci	r31, 0xFB	; 251
    32c8:	83 e1       	ldi	r24, 0x13	; 19
    32ca:	80 83       	st	Z, r24
    32cc:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    32d0:	8f 5f       	subi	r24, 0xFF	; 255
    32d2:	80 93 7c 04 	sts	0x047C, r24
    32d6:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    32da:	80 34       	cpi	r24, 0x40	; 64
    32dc:	10 f0       	brcs	.+4      	; 0x32e2 <main+0x113a>
    32de:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    32e2:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    32e6:	80 91 7b 04 	lds	r24, 0x047B
    32ea:	98 17       	cp	r25, r24
    32ec:	09 f4       	brne	.+2      	; 0x32f0 <main+0x1148>
    32ee:	33 c1       	rjmp	.+614    	; 0x3556 <main+0x13ae>
    32f0:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    32f4:	80 34       	cpi	r24, 0x40	; 64
    32f6:	08 f4       	brcc	.+2      	; 0x32fa <main+0x1152>
    32f8:	33 ca       	rjmp	.-2970   	; 0x2760 <main+0x5b8>
    32fa:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    32fe:	30 ca       	rjmp	.-2976   	; 0x2760 <main+0x5b8>
    3300:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    3304:	8f 5f       	subi	r24, 0xFF	; 255
    3306:	80 93 7b 04 	sts	0x047B, r24
    330a:	e6 ca       	rjmp	.-2612   	; 0x28d8 <main+0x730>
    330c:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3310:	f0 e0       	ldi	r31, 0x00	; 0
    3312:	e3 58       	subi	r30, 0x83	; 131
    3314:	fb 4f       	sbci	r31, 0xFB	; 251
    3316:	82 e1       	ldi	r24, 0x12	; 18
    3318:	80 83       	st	Z, r24
    331a:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    331e:	8f 5f       	subi	r24, 0xFF	; 255
    3320:	80 93 7c 04 	sts	0x047C, r24
    3324:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    3328:	80 34       	cpi	r24, 0x40	; 64
    332a:	10 f0       	brcs	.+4      	; 0x3330 <main+0x1188>
    332c:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3330:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    3334:	80 91 7b 04 	lds	r24, 0x047B
    3338:	98 17       	cp	r25, r24
    333a:	09 f4       	brne	.+2      	; 0x333e <main+0x1196>
    333c:	24 c1       	rjmp	.+584    	; 0x3586 <main+0x13de>
    333e:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    3342:	80 34       	cpi	r24, 0x40	; 64
    3344:	08 f4       	brcc	.+2      	; 0x3348 <main+0x11a0>
    3346:	0a ca       	rjmp	.-3052   	; 0x275c <main+0x5b4>
    3348:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    334c:	07 ca       	rjmp	.-3058   	; 0x275c <main+0x5b4>
    334e:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3352:	f0 e0       	ldi	r31, 0x00	; 0
    3354:	e3 58       	subi	r30, 0x83	; 131
    3356:	fb 4f       	sbci	r31, 0xFB	; 251
    3358:	85 e1       	ldi	r24, 0x15	; 21
    335a:	80 83       	st	Z, r24
    335c:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3360:	8f 5f       	subi	r24, 0xFF	; 255
    3362:	80 93 7c 04 	sts	0x047C, r24
    3366:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    336a:	80 34       	cpi	r24, 0x40	; 64
    336c:	10 f0       	brcs	.+4      	; 0x3372 <main+0x11ca>
    336e:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3372:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    3376:	80 91 7b 04 	lds	r24, 0x047B
    337a:	98 17       	cp	r25, r24
    337c:	09 f4       	brne	.+2      	; 0x3380 <main+0x11d8>
    337e:	f1 c0       	rjmp	.+482    	; 0x3562 <main+0x13ba>
    3380:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    3384:	80 34       	cpi	r24, 0x40	; 64
    3386:	08 f4       	brcc	.+2      	; 0x338a <main+0x11e2>
    3388:	d5 ca       	rjmp	.-2646   	; 0x2934 <main+0x78c>
    338a:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    338e:	d2 ca       	rjmp	.-2652   	; 0x2934 <main+0x78c>
    3390:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3394:	f0 e0       	ldi	r31, 0x00	; 0
    3396:	e3 58       	subi	r30, 0x83	; 131
    3398:	fb 4f       	sbci	r31, 0xFB	; 251
    339a:	8f e0       	ldi	r24, 0x0F	; 15
    339c:	80 83       	st	Z, r24
    339e:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    33a2:	8f 5f       	subi	r24, 0xFF	; 255
    33a4:	80 93 7c 04 	sts	0x047C, r24
    33a8:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    33ac:	80 34       	cpi	r24, 0x40	; 64
    33ae:	10 f0       	brcs	.+4      	; 0x33b4 <main+0x120c>
    33b0:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    33b4:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    33b8:	80 91 7b 04 	lds	r24, 0x047B
    33bc:	98 17       	cp	r25, r24
    33be:	09 f4       	brne	.+2      	; 0x33c2 <main+0x121a>
    33c0:	e8 c0       	rjmp	.+464    	; 0x3592 <main+0x13ea>
    33c2:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    33c6:	80 34       	cpi	r24, 0x40	; 64
    33c8:	08 f4       	brcc	.+2      	; 0x33cc <main+0x1224>
    33ca:	61 ca       	rjmp	.-2878   	; 0x288e <main+0x6e6>
    33cc:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    33d0:	5e ca       	rjmp	.-2884   	; 0x288e <main+0x6e6>
    33d2:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    33d6:	f0 e0       	ldi	r31, 0x00	; 0
    33d8:	e3 58       	subi	r30, 0x83	; 131
    33da:	fb 4f       	sbci	r31, 0xFB	; 251
    33dc:	84 e1       	ldi	r24, 0x14	; 20
    33de:	80 83       	st	Z, r24
    33e0:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    33e4:	8f 5f       	subi	r24, 0xFF	; 255
    33e6:	80 93 7c 04 	sts	0x047C, r24
    33ea:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    33ee:	80 34       	cpi	r24, 0x40	; 64
    33f0:	10 f0       	brcs	.+4      	; 0x33f6 <main+0x124e>
    33f2:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    33f6:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    33fa:	80 91 7b 04 	lds	r24, 0x047B
    33fe:	98 17       	cp	r25, r24
    3400:	09 f4       	brne	.+2      	; 0x3404 <main+0x125c>
    3402:	b5 c0       	rjmp	.+362    	; 0x356e <main+0x13c6>
    3404:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    3408:	80 34       	cpi	r24, 0x40	; 64
    340a:	08 f4       	brcc	.+2      	; 0x340e <main+0x1266>
    340c:	91 ca       	rjmp	.-2782   	; 0x2930 <main+0x788>
    340e:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3412:	8e ca       	rjmp	.-2788   	; 0x2930 <main+0x788>
    3414:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3418:	f0 e0       	ldi	r31, 0x00	; 0
    341a:	e3 58       	subi	r30, 0x83	; 131
    341c:	fb 4f       	sbci	r31, 0xFB	; 251
    341e:	8e e0       	ldi	r24, 0x0E	; 14
    3420:	80 83       	st	Z, r24
    3422:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3426:	8f 5f       	subi	r24, 0xFF	; 255
    3428:	80 93 7c 04 	sts	0x047C, r24
    342c:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    3430:	80 34       	cpi	r24, 0x40	; 64
    3432:	10 f0       	brcs	.+4      	; 0x3438 <main+0x1290>
    3434:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3438:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    343c:	80 91 7b 04 	lds	r24, 0x047B
    3440:	98 17       	cp	r25, r24
    3442:	09 f4       	brne	.+2      	; 0x3446 <main+0x129e>
    3444:	42 c0       	rjmp	.+132    	; 0x34ca <main+0x1322>
    3446:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    344a:	80 34       	cpi	r24, 0x40	; 64
    344c:	08 f4       	brcc	.+2      	; 0x3450 <main+0x12a8>
    344e:	1d ca       	rjmp	.-3014   	; 0x288a <main+0x6e2>
    3450:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    3454:	1a ca       	rjmp	.-3020   	; 0x288a <main+0x6e2>
    3456:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    345a:	8f 5f       	subi	r24, 0xFF	; 255
    345c:	80 93 7b 04 	sts	0x047B, r24
    3460:	0d c9       	rjmp	.-3558   	; 0x267c <main+0x4d4>
    3462:	80 91 71 00 	lds	r24, 0x0071
          g_current_music++;
        }
        g_music_duration = calc_note_duration(pgm_read_word(g_current_music));
        g_current_music++;
        if (pgm_read_word(g_current_music) == MUSIC_P) { // pause check (silence for a certain time)
          TIMSK3 &= ~(1 << OCIE3A); // disable interrupt
    3466:	8d 7f       	andi	r24, 0xFD	; 253
    3468:	80 93 71 00 	sts	0x0071, r24
    346c:	5d 98       	cbi	0x0b, 5	; 11
          PORT_C90_BUZZER &= ~(1 << PIN_C90_BUZZER);
    346e:	f1 c9       	rjmp	.-3102   	; 0x2852 <main+0x6aa>
    3470:	42 98       	cbi	0x08, 2	; 8
    } else if (FLAG_ALARM_BLINK) {
      FLAG_ALARM_BLINK = 0;
      if (g_alarm_blink_counter % 4 == 0) { // blink for 1 tick every timer1 4 counts
        PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      } else {
        PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
    3472:	3e cd       	rjmp	.-1412   	; 0x2ef0 <main+0xd48>
    3474:	e0 91 7c 04 	lds	r30, 0x047C
    return EV_VOID; // just keep returning a void event
  }
}

void set_event(uint8_t ev) {
  g_event_buffer[g_buffer_head] = ev; // insert event at head position
    3478:	f0 e0       	ldi	r31, 0x00	; 0
    347a:	e3 58       	subi	r30, 0x83	; 131
    347c:	fb 4f       	sbci	r31, 0xFB	; 251
    347e:	8d e0       	ldi	r24, 0x0D	; 13
    3480:	80 83       	st	Z, r24
    3482:	80 91 7c 04 	lds	r24, 0x047C
  g_buffer_head++; // advance head
    3486:	8f 5f       	subi	r24, 0xFF	; 255
    3488:	80 93 7c 04 	sts	0x047C, r24
    348c:	80 91 7c 04 	lds	r24, 0x047C
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    3490:	80 34       	cpi	r24, 0x40	; 64
    3492:	10 f0       	brcs	.+4      	; 0x3498 <main+0x12f0>
    3494:	10 92 7c 04 	sts	0x047C, r1
    g_buffer_head = 0; // cycle back to start
    3498:	90 91 7c 04 	lds	r25, 0x047C
  }
  if (g_buffer_head == g_buffer_tail) {
    349c:	80 91 7b 04 	lds	r24, 0x047B
    34a0:	98 13       	cpse	r25, r24
    34a2:	05 c0       	rjmp	.+10     	; 0x34ae <main+0x1306>
    34a4:	80 91 7b 04 	lds	r24, 0x047B
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    34a8:	8f 5f       	subi	r24, 0xFF	; 255
    34aa:	80 93 7b 04 	sts	0x047B, r24
    34ae:	80 91 7b 04 	lds	r24, 0x047B
  }
  if (g_buffer_tail >= C90_EVENT_BUFFER_SIZE) {
    34b2:	80 34       	cpi	r24, 0x40	; 64
    34b4:	08 f4       	brcc	.+2      	; 0x34b8 <main+0x1310>
    34b6:	ea c8       	rjmp	.-3628   	; 0x268c <main+0x4e4>
    34b8:	10 92 7b 04 	sts	0x047B, r1
    g_buffer_tail = 0; // cycle back to start
    34bc:	e7 c8       	rjmp	.-3634   	; 0x268c <main+0x4e4>
    34be:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    34c2:	8f 5f       	subi	r24, 0xFF	; 255
    34c4:	80 93 7b 04 	sts	0x047B, r24
    34c8:	fc ca       	rjmp	.-2568   	; 0x2ac2 <main+0x91a>
    34ca:	80 91 7b 04 	lds	r24, 0x047B
    34ce:	8f 5f       	subi	r24, 0xFF	; 255
    34d0:	80 93 7b 04 	sts	0x047B, r24
    34d4:	b8 cf       	rjmp	.-144    	; 0x3446 <main+0x129e>
    34d6:	80 91 7b 04 	lds	r24, 0x047B
    34da:	8f 5f       	subi	r24, 0xFF	; 255
    34dc:	80 93 7b 04 	sts	0x047B, r24
    34e0:	29 ce       	rjmp	.-942    	; 0x3134 <main+0xf8c>
    34e2:	80 91 7b 04 	lds	r24, 0x047B
    34e6:	8f 5f       	subi	r24, 0xFF	; 255
    34e8:	80 93 7b 04 	sts	0x047B, r24
    34ec:	bf ce       	rjmp	.-642    	; 0x326c <main+0x10c4>
    34ee:	91 95       	neg	r25
      if (g_alarm_blink_counter % 4 == 0) { // blink for 1 tick every timer1 4 counts
        PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      } else {
        PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      }
      if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
    34f0:	81 95       	neg	r24
    34f2:	91 09       	sbc	r25, r1
    34f4:	0c cd       	rjmp	.-1512   	; 0x2f0e <main+0xd66>
    34f6:	20 93 d3 04 	sts	0x04D3, r18
void check_sound() {
  if (FLAG_MUSIC) {
    if (!g_music_duration) {
      if (pgm_read_word(g_current_music)) { // get note data until MUSIC_END
        if (g_current_music == g_selected_music) { // still at start: first byte is the tempo
          g_music_tempo = pgm_read_word(g_current_music);
    34fa:	02 96       	adiw	r24, 0x02	; 2
    34fc:	62 2f       	mov	r22, r18
          g_current_music++;
    34fe:	9c 01       	movw	r18, r24
    3500:	84 c9       	rjmp	.-3320   	; 0x280a <main+0x662>
    3502:	80 91 7b 04 	lds	r24, 0x047B
  g_buffer_head++; // advance head
  if (g_buffer_head >= C90_EVENT_BUFFER_SIZE) {
    g_buffer_head = 0; // cycle back to start
  }
  if (g_buffer_head == g_buffer_tail) {
    g_buffer_tail++; // also move tail, basically destroying an event to make space
    3506:	8f 5f       	subi	r24, 0xFF	; 255
    3508:	80 93 7b 04 	sts	0x047B, r24
    350c:	8b cd       	rjmp	.-1258   	; 0x3024 <main+0xe7c>
    350e:	80 91 7b 04 	lds	r24, 0x047B
    3512:	8f 5f       	subi	r24, 0xFF	; 255
    3514:	80 93 7b 04 	sts	0x047B, r24
    3518:	cc cd       	rjmp	.-1128   	; 0x30b2 <main+0xf0a>
    351a:	80 91 7b 04 	lds	r24, 0x047B
    351e:	8f 5f       	subi	r24, 0xFF	; 255
    3520:	80 93 7b 04 	sts	0x047B, r24
    3524:	a0 cd       	rjmp	.-1216   	; 0x3066 <main+0xebe>
    3526:	80 91 7b 04 	lds	r24, 0x047B
    352a:	8f 5f       	subi	r24, 0xFF	; 255
    352c:	80 93 7b 04 	sts	0x047B, r24
    3530:	22 ce       	rjmp	.-956    	; 0x3176 <main+0xfce>
    3532:	80 91 7b 04 	lds	r24, 0x047B
    3536:	8f 5f       	subi	r24, 0xFF	; 255
    3538:	80 93 7b 04 	sts	0x047B, r24
    353c:	da cd       	rjmp	.-1100   	; 0x30f2 <main+0xf4a>
    353e:	80 91 7b 04 	lds	r24, 0x047B
    3542:	8f 5f       	subi	r24, 0xFF	; 255
    3544:	80 93 7b 04 	sts	0x047B, r24
    3548:	3d ce       	rjmp	.-902    	; 0x31c4 <main+0x101c>
    354a:	80 91 7b 04 	lds	r24, 0x047B
    354e:	8f 5f       	subi	r24, 0xFF	; 255
    3550:	80 93 7b 04 	sts	0x047B, r24
    3554:	ac ce       	rjmp	.-680    	; 0x32ae <main+0x1106>
    3556:	80 91 7b 04 	lds	r24, 0x047B
    355a:	8f 5f       	subi	r24, 0xFF	; 255
    355c:	80 93 7b 04 	sts	0x047B, r24
    3560:	c7 ce       	rjmp	.-626    	; 0x32f0 <main+0x1148>
    3562:	80 91 7b 04 	lds	r24, 0x047B
    3566:	8f 5f       	subi	r24, 0xFF	; 255
    3568:	80 93 7b 04 	sts	0x047B, r24
    356c:	09 cf       	rjmp	.-494    	; 0x3380 <main+0x11d8>
    356e:	80 91 7b 04 	lds	r24, 0x047B
    3572:	8f 5f       	subi	r24, 0xFF	; 255
    3574:	80 93 7b 04 	sts	0x047B, r24
    3578:	45 cf       	rjmp	.-374    	; 0x3404 <main+0x125c>
    357a:	80 91 7b 04 	lds	r24, 0x047B
    357e:	8f 5f       	subi	r24, 0xFF	; 255
    3580:	80 93 7b 04 	sts	0x047B, r24
    3584:	40 ce       	rjmp	.-896    	; 0x3206 <main+0x105e>
    3586:	80 91 7b 04 	lds	r24, 0x047B
    358a:	8f 5f       	subi	r24, 0xFF	; 255
    358c:	80 93 7b 04 	sts	0x047B, r24
    3590:	d6 ce       	rjmp	.-596    	; 0x333e <main+0x1196>
    3592:	80 91 7b 04 	lds	r24, 0x047B
    3596:	8f 5f       	subi	r24, 0xFF	; 255
    3598:	80 93 7b 04 	sts	0x047B, r24
    359c:	12 cf       	rjmp	.-476    	; 0x33c2 <main+0x121a>
    359e:	91 95       	neg	r25
      } else {
        PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      }
      if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
       (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
       (abs(g_adc_voltage[3] - g_alarm_snapshot[2]) > g_settings.alarm_trigger)) {
    35a0:	81 95       	neg	r24
    35a2:	91 09       	sbc	r25, r1
    35a4:	d2 cc       	rjmp	.-1628   	; 0x2f4a <main+0xda2>
    35a6:	91 95       	neg	r25
        PORT_C90_LIGHT_INDICATOR_COCKPIT |= (1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      } else {
        PORT_C90_LIGHT_INDICATOR_COCKPIT &= ~(1 << PIN_C90_LIGHT_INDICATOR_COCKPIT);
      }
      if ((abs(g_adc_voltage[1] - g_alarm_snapshot[0]) > g_settings.alarm_trigger) ||
       (abs(g_adc_voltage[2] - g_alarm_snapshot[1]) > g_settings.alarm_trigger) || 
    35a8:	81 95       	neg	r24
    35aa:	91 09       	sbc	r25, r1
    35ac:	bf cc       	rjmp	.-1666   	; 0x2f2c <main+0xd84>

000035ae <uart_init>:
#include  "usart.h"

// Initialization
// NOTE that I'm using the UART1 rx/tx pins of the atmega1284p, not UART0
void uart_init() {
  cli(); // Disable global interrupts
    35ae:	f8 94       	cli
  UBRR1 = ((F_CPU / (USART_BAUDRATE * 8UL)) - 1); // set baudrate, using 8 as multiplier because we set U2X1
    35b0:	81 e8       	ldi	r24, 0x81	; 129
    35b2:	90 e0       	ldi	r25, 0x00	; 0
    35b4:	90 93 cd 00 	sts	0x00CD, r25
    35b8:	80 93 cc 00 	sts	0x00CC, r24
	UCSR1A = (1 << U2X1); // enable 2x speed
    35bc:	82 e0       	ldi	r24, 0x02	; 2
    35be:	80 93 c8 00 	sts	0x00C8, r24
  // Turn on the reception and transmission circuitry and Reception Complete Interrupt
	UCSR1B = (1 << RXEN1) | (1 << TXEN1) | (1 << RXCIE1);
    35c2:	88 e9       	ldi	r24, 0x98	; 152
    35c4:	80 93 c9 00 	sts	0x00C9, r24
	UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // set 8 bits data size (default no parity bit, 1 stop bit)
    35c8:	86 e0       	ldi	r24, 0x06	; 6
    35ca:	80 93 ca 00 	sts	0x00CA, r24
  tx_buffer_head = tx_buffer_tail = 0; // init buffer
    35ce:	10 92 dc 07 	sts	0x07DC, r1
    35d2:	10 92 dd 07 	sts	0x07DD, r1
  rx_buffer_head = rx_buffer_tail = 0; // init buffer
    35d6:	10 92 da 06 	sts	0x06DA, r1
    35da:	10 92 db 06 	sts	0x06DB, r1
  sei(); // Enable global interrupts
    35de:	78 94       	sei
    35e0:	08 95       	ret

000035e2 <uart_put>:
}

// Transmit a byte
void uart_put(uint8_t c) {
	uint8_t i;
	i = tx_buffer_head + 1; // advance head
    35e2:	20 91 dd 07 	lds	r18, 0x07DD
    35e6:	2f 5f       	subi	r18, 0xFF	; 255
	if (i >= TX_BUFFER_SIZE) i = 0; // go to first index if buffer full
  // NOTE: the hard wait below is not desirable when big, fast UART transfers are part of the main program loop,
  // in that case, better change it to an if (tx_buffer_tail != i) to prevent delays of other program parts
	while (tx_buffer_tail == i); // wait until space in buffer
    35e8:	90 91 dc 07 	lds	r25, 0x07DC
    35ec:	92 17       	cp	r25, r18
    35ee:	e1 f3       	breq	.-8      	; 0x35e8 <uart_put+0x6>
  tx_buffer[i] = c; // put char in buffer
    35f0:	e2 2f       	mov	r30, r18
    35f2:	f0 e0       	ldi	r31, 0x00	; 0
    35f4:	e2 52       	subi	r30, 0x22	; 34
    35f6:	f8 4f       	sbci	r31, 0xF8	; 248
    35f8:	80 83       	st	Z, r24
  tx_buffer_head = i; // set new head
    35fa:	20 93 dd 07 	sts	0x07DD, r18
  // Turn on the reception and transmission circuitry and Reception Complete and
  // USART Data Register Empty interrupts
  UCSR1B = (1<<RXEN1) | (1<<TXEN1) | (1<<RXCIE1) | (1<<UDRIE1);
    35fe:	88 eb       	ldi	r24, 0xB8	; 184
    3600:	80 93 c9 00 	sts	0x00C9, r24
    3604:	08 95       	ret

00003606 <uart_get>:
}

// Receive a byte, NOTE: always call uart_available() first, before this function
uint8_t uart_get(void) {
  uint8_t c, i;
  i = rx_buffer_tail + 1; // advance tail
    3606:	90 91 da 06 	lds	r25, 0x06DA
    360a:	9f 5f       	subi	r25, 0xFF	; 255
  if (i >= RX_BUFFER_SIZE) i = 0; // got to first index if buffer full
  c = rx_buffer[i]; // get char from buffer
    360c:	e9 2f       	mov	r30, r25
    360e:	f0 e0       	ldi	r31, 0x00	; 0
    3610:	e4 52       	subi	r30, 0x24	; 36
    3612:	f9 4f       	sbci	r31, 0xF9	; 249
    3614:	80 81       	ld	r24, Z
  rx_buffer_tail = i; // set new tail
    3616:	90 93 da 06 	sts	0x06DA, r25
  return c; // return char
}
    361a:	08 95       	ret

0000361c <uart_put_str>:

// Writes a string from flash to the uart
void uart_put_str(const char *str) {
	while (*str) {
    361c:	fc 01       	movw	r30, r24
    361e:	20 81       	ld	r18, Z
    3620:	22 23       	and	r18, r18
    3622:	b1 f0       	breq	.+44     	; 0x3650 <uart_put_str+0x34>
    3624:	dc 01       	movw	r26, r24
    3626:	11 96       	adiw	r26, 0x01	; 1
	while (tx_buffer_tail == i); // wait until space in buffer
  tx_buffer[i] = c; // put char in buffer
  tx_buffer_head = i; // set new head
  // Turn on the reception and transmission circuitry and Reception Complete and
  // USART Data Register Empty interrupts
  UCSR1B = (1<<RXEN1) | (1<<TXEN1) | (1<<RXCIE1) | (1<<UDRIE1);
    3628:	38 eb       	ldi	r19, 0xB8	; 184
}

// Transmit a byte
void uart_put(uint8_t c) {
	uint8_t i;
	i = tx_buffer_head + 1; // advance head
    362a:	90 91 dd 07 	lds	r25, 0x07DD
    362e:	9f 5f       	subi	r25, 0xFF	; 255
	if (i >= TX_BUFFER_SIZE) i = 0; // go to first index if buffer full
  // NOTE: the hard wait below is not desirable when big, fast UART transfers are part of the main program loop,
  // in that case, better change it to an if (tx_buffer_tail != i) to prevent delays of other program parts
	while (tx_buffer_tail == i); // wait until space in buffer
    3630:	80 91 dc 07 	lds	r24, 0x07DC
    3634:	98 17       	cp	r25, r24
    3636:	e1 f3       	breq	.-8      	; 0x3630 <uart_put_str+0x14>
  tx_buffer[i] = c; // put char in buffer
    3638:	e9 2f       	mov	r30, r25
    363a:	f0 e0       	ldi	r31, 0x00	; 0
    363c:	e2 52       	subi	r30, 0x22	; 34
    363e:	f8 4f       	sbci	r31, 0xF8	; 248
    3640:	20 83       	st	Z, r18
  tx_buffer_head = i; // set new head
    3642:	90 93 dd 07 	sts	0x07DD, r25
  // Turn on the reception and transmission circuitry and Reception Complete and
  // USART Data Register Empty interrupts
  UCSR1B = (1<<RXEN1) | (1<<TXEN1) | (1<<RXCIE1) | (1<<UDRIE1);
    3646:	30 93 c9 00 	sts	0x00C9, r19
  return c; // return char
}

// Writes a string from flash to the uart
void uart_put_str(const char *str) {
	while (*str) {
    364a:	2d 91       	ld	r18, X+
    364c:	21 11       	cpse	r18, r1
    364e:	ed cf       	rjmp	.-38     	; 0x362a <uart_put_str+0xe>
    3650:	08 95       	ret

00003652 <uart_put_str_P>:

// Writes a string from Flash (PROGMEM) to the uart
void uart_put_str_P(const char *str) {
	char c;
	while (1) {
		c = pgm_read_byte(str++);
    3652:	9c 01       	movw	r18, r24
    3654:	2f 5f       	subi	r18, 0xFF	; 255
    3656:	3f 4f       	sbci	r19, 0xFF	; 255
    3658:	fc 01       	movw	r30, r24
    365a:	84 91       	lpm	r24, Z
		if (!c) break;
    365c:	88 23       	and	r24, r24
    365e:	b1 f0       	breq	.+44     	; 0x368c <uart_put_str_P+0x3a>
    3660:	f9 01       	movw	r30, r18
	while (tx_buffer_tail == i); // wait until space in buffer
  tx_buffer[i] = c; // put char in buffer
  tx_buffer_head = i; // set new head
  // Turn on the reception and transmission circuitry and Reception Complete and
  // USART Data Register Empty interrupts
  UCSR1B = (1<<RXEN1) | (1<<TXEN1) | (1<<RXCIE1) | (1<<UDRIE1);
    3662:	38 eb       	ldi	r19, 0xB8	; 184
}

// Transmit a byte
void uart_put(uint8_t c) {
	uint8_t i;
	i = tx_buffer_head + 1; // advance head
    3664:	20 91 dd 07 	lds	r18, 0x07DD
    3668:	2f 5f       	subi	r18, 0xFF	; 255
	if (i >= TX_BUFFER_SIZE) i = 0; // go to first index if buffer full
  // NOTE: the hard wait below is not desirable when big, fast UART transfers are part of the main program loop,
  // in that case, better change it to an if (tx_buffer_tail != i) to prevent delays of other program parts
	while (tx_buffer_tail == i); // wait until space in buffer
    366a:	90 91 dc 07 	lds	r25, 0x07DC
    366e:	29 17       	cp	r18, r25
    3670:	e1 f3       	breq	.-8      	; 0x366a <uart_put_str_P+0x18>
  tx_buffer[i] = c; // put char in buffer
    3672:	a2 2f       	mov	r26, r18
    3674:	b0 e0       	ldi	r27, 0x00	; 0
    3676:	a2 52       	subi	r26, 0x22	; 34
    3678:	b8 4f       	sbci	r27, 0xF8	; 248
    367a:	8c 93       	st	X, r24
  tx_buffer_head = i; // set new head
    367c:	20 93 dd 07 	sts	0x07DD, r18
  // Turn on the reception and transmission circuitry and Reception Complete and
  // USART Data Register Empty interrupts
  UCSR1B = (1<<RXEN1) | (1<<TXEN1) | (1<<RXCIE1) | (1<<UDRIE1);
    3680:	30 93 c9 00 	sts	0x00C9, r19

// Writes a string from Flash (PROGMEM) to the uart
void uart_put_str_P(const char *str) {
	char c;
	while (1) {
		c = pgm_read_byte(str++);
    3684:	84 91       	lpm	r24, Z
    3686:	31 96       	adiw	r30, 0x01	; 1
		if (!c) break;
    3688:	81 11       	cpse	r24, r1
    368a:	ec cf       	rjmp	.-40     	; 0x3664 <uart_put_str_P+0x12>
    368c:	08 95       	ret

0000368e <__vector_29>:
}

// USART1 data register empty Interrupt
// Move a character from the transmit buffer to the data register.
// If the transmit buffer is empty the UDRE interrupt is disabled until another uart_put() is called
ISR(USART1_UDRE_vect) {
    368e:	1f 92       	push	r1
    3690:	0f 92       	push	r0
    3692:	0f b6       	in	r0, 0x3f	; 63
    3694:	0f 92       	push	r0
    3696:	11 24       	eor	r1, r1
    3698:	0b b6       	in	r0, 0x3b	; 59
    369a:	0f 92       	push	r0
    369c:	8f 93       	push	r24
    369e:	9f 93       	push	r25
    36a0:	ef 93       	push	r30
    36a2:	ff 93       	push	r31
	uint8_t i;
	if (tx_buffer_head == tx_buffer_tail) {
    36a4:	90 91 dd 07 	lds	r25, 0x07DD
    36a8:	80 91 dc 07 	lds	r24, 0x07DC
    36ac:	98 17       	cp	r25, r24
    36ae:	b9 f0       	breq	.+46     	; 0x36de <__vector_29+0x50>
    UCSR1B &= ~(1 << UDRIE1); // buffer is empty, disable interrupt
	} else { // fill transmit register with next byte to send
		i = tx_buffer_tail + 1; // get tail + 1
    36b0:	80 91 dc 07 	lds	r24, 0x07DC
    36b4:	8f 5f       	subi	r24, 0xFF	; 255
		if (i >= TX_BUFFER_SIZE) i = 0; // go to first index if buffer full
		UDR1 = tx_buffer[i]; // send byte
    36b6:	e8 2f       	mov	r30, r24
    36b8:	f0 e0       	ldi	r31, 0x00	; 0
    36ba:	e2 52       	subi	r30, 0x22	; 34
    36bc:	f8 4f       	sbci	r31, 0xF8	; 248
    36be:	90 81       	ld	r25, Z
    36c0:	90 93 ce 00 	sts	0x00CE, r25
		tx_buffer_tail = i; // set new tail
    36c4:	80 93 dc 07 	sts	0x07DC, r24
	}
}
    36c8:	ff 91       	pop	r31
    36ca:	ef 91       	pop	r30
    36cc:	9f 91       	pop	r25
    36ce:	8f 91       	pop	r24
    36d0:	0f 90       	pop	r0
    36d2:	0b be       	out	0x3b, r0	; 59
    36d4:	0f 90       	pop	r0
    36d6:	0f be       	out	0x3f, r0	; 63
    36d8:	0f 90       	pop	r0
    36da:	1f 90       	pop	r1
    36dc:	18 95       	reti
// Move a character from the transmit buffer to the data register.
// If the transmit buffer is empty the UDRE interrupt is disabled until another uart_put() is called
ISR(USART1_UDRE_vect) {
	uint8_t i;
	if (tx_buffer_head == tx_buffer_tail) {
    UCSR1B &= ~(1 << UDRIE1); // buffer is empty, disable interrupt
    36de:	80 91 c9 00 	lds	r24, 0x00C9
    36e2:	8f 7d       	andi	r24, 0xDF	; 223
    36e4:	80 93 c9 00 	sts	0x00C9, r24
    36e8:	ef cf       	rjmp	.-34     	; 0x36c8 <__vector_29+0x3a>

000036ea <__vector_28>:
		tx_buffer_tail = i; // set new tail
	}
}

// Receive Complete Interrupt
ISR(USART1_RX_vect) {
    36ea:	1f 92       	push	r1
    36ec:	0f 92       	push	r0
    36ee:	0f b6       	in	r0, 0x3f	; 63
    36f0:	0f 92       	push	r0
    36f2:	11 24       	eor	r1, r1
    36f4:	0b b6       	in	r0, 0x3b	; 59
    36f6:	0f 92       	push	r0
    36f8:	2f 93       	push	r18
    36fa:	8f 93       	push	r24
    36fc:	9f 93       	push	r25
    36fe:	ef 93       	push	r30
    3700:	ff 93       	push	r31
	uint8_t c, i;
	c = UDR1; // receive byte
    3702:	20 91 ce 00 	lds	r18, 0x00CE
	i = rx_buffer_head + 1; // advance head 
    3706:	80 91 db 06 	lds	r24, 0x06DB
    370a:	8f 5f       	subi	r24, 0xFF	; 255
	if (i >= RX_BUFFER_SIZE) i = 0; // go to first index if buffer full
	if (i != rx_buffer_tail) { // not full
    370c:	90 91 da 06 	lds	r25, 0x06DA
    3710:	89 17       	cp	r24, r25
    3712:	39 f0       	breq	.+14     	; 0x3722 <__vector_28+0x38>
		rx_buffer[i] = c; // put in read buffer
    3714:	e8 2f       	mov	r30, r24
    3716:	f0 e0       	ldi	r31, 0x00	; 0
    3718:	e4 52       	subi	r30, 0x24	; 36
    371a:	f9 4f       	sbci	r31, 0xF9	; 249
    371c:	20 83       	st	Z, r18
		rx_buffer_head = i; // set new head
    371e:	80 93 db 06 	sts	0x06DB, r24
	}
}
    3722:	ff 91       	pop	r31
    3724:	ef 91       	pop	r30
    3726:	9f 91       	pop	r25
    3728:	8f 91       	pop	r24
    372a:	2f 91       	pop	r18
    372c:	0f 90       	pop	r0
    372e:	0b be       	out	0x3b, r0	; 59
    3730:	0f 90       	pop	r0
    3732:	0f be       	out	0x3f, r0	; 63
    3734:	0f 90       	pop	r0
    3736:	1f 90       	pop	r1
    3738:	18 95       	reti

0000373a <uart_available>:
// Return the number of bytes waiting in the receive buffer.
// Call this before uart_get() to check if it will need
// to wait for a byte to arrive.
uint8_t uart_available(void) {
	uint8_t head, tail;
	head = rx_buffer_head;
    373a:	80 91 db 06 	lds	r24, 0x06DB
	tail = rx_buffer_tail;
    373e:	90 91 da 06 	lds	r25, 0x06DA
	if (head >= tail) return head - tail; // return count of bytes inbetween
	return RX_BUFFER_SIZE + head - tail; // head has rolled over to start, return count of bytes inbetween
}
    3742:	89 1b       	sub	r24, r25
    3744:	08 95       	ret

00003746 <command_register>:
  g_output = output;
  // register generic commands
  show_prompt();
}

uint8_t command_register(const char *cmd, const char *info, uint8_t priv, void (*handler)(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE])) {
    3746:	8f 92       	push	r8
    3748:	9f 92       	push	r9
    374a:	bf 92       	push	r11
    374c:	cf 92       	push	r12
    374e:	df 92       	push	r13
    3750:	ef 92       	push	r14
    3752:	ff 92       	push	r15
    3754:	0f 93       	push	r16
    3756:	1f 93       	push	r17
    3758:	cf 93       	push	r28
    375a:	df 93       	push	r29
    375c:	1f 92       	push	r1
    375e:	cd b7       	in	r28, 0x3d	; 61
    3760:	de b7       	in	r29, 0x3e	; 62
    3762:	7c 01       	movw	r14, r24
    3764:	6b 01       	movw	r12, r22
    3766:	89 01       	movw	r16, r18
  g_handlers[g_handler_pos].cmd = malloc(sizeof(tCommand));
    3768:	b0 90 e2 09 	lds	r11, 0x09E2
    376c:	8b 2c       	mov	r8, r11
    376e:	91 2c       	mov	r9, r1
    3770:	85 e0       	ldi	r24, 0x05	; 5
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	49 83       	std	Y+1, r20	; 0x01
    3776:	0e 94 a9 24 	call	0x4952	; 0x4952 <malloc>
    377a:	fc 01       	movw	r30, r24
    377c:	c4 01       	movw	r24, r8
    377e:	88 0f       	add	r24, r24
    3780:	99 1f       	adc	r25, r25
    3782:	88 0f       	add	r24, r24
    3784:	99 1f       	adc	r25, r25
    3786:	8e 51       	subi	r24, 0x1E	; 30
    3788:	97 4f       	sbci	r25, 0xF7	; 247
    378a:	dc 01       	movw	r26, r24
    378c:	11 96       	adiw	r26, 0x01	; 1
    378e:	fc 93       	st	X, r31
    3790:	ee 93       	st	-X, r30
  if (g_handlers[g_handler_pos].cmd == NULL) {
    3792:	49 81       	ldd	r20, Y+1	; 0x01
    3794:	30 97       	sbiw	r30, 0x00	; 0
    3796:	d1 f0       	breq	.+52     	; 0x37cc <command_register+0x86>
   return 0;  
  }
  g_handlers[g_handler_pos].cmd->cmd_info = info;
    3798:	d1 82       	std	Z+1, r13	; 0x01
    379a:	c0 82       	st	Z, r12
  g_handlers[g_handler_pos].cmd->cmd_text = cmd;
    379c:	f3 82       	std	Z+3, r15	; 0x03
    379e:	e2 82       	std	Z+2, r14	; 0x02
  g_handlers[g_handler_pos].cmd->privileged = priv;
    37a0:	44 83       	std	Z+4, r20	; 0x04
  g_handlers[g_handler_pos].cmd_cb_t = handler;
    37a2:	13 96       	adiw	r26, 0x03	; 3
    37a4:	1c 93       	st	X, r17
    37a6:	0e 93       	st	-X, r16
    37a8:	12 97       	sbiw	r26, 0x02	; 2
  g_handler_pos++;
    37aa:	b3 94       	inc	r11
    37ac:	b0 92 e2 09 	sts	0x09E2, r11
  return 1;
    37b0:	81 e0       	ldi	r24, 0x01	; 1
}
    37b2:	0f 90       	pop	r0
    37b4:	df 91       	pop	r29
    37b6:	cf 91       	pop	r28
    37b8:	1f 91       	pop	r17
    37ba:	0f 91       	pop	r16
    37bc:	ff 90       	pop	r15
    37be:	ef 90       	pop	r14
    37c0:	df 90       	pop	r13
    37c2:	cf 90       	pop	r12
    37c4:	bf 90       	pop	r11
    37c6:	9f 90       	pop	r9
    37c8:	8f 90       	pop	r8
    37ca:	08 95       	ret
}

uint8_t command_register(const char *cmd, const char *info, uint8_t priv, void (*handler)(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE])) {
  g_handlers[g_handler_pos].cmd = malloc(sizeof(tCommand));
  if (g_handlers[g_handler_pos].cmd == NULL) {
   return 0;  
    37cc:	80 e0       	ldi	r24, 0x00	; 0
    37ce:	f1 cf       	rjmp	.-30     	; 0x37b2 <command_register+0x6c>

000037d0 <command_launch>:
    }
    show_prompt();
  }
} 

uint8_t command_launch() {
    37d0:	1f 93       	push	r17
    37d2:	cf 93       	push	r28
    37d4:	df 93       	push	r29
  return CMD_HANDLER_SIZE; // no handler found
}

void clear_cmd_args() {
  for (int i = 0; i < CMD_MAX_ARGS; i++) {
    g_cmd_args[i][0] = '\0';
    37d6:	10 92 e3 09 	sts	0x09E3, r1
    37da:	10 92 03 0a 	sts	0x0A03, r1
    37de:	10 92 23 0a 	sts	0x0A23, r1
    37e2:	10 92 43 0a 	sts	0x0A43, r1
    37e6:	10 92 63 0a 	sts	0x0A63, r1
    37ea:	10 92 83 0a 	sts	0x0A83, r1
    37ee:	10 92 a3 0a 	sts	0x0AA3, r1
    37f2:	10 92 c3 0a 	sts	0x0AC3, r1
    37f6:	10 92 e3 0a 	sts	0x0AE3, r1
    37fa:	10 92 03 0b 	sts	0x0B03, r1
  clear_cmd_args(); // clear previous args
  // check input command to all registered commands
  for (i = 0; i < CMD_HANDLER_SIZE; i++) {
    cmd = g_handlers[i].cmd->cmd_text;
    x = 0;
    while (*cmd && (*cmd == g_cmd_input[x])) {
    37fe:	50 91 23 0c 	lds	r21, 0x0C23
    3802:	22 ee       	ldi	r18, 0xE2	; 226
    3804:	38 e0       	ldi	r19, 0x08	; 8
    3806:	10 e0       	ldi	r17, 0x00	; 0
  char const *cmd;
  char *arg_part;
  clear_cmd_args(); // clear previous args
  // check input command to all registered commands
  for (i = 0; i < CMD_HANDLER_SIZE; i++) {
    cmd = g_handlers[i].cmd->cmd_text;
    3808:	d9 01       	movw	r26, r18
    380a:	ed 91       	ld	r30, X+
    380c:	fc 91       	ld	r31, X
    380e:	c2 81       	ldd	r28, Z+2	; 0x02
    3810:	d3 81       	ldd	r29, Z+3	; 0x03
    x = 0;
    while (*cmd && (*cmd == g_cmd_input[x])) {
    3812:	88 81       	ld	r24, Y
    3814:	88 23       	and	r24, r24
    3816:	f1 f0       	breq	.+60     	; 0x3854 <command_launch+0x84>
    3818:	85 13       	cpse	r24, r21
    381a:	1c c0       	rjmp	.+56     	; 0x3854 <command_launch+0x84>
    381c:	de 01       	movw	r26, r28
    381e:	11 96       	adiw	r26, 0x01	; 1
  char *arg_part;
  clear_cmd_args(); // clear previous args
  // check input command to all registered commands
  for (i = 0; i < CMD_HANDLER_SIZE; i++) {
    cmd = g_handlers[i].cmd->cmd_text;
    x = 0;
    3820:	80 e0       	ldi	r24, 0x00	; 0
    3822:	07 c0       	rjmp	.+14     	; 0x3832 <command_launch+0x62>
    while (*cmd && (*cmd == g_cmd_input[x])) {
    3824:	e8 2f       	mov	r30, r24
    3826:	f0 e0       	ldi	r31, 0x00	; 0
    3828:	ed 5d       	subi	r30, 0xDD	; 221
    382a:	f3 4f       	sbci	r31, 0xF3	; 243
    382c:	40 81       	ld	r20, Z
    382e:	94 13       	cpse	r25, r20
    3830:	04 c0       	rjmp	.+8      	; 0x383a <command_launch+0x6a>
      x++;
    3832:	8f 5f       	subi	r24, 0xFF	; 255
  clear_cmd_args(); // clear previous args
  // check input command to all registered commands
  for (i = 0; i < CMD_HANDLER_SIZE; i++) {
    cmd = g_handlers[i].cmd->cmd_text;
    x = 0;
    while (*cmd && (*cmd == g_cmd_input[x])) {
    3834:	9d 91       	ld	r25, X+
    3836:	91 11       	cpse	r25, r1
    3838:	f5 cf       	rjmp	.-22     	; 0x3824 <command_launch+0x54>
      x++;
      cmd++;
    }
    // input command string matches a fully registered command string
    if ((x) && (x == strlen(g_handlers[i].cmd->cmd_text))) {
    383a:	88 23       	and	r24, r24
    383c:	59 f0       	breq	.+22     	; 0x3854 <command_launch+0x84>
    383e:	fe 01       	movw	r30, r28
    3840:	01 90       	ld	r0, Z+
    3842:	00 20       	and	r0, r0
    3844:	e9 f7       	brne	.-6      	; 0x3840 <command_launch+0x70>
    3846:	31 97       	sbiw	r30, 0x01	; 1
    3848:	ec 1b       	sub	r30, r28
    384a:	fd 0b       	sbc	r31, r29
    384c:	90 e0       	ldi	r25, 0x00	; 0
    384e:	8e 17       	cp	r24, r30
    3850:	9f 07       	cpc	r25, r31
    3852:	51 f0       	breq	.+20     	; 0x3868 <command_launch+0x98>
  uint8_t i, x, n = 0;
  char const *cmd;
  char *arg_part;
  clear_cmd_args(); // clear previous args
  // check input command to all registered commands
  for (i = 0; i < CMD_HANDLER_SIZE; i++) {
    3854:	1f 5f       	subi	r17, 0xFF	; 255
    3856:	2c 5f       	subi	r18, 0xFC	; 252
    3858:	3f 4f       	sbci	r19, 0xFF	; 255
    385a:	10 34       	cpi	r17, 0x40	; 64
    385c:	a9 f6       	brne	.-86     	; 0x3808 <command_launch+0x38>
        arg_part = strtok(NULL, " ");
      }
      return i; // handler index
    }
  }
  return CMD_HANDLER_SIZE; // no handler found
    385e:	80 e4       	ldi	r24, 0x40	; 64
}
    3860:	df 91       	pop	r29
    3862:	cf 91       	pop	r28
    3864:	1f 91       	pop	r17
    3866:	08 95       	ret
      x++;
      cmd++;
    }
    // input command string matches a fully registered command string
    if ((x) && (x == strlen(g_handlers[i].cmd->cmd_text))) {
      arg_part = strtok(&g_cmd_input[x], " ");
    3868:	6c e7       	ldi	r22, 0x7C	; 124
    386a:	73 e0       	ldi	r23, 0x03	; 3
    386c:	8d 5d       	subi	r24, 0xDD	; 221
    386e:	93 4f       	sbci	r25, 0xF3	; 243
    3870:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <strtok>
    3874:	dc 01       	movw	r26, r24
      while (*arg_part) {
    3876:	8c 91       	ld	r24, X
    3878:	88 23       	and	r24, r24
    387a:	31 f1       	breq	.+76     	; 0x38c8 <command_launch+0xf8>
    show_prompt();
  }
} 

uint8_t command_launch() {
  uint8_t i, x, n = 0;
    387c:	c0 e0       	ldi	r28, 0x00	; 0
    387e:	0a c0       	rjmp	.+20     	; 0x3894 <command_launch+0xc4>
      arg_part = strtok(&g_cmd_input[x], " ");
      while (*arg_part) {
        if (strlen(arg_part) <= CMD_MAX_ARGS_SIZE) {
          strcpy(g_cmd_args[n++], arg_part);
        }
        arg_part = strtok(NULL, " ");
    3880:	6c e7       	ldi	r22, 0x7C	; 124
    3882:	73 e0       	ldi	r23, 0x03	; 3
    3884:	80 e0       	ldi	r24, 0x00	; 0
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <strtok>
    388c:	dc 01       	movw	r26, r24
      cmd++;
    }
    // input command string matches a fully registered command string
    if ((x) && (x == strlen(g_handlers[i].cmd->cmd_text))) {
      arg_part = strtok(&g_cmd_input[x], " ");
      while (*arg_part) {
    388e:	9c 91       	ld	r25, X
    3890:	99 23       	and	r25, r25
    3892:	d1 f0       	breq	.+52     	; 0x38c8 <command_launch+0xf8>
        if (strlen(arg_part) <= CMD_MAX_ARGS_SIZE) {
    3894:	fd 01       	movw	r30, r26
    3896:	01 90       	ld	r0, Z+
    3898:	00 20       	and	r0, r0
    389a:	e9 f7       	brne	.-6      	; 0x3896 <command_launch+0xc6>
    389c:	31 97       	sbiw	r30, 0x01	; 1
    389e:	ea 1b       	sub	r30, r26
    38a0:	fb 0b       	sbc	r31, r27
    38a2:	e1 32       	cpi	r30, 0x21	; 33
    38a4:	f1 05       	cpc	r31, r1
    38a6:	60 f7       	brcc	.-40     	; 0x3880 <command_launch+0xb0>
          strcpy(g_cmd_args[n++], arg_part);
    38a8:	d1 e0       	ldi	r29, 0x01	; 1
    38aa:	dc 0f       	add	r29, r28
    38ac:	20 e2       	ldi	r18, 0x20	; 32
    38ae:	c2 9f       	mul	r28, r18
    38b0:	c0 01       	movw	r24, r0
    38b2:	11 24       	eor	r1, r1
    38b4:	af 01       	movw	r20, r30
    38b6:	4f 5f       	subi	r20, 0xFF	; 255
    38b8:	5f 4f       	sbci	r21, 0xFF	; 255
    38ba:	bd 01       	movw	r22, r26
    38bc:	8d 51       	subi	r24, 0x1D	; 29
    38be:	96 4f       	sbci	r25, 0xF6	; 246
    38c0:	0e 94 92 27 	call	0x4f24	; 0x4f24 <memcpy>
    38c4:	cd 2f       	mov	r28, r29
    38c6:	dc cf       	rjmp	.-72     	; 0x3880 <command_launch+0xb0>
    38c8:	81 2f       	mov	r24, r17
      }
      return i; // handler index
    }
  }
  return CMD_HANDLER_SIZE; // no handler found
}
    38ca:	df 91       	pop	r29
    38cc:	cf 91       	pop	r28
    38ce:	1f 91       	pop	r17
    38d0:	08 95       	ret

000038d2 <show_prompt>:
  for (int i = 0; i < CMD_MAX_ARGS; i++) {
    g_cmd_args[i][0] = '\0';
  }
}

void show_prompt() {
    38d2:	cf 93       	push	r28
    38d4:	df 93       	push	r29
    38d6:	c9 ee       	ldi	r28, 0xE9	; 233
    38d8:	d2 e1       	ldi	r29, 0x12	; 18
  for (uint8_t i = 0; i < 4; i++) {
    g_output((const char*)pgm_read_word(&g_logo[i]), 1, 2);
    38da:	fe 01       	movw	r30, r28
    38dc:	85 91       	lpm	r24, Z+
    38de:	94 91       	lpm	r25, Z
    38e0:	e0 91 de 08 	lds	r30, 0x08DE
    38e4:	f0 91 df 08 	lds	r31, 0x08DF
    38e8:	42 e0       	ldi	r20, 0x02	; 2
    38ea:	61 e0       	ldi	r22, 0x01	; 1
    38ec:	09 95       	icall
    38ee:	22 96       	adiw	r28, 0x02	; 2
    g_cmd_args[i][0] = '\0';
  }
}

void show_prompt() {
  for (uint8_t i = 0; i < 4; i++) {
    38f0:	82 e1       	ldi	r24, 0x12	; 18
    38f2:	c1 3f       	cpi	r28, 0xF1	; 241
    38f4:	d8 07       	cpc	r29, r24
    38f6:	89 f7       	brne	.-30     	; 0x38da <show_prompt+0x8>
    g_output((const char*)pgm_read_word(&g_logo[i]), 1, 2);
  }
  g_output(g_user, 0, 0);
    38f8:	e0 91 de 08 	lds	r30, 0x08DE
    38fc:	f0 91 df 08 	lds	r31, 0x08DF
    3900:	40 e0       	ldi	r20, 0x00	; 0
    3902:	60 e0       	ldi	r22, 0x00	; 0
    3904:	80 91 98 01 	lds	r24, 0x0198
    3908:	90 91 99 01 	lds	r25, 0x0199
    390c:	09 95       	icall
  g_output("@", 0, 0);
    390e:	e0 91 de 08 	lds	r30, 0x08DE
    3912:	f0 91 df 08 	lds	r31, 0x08DF
    3916:	40 e0       	ldi	r20, 0x00	; 0
    3918:	60 e0       	ldi	r22, 0x00	; 0
    391a:	85 eb       	ldi	r24, 0xB5	; 181
    391c:	91 e0       	ldi	r25, 0x01	; 1
    391e:	09 95       	icall
  g_output(g_appname, 0, 0);
    3920:	e0 91 de 08 	lds	r30, 0x08DE
    3924:	f0 91 df 08 	lds	r31, 0x08DF
    3928:	40 e0       	ldi	r20, 0x00	; 0
    392a:	60 e0       	ldi	r22, 0x00	; 0
    392c:	80 91 9a 01 	lds	r24, 0x019A
    3930:	90 91 9b 01 	lds	r25, 0x019B
    3934:	09 95       	icall
  g_output("> ", 0, 0);
    3936:	e0 91 de 08 	lds	r30, 0x08DE
    393a:	f0 91 df 08 	lds	r31, 0x08DF
    393e:	40 e0       	ldi	r20, 0x00	; 0
    3940:	60 e0       	ldi	r22, 0x00	; 0
    3942:	87 eb       	ldi	r24, 0xB7	; 183
    3944:	91 e0       	ldi	r25, 0x01	; 1
}
    3946:	df 91       	pop	r29
    3948:	cf 91       	pop	r28
    g_output((const char*)pgm_read_word(&g_logo[i]), 1, 2);
  }
  g_output(g_user, 0, 0);
  g_output("@", 0, 0);
  g_output(g_appname, 0, 0);
  g_output("> ", 0, 0);
    394a:	09 94       	ijmp

0000394c <command_init>:
static void (*g_output)(const char*, uint8_t, uint8_t);

const char CMD_NOT_FOUND[] PROGMEM = "Command not found.";

void command_init(void (*input)(uint8_t event, char* cmd), void (*output)(const char* str, uint8_t flashmem, uint8_t clear)) {  
  g_input = input;
    394c:	90 93 e1 08 	sts	0x08E1, r25
    3950:	80 93 e0 08 	sts	0x08E0, r24
  g_output = output;
    3954:	70 93 df 08 	sts	0x08DF, r23
    3958:	60 93 de 08 	sts	0x08DE, r22
  // register generic commands
  show_prompt();
    395c:	ba cf       	rjmp	.-140    	; 0x38d2 <show_prompt>

0000395e <command_process>:
    395e:	e0 91 e0 08 	lds	r30, 0x08E0
  return 1;
}

void command_process() {
  uint8_t idx;
  g_input(0, g_cmd_input);
    3962:	f0 91 e1 08 	lds	r31, 0x08E1
    3966:	63 e2       	ldi	r22, 0x23	; 35
    3968:	7c e0       	ldi	r23, 0x0C	; 12
    396a:	80 e0       	ldi	r24, 0x00	; 0
    396c:	09 95       	icall
  if (*g_cmd_input) { // received a command string
    396e:	80 91 23 0c 	lds	r24, 0x0C23
    3972:	81 11       	cpse	r24, r1
    3974:	01 c0       	rjmp	.+2      	; 0x3978 <command_process+0x1a>
    3976:	08 95       	ret
    idx = command_launch();
    3978:	2b df       	rcall	.-426    	; 0x37d0 <command_launch>
    397a:	80 34       	cpi	r24, 0x40	; 64
    if (idx != CMD_HANDLER_SIZE) {
    397c:	d1 f0       	breq	.+52     	; 0x39b2 <command_process+0x54>
    397e:	e8 2f       	mov	r30, r24
      g_handlers[idx].cmd_cb_t(g_cmd_output, g_cmd_args); // call handler
    3980:	f0 e0       	ldi	r31, 0x00	; 0
    3982:	ee 0f       	add	r30, r30
    3984:	ff 1f       	adc	r31, r31
    3986:	ee 0f       	add	r30, r30
    3988:	ff 1f       	adc	r31, r31
    398a:	ee 51       	subi	r30, 0x1E	; 30
    398c:	f7 4f       	sbci	r31, 0xF7	; 247
    398e:	02 80       	ldd	r0, Z+2	; 0x02
    3990:	f3 81       	ldd	r31, Z+3	; 0x03
    3992:	e0 2d       	mov	r30, r0
    3994:	63 ee       	ldi	r22, 0xE3	; 227
    3996:	79 e0       	ldi	r23, 0x09	; 9
    3998:	83 e2       	ldi	r24, 0x23	; 35
    399a:	9b e0       	ldi	r25, 0x0B	; 11
    399c:	09 95       	icall
    399e:	e0 91 de 08 	lds	r30, 0x08DE
      g_output(g_cmd_output, 0, 3);
    39a2:	f0 91 df 08 	lds	r31, 0x08DF
    39a6:	43 e0       	ldi	r20, 0x03	; 3
    39a8:	60 e0       	ldi	r22, 0x00	; 0
    39aa:	83 e2       	ldi	r24, 0x23	; 35
    39ac:	9b e0       	ldi	r25, 0x0B	; 11
    39ae:	09 95       	icall
    39b0:	90 cf       	rjmp	.-224    	; 0x38d2 <show_prompt>
    } else {
      g_output(CMD_NOT_FOUND, 1, 3);
    }
    show_prompt();
    39b2:	e0 91 de 08 	lds	r30, 0x08DE
    idx = command_launch();
    if (idx != CMD_HANDLER_SIZE) {
      g_handlers[idx].cmd_cb_t(g_cmd_output, g_cmd_args); // call handler
      g_output(g_cmd_output, 0, 3);
    } else {
      g_output(CMD_NOT_FOUND, 1, 3);
    39b6:	f0 91 df 08 	lds	r31, 0x08DF
    39ba:	43 e0       	ldi	r20, 0x03	; 3
    39bc:	61 e0       	ldi	r22, 0x01	; 1
    39be:	89 e5       	ldi	r24, 0x59	; 89
    39c0:	93 e1       	ldi	r25, 0x13	; 19
    39c2:	09 95       	icall
    39c4:	86 cf       	rjmp	.-244    	; 0x38d2 <show_prompt>

000039c6 <command_handle_reset>:
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcpy(cmd_output, uart_buf);
}

void command_handle_reset(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  g_mcu_reset = 1;
    39c6:	21 e0       	ldi	r18, 0x01	; 1
    39c8:	20 93 36 12 	sts	0x1236, r18
  strcpy(cmd_output, "Resetting....");
    39cc:	2e e0       	ldi	r18, 0x0E	; 14
    39ce:	ea eb       	ldi	r30, 0xBA	; 186
    39d0:	f1 e0       	ldi	r31, 0x01	; 1
    39d2:	dc 01       	movw	r26, r24
    39d4:	01 90       	ld	r0, Z+
    39d6:	0d 92       	st	X+, r0
    39d8:	2a 95       	dec	r18
    39da:	e1 f7       	brne	.-8      	; 0x39d4 <command_handle_reset+0xe>
    39dc:	08 95       	ret

000039de <command_handle_show_version>:
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  return uart_buf;
}

void command_handle_show_version(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy_P(cmd_output, g_firmware_version);
    39de:	68 ec       	ldi	r22, 0xC8	; 200
    39e0:	72 e1       	ldi	r23, 0x12	; 18
    39e2:	0c 94 88 27 	jmp	0x4f10	; 0x4f10 <strcpy_P>

000039e6 <command_handle_set_sense>:

void command_handle_show_state(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy(cmd_output, display_state_info());
}

void command_handle_set_sense(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
    39e6:	0f 93       	push	r16
    39e8:	1f 93       	push	r17
    39ea:	cf 93       	push	r28
    39ec:	df 93       	push	r29
    39ee:	ec 01       	movw	r28, r24
    39f0:	8b 01       	movw	r16, r22
  g_senses = 0; // deactivate physical senses, because they can conflict
    39f2:	10 92 2c 10 	sts	0x102C, r1
    39f6:	10 92 2b 10 	sts	0x102B, r1
  g_dyn_senses = (uint16_t)(strtol(args[0], NULL, 2));
    39fa:	42 e0       	ldi	r20, 0x02	; 2
    39fc:	50 e0       	ldi	r21, 0x00	; 0
    39fe:	60 e0       	ldi	r22, 0x00	; 0
    3a00:	70 e0       	ldi	r23, 0x00	; 0
    3a02:	c8 01       	movw	r24, r16
    3a04:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <strtol>
    3a08:	70 93 40 12 	sts	0x1240, r23
    3a0c:	60 93 3f 12 	sts	0x123F, r22
  g_dyn_senses_status = (uint16_t)(strtol(args[1], NULL, 2));
    3a10:	42 e0       	ldi	r20, 0x02	; 2
    3a12:	50 e0       	ldi	r21, 0x00	; 0
    3a14:	60 e0       	ldi	r22, 0x00	; 0
    3a16:	70 e0       	ldi	r23, 0x00	; 0
    3a18:	c8 01       	movw	r24, r16
    3a1a:	80 96       	adiw	r24, 0x20	; 32
    3a1c:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <strtol>
    3a20:	70 93 42 12 	sts	0x1242, r23
    3a24:	60 93 41 12 	sts	0x1241, r22
  strcpy(cmd_output, "Senses updated.");
    3a28:	80 e1       	ldi	r24, 0x10	; 16
    3a2a:	e8 ec       	ldi	r30, 0xC8	; 200
    3a2c:	f1 e0       	ldi	r31, 0x01	; 1
    3a2e:	de 01       	movw	r26, r28
    3a30:	01 90       	ld	r0, Z+
    3a32:	0d 92       	st	X+, r0
    3a34:	8a 95       	dec	r24
    3a36:	e1 f7       	brne	.-8      	; 0x3a30 <command_handle_set_sense+0x4a>
}
    3a38:	df 91       	pop	r29
    3a3a:	cf 91       	pop	r28
    3a3c:	1f 91       	pop	r17
    3a3e:	0f 91       	pop	r16
    3a40:	08 95       	ret

00003a42 <command_handle_set_conf>:

void command_handle_set_conf(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
    3a42:	0f 93       	push	r16
    3a44:	1f 93       	push	r17
    3a46:	cf 93       	push	r28
    3a48:	df 93       	push	r29
    3a4a:	8c 01       	movw	r16, r24
    3a4c:	eb 01       	movw	r28, r22
  uint8_t success = 1;
  if (strcmp("dsc", args[0]) == 0) {
    3a4e:	88 ed       	ldi	r24, 0xD8	; 216
    3a50:	91 e0       	ldi	r25, 0x01	; 1
    3a52:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3a56:	89 2b       	or	r24, r25
    3a58:	09 f4       	brne	.+2      	; 0x3a5c <command_handle_set_conf+0x1a>
    3a5a:	79 c0       	rjmp	.+242    	; 0x3b4e <command_handle_set_conf+0x10c>
    eeprom_update_word(&g_rom_settings.deep_sleep_counter, (uint16_t)(atoi(args[1])));
  } else if (strcmp("st", args[0]) == 0) {
    3a5c:	be 01       	movw	r22, r28
    3a5e:	8d ed       	ldi	r24, 0xDD	; 221
    3a60:	91 e0       	ldi	r25, 0x01	; 1
    3a62:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3a66:	89 2b       	or	r24, r25
    3a68:	09 f4       	brne	.+2      	; 0x3a6c <command_handle_set_conf+0x2a>
    3a6a:	87 c0       	rjmp	.+270    	; 0x3b7a <command_handle_set_conf+0x138>
    eeprom_update_word(&g_rom_settings.settle_time, (uint16_t)(atoi(args[1])));
  } else if (strcmp("ast", args[0]) == 0) {
    3a6c:	be 01       	movw	r22, r28
    3a6e:	8c ed       	ldi	r24, 0xDC	; 220
    3a70:	91 e0       	ldi	r25, 0x01	; 1
    3a72:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3a76:	89 2b       	or	r24, r25
    3a78:	09 f4       	brne	.+2      	; 0x3a7c <command_handle_set_conf+0x3a>
    3a7a:	89 c0       	rjmp	.+274    	; 0x3b8e <command_handle_set_conf+0x14c>
    eeprom_update_word(&g_rom_settings.alarm_settle_time, (uint16_t)(atoi(args[1])));
  } else if (strcmp("is", args[0]) == 0) {
    3a7c:	be 01       	movw	r22, r28
    3a7e:	80 ee       	ldi	r24, 0xE0	; 224
    3a80:	91 e0       	ldi	r25, 0x01	; 1
    3a82:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3a86:	89 2b       	or	r24, r25
    3a88:	09 f4       	brne	.+2      	; 0x3a8c <command_handle_set_conf+0x4a>
    3a8a:	95 c0       	rjmp	.+298    	; 0x3bb6 <command_handle_set_conf+0x174>
    eeprom_update_byte(&g_rom_settings.indicator_sound, (uint8_t)(atoi(args[1])));
  } else if (strcmp("bs", args[0]) == 0) {
    3a8c:	be 01       	movw	r22, r28
    3a8e:	83 ee       	ldi	r24, 0xE3	; 227
    3a90:	91 e0       	ldi	r25, 0x01	; 1
    3a92:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3a96:	89 2b       	or	r24, r25
    3a98:	09 f4       	brne	.+2      	; 0x3a9c <command_handle_set_conf+0x5a>
    3a9a:	83 c0       	rjmp	.+262    	; 0x3ba2 <command_handle_set_conf+0x160>
    eeprom_update_word(&g_rom_settings.blink_speed, (uint16_t)(atoi(args[1])));
  } else if (strcmp("ac", args[0]) == 0) {
    3a9c:	be 01       	movw	r22, r28
    3a9e:	86 ee       	ldi	r24, 0xE6	; 230
    3aa0:	91 e0       	ldi	r25, 0x01	; 1
    3aa2:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3aa6:	89 2b       	or	r24, r25
    3aa8:	09 f4       	brne	.+2      	; 0x3aac <command_handle_set_conf+0x6a>
    3aaa:	8f c0       	rjmp	.+286    	; 0x3bca <command_handle_set_conf+0x188>
    eeprom_update_byte(&g_rom_settings.alarm_counter, (uint8_t)(atoi(args[1])));
  } else if (strcmp("at", args[0]) == 0) {
    3aac:	be 01       	movw	r22, r28
    3aae:	89 ee       	ldi	r24, 0xE9	; 233
    3ab0:	91 e0       	ldi	r25, 0x01	; 1
    3ab2:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3ab6:	89 2b       	or	r24, r25
    3ab8:	09 f4       	brne	.+2      	; 0x3abc <command_handle_set_conf+0x7a>
    3aba:	9b c0       	rjmp	.+310    	; 0x3bf2 <command_handle_set_conf+0x1b0>
    eeprom_update_byte(&g_rom_settings.alarm_trigger, (uint8_t)(atoi(args[1])));
  } else if (strcmp("atc", args[0]) == 0) {
    3abc:	be 01       	movw	r22, r28
    3abe:	8c ee       	ldi	r24, 0xEC	; 236
    3ac0:	91 e0       	ldi	r25, 0x01	; 1
    3ac2:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3ac6:	89 2b       	or	r24, r25
    3ac8:	09 f4       	brne	.+2      	; 0x3acc <command_handle_set_conf+0x8a>
    3aca:	9d c0       	rjmp	.+314    	; 0x3c06 <command_handle_set_conf+0x1c4>
    eeprom_update_byte(&g_rom_settings.alarm_trigger_counter, (uint8_t)(atoi(args[1])));
  } else if (strcmp("amint", args[0]) == 0) {
    3acc:	be 01       	movw	r22, r28
    3ace:	80 ef       	ldi	r24, 0xF0	; 240
    3ad0:	91 e0       	ldi	r25, 0x01	; 1
    3ad2:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3ad6:	89 2b       	or	r24, r25
    3ad8:	09 f4       	brne	.+2      	; 0x3adc <command_handle_set_conf+0x9a>
    3ada:	81 c0       	rjmp	.+258    	; 0x3bde <command_handle_set_conf+0x19c>
    eeprom_update_byte(&g_rom_settings.alarm_thres_min, (uint8_t)(atoi(args[1])));
  } else if (strcmp("amaxt", args[0]) == 0) {
    3adc:	be 01       	movw	r22, r28
    3ade:	86 ef       	ldi	r24, 0xF6	; 246
    3ae0:	91 e0       	ldi	r25, 0x01	; 1
    3ae2:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3ae6:	89 2b       	or	r24, r25
    3ae8:	09 f4       	brne	.+2      	; 0x3aec <command_handle_set_conf+0xaa>
    3aea:	97 c0       	rjmp	.+302    	; 0x3c1a <command_handle_set_conf+0x1d8>
    eeprom_update_word(&g_rom_settings.alarm_thres_max, (uint16_t)(atoi(args[1])));
  } else if (strcmp("bp", args[0]) == 0) {
    3aec:	be 01       	movw	r22, r28
    3aee:	8c ef       	ldi	r24, 0xFC	; 252
    3af0:	91 e0       	ldi	r25, 0x01	; 1
    3af2:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3af6:	89 2b       	or	r24, r25
    3af8:	09 f4       	brne	.+2      	; 0x3afc <command_handle_set_conf+0xba>
    3afa:	99 c0       	rjmp	.+306    	; 0x3c2e <command_handle_set_conf+0x1ec>
    eeprom_update_byte(&g_rom_settings.backpedal, (uint8_t)(atoi(args[1])));
  } else if (strcmp("bpt", args[0]) == 0) {
    3afc:	be 01       	movw	r22, r28
    3afe:	8f ef       	ldi	r24, 0xFF	; 255
    3b00:	91 e0       	ldi	r25, 0x01	; 1
    3b02:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3b06:	89 2b       	or	r24, r25
    3b08:	09 f4       	brne	.+2      	; 0x3b0c <command_handle_set_conf+0xca>
    3b0a:	9b c0       	rjmp	.+310    	; 0x3c42 <command_handle_set_conf+0x200>
    eeprom_update_word(&g_rom_settings.backpedal_thres_min, (uint16_t)(atoi(args[1])));
  } else if (strcmp("ss", args[0]) == 0) {
    3b0c:	be 01       	movw	r22, r28
    3b0e:	83 e0       	ldi	r24, 0x03	; 3
    3b10:	92 e0       	ldi	r25, 0x02	; 2
    3b12:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3b16:	89 2b       	or	r24, r25
    3b18:	09 f4       	brne	.+2      	; 0x3b1c <command_handle_set_conf+0xda>
    3b1a:	9d c0       	rjmp	.+314    	; 0x3c56 <command_handle_set_conf+0x214>
    eeprom_update_byte(&g_rom_settings.startup_sound, (uint8_t)(atoi(args[1])));
  } else if (strcmp("as", args[0]) == 0) {
    3b1c:	be 01       	movw	r22, r28
    3b1e:	86 e0       	ldi	r24, 0x06	; 6
    3b20:	92 e0       	ldi	r25, 0x02	; 2
    3b22:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3b26:	89 2b       	or	r24, r25
    3b28:	09 f4       	brne	.+2      	; 0x3b2c <command_handle_set_conf+0xea>
    3b2a:	9f c0       	rjmp	.+318    	; 0x3c6a <command_handle_set_conf+0x228>
    eeprom_update_byte(&g_rom_settings.alarm_sound, (uint8_t)(atoi(args[1])));
  } else if (strcmp("p", args[0]) == 0) {
    3b2c:	be 01       	movw	r22, r28
    3b2e:	8d ef       	ldi	r24, 0xFD	; 253
    3b30:	91 e0       	ldi	r25, 0x01	; 1
    3b32:	0e 94 9b 27 	call	0x4f36	; 0x4f36 <strcmp>
    3b36:	89 2b       	or	r24, r25
    3b38:	09 f4       	brne	.+2      	; 0x3b3c <command_handle_set_conf+0xfa>
    3b3a:	a1 c0       	rjmp	.+322    	; 0x3c7e <command_handle_set_conf+0x23c>
    success = 0;
  }
  if (success) {
    strcpy(cmd_output, "Update successful, RESET the device to use new values!");
  } else {
    strcpy(cmd_output, "Configuration options error! Use set conf [abbreviation] [value].");
    3b3c:	82 e4       	ldi	r24, 0x42	; 66
    3b3e:	e0 e4       	ldi	r30, 0x40	; 64
    3b40:	f2 e0       	ldi	r31, 0x02	; 2
    3b42:	d8 01       	movw	r26, r16
    3b44:	01 90       	ld	r0, Z+
    3b46:	0d 92       	st	X+, r0
    3b48:	8a 95       	dec	r24
    3b4a:	e1 f7       	brne	.-8      	; 0x3b44 <command_handle_set_conf+0x102>
    3b4c:	11 c0       	rjmp	.+34     	; 0x3b70 <command_handle_set_conf+0x12e>
}

void command_handle_set_conf(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  uint8_t success = 1;
  if (strcmp("dsc", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.deep_sleep_counter, (uint16_t)(atoi(args[1])));
    3b4e:	ce 01       	movw	r24, r28
    3b50:	80 96       	adiw	r24, 0x20	; 32
    3b52:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3b56:	bc 01       	movw	r22, r24
    3b58:	80 e0       	ldi	r24, 0x00	; 0
    3b5a:	90 e0       	ldi	r25, 0x00	; 0
    3b5c:	0e 94 2c 28 	call	0x5058	; 0x5058 <__eeupd_word_m1284p>
    eeprom_update_block(args[1], &g_rom_settings.passwd, 32);
  } else {
    success = 0;
  }
  if (success) {
    strcpy(cmd_output, "Update successful, RESET the device to use new values!");
    3b60:	87 e3       	ldi	r24, 0x37	; 55
    3b62:	e9 e0       	ldi	r30, 0x09	; 9
    3b64:	f2 e0       	ldi	r31, 0x02	; 2
    3b66:	d8 01       	movw	r26, r16
    3b68:	01 90       	ld	r0, Z+
    3b6a:	0d 92       	st	X+, r0
    3b6c:	8a 95       	dec	r24
    3b6e:	e1 f7       	brne	.-8      	; 0x3b68 <command_handle_set_conf+0x126>
  } else {
    strcpy(cmd_output, "Configuration options error! Use set conf [abbreviation] [value].");
  }
}
    3b70:	df 91       	pop	r29
    3b72:	cf 91       	pop	r28
    3b74:	1f 91       	pop	r17
    3b76:	0f 91       	pop	r16
    3b78:	08 95       	ret
void command_handle_set_conf(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  uint8_t success = 1;
  if (strcmp("dsc", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.deep_sleep_counter, (uint16_t)(atoi(args[1])));
  } else if (strcmp("st", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.settle_time, (uint16_t)(atoi(args[1])));
    3b7a:	ce 01       	movw	r24, r28
    3b7c:	80 96       	adiw	r24, 0x20	; 32
    3b7e:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3b82:	bc 01       	movw	r22, r24
    3b84:	82 e0       	ldi	r24, 0x02	; 2
    3b86:	90 e0       	ldi	r25, 0x00	; 0
    3b88:	0e 94 2c 28 	call	0x5058	; 0x5058 <__eeupd_word_m1284p>
    3b8c:	e9 cf       	rjmp	.-46     	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("ast", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.alarm_settle_time, (uint16_t)(atoi(args[1])));
    3b8e:	ce 01       	movw	r24, r28
    3b90:	80 96       	adiw	r24, 0x20	; 32
    3b92:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3b96:	bc 01       	movw	r22, r24
    3b98:	84 e0       	ldi	r24, 0x04	; 4
    3b9a:	90 e0       	ldi	r25, 0x00	; 0
    3b9c:	0e 94 2c 28 	call	0x5058	; 0x5058 <__eeupd_word_m1284p>
    3ba0:	df cf       	rjmp	.-66     	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("is", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.indicator_sound, (uint8_t)(atoi(args[1])));
  } else if (strcmp("bs", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.blink_speed, (uint16_t)(atoi(args[1])));
    3ba2:	ce 01       	movw	r24, r28
    3ba4:	80 96       	adiw	r24, 0x20	; 32
    3ba6:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3baa:	bc 01       	movw	r22, r24
    3bac:	87 e0       	ldi	r24, 0x07	; 7
    3bae:	90 e0       	ldi	r25, 0x00	; 0
    3bb0:	0e 94 2c 28 	call	0x5058	; 0x5058 <__eeupd_word_m1284p>
    3bb4:	d5 cf       	rjmp	.-86     	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("st", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.settle_time, (uint16_t)(atoi(args[1])));
  } else if (strcmp("ast", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.alarm_settle_time, (uint16_t)(atoi(args[1])));
  } else if (strcmp("is", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.indicator_sound, (uint8_t)(atoi(args[1])));
    3bb6:	ce 01       	movw	r24, r28
    3bb8:	80 96       	adiw	r24, 0x20	; 32
    3bba:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3bbe:	68 2f       	mov	r22, r24
    3bc0:	86 e0       	ldi	r24, 0x06	; 6
    3bc2:	90 e0       	ldi	r25, 0x00	; 0
    3bc4:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3bc8:	cb cf       	rjmp	.-106    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("bs", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.blink_speed, (uint16_t)(atoi(args[1])));
  } else if (strcmp("ac", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_counter, (uint8_t)(atoi(args[1])));
    3bca:	ce 01       	movw	r24, r28
    3bcc:	80 96       	adiw	r24, 0x20	; 32
    3bce:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3bd2:	68 2f       	mov	r22, r24
    3bd4:	89 e0       	ldi	r24, 0x09	; 9
    3bd6:	90 e0       	ldi	r25, 0x00	; 0
    3bd8:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3bdc:	c1 cf       	rjmp	.-126    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("at", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_trigger, (uint8_t)(atoi(args[1])));
  } else if (strcmp("atc", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_trigger_counter, (uint8_t)(atoi(args[1])));
  } else if (strcmp("amint", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_thres_min, (uint8_t)(atoi(args[1])));
    3bde:	ce 01       	movw	r24, r28
    3be0:	80 96       	adiw	r24, 0x20	; 32
    3be2:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3be6:	68 2f       	mov	r22, r24
    3be8:	8c e0       	ldi	r24, 0x0C	; 12
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3bf0:	b7 cf       	rjmp	.-146    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("bs", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.blink_speed, (uint16_t)(atoi(args[1])));
  } else if (strcmp("ac", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_counter, (uint8_t)(atoi(args[1])));
  } else if (strcmp("at", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_trigger, (uint8_t)(atoi(args[1])));
    3bf2:	ce 01       	movw	r24, r28
    3bf4:	80 96       	adiw	r24, 0x20	; 32
    3bf6:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3bfa:	68 2f       	mov	r22, r24
    3bfc:	8a e0       	ldi	r24, 0x0A	; 10
    3bfe:	90 e0       	ldi	r25, 0x00	; 0
    3c00:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3c04:	ad cf       	rjmp	.-166    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("atc", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_trigger_counter, (uint8_t)(atoi(args[1])));
    3c06:	ce 01       	movw	r24, r28
    3c08:	80 96       	adiw	r24, 0x20	; 32
    3c0a:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3c0e:	68 2f       	mov	r22, r24
    3c10:	8b e0       	ldi	r24, 0x0B	; 11
    3c12:	90 e0       	ldi	r25, 0x00	; 0
    3c14:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3c18:	a3 cf       	rjmp	.-186    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("amint", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_thres_min, (uint8_t)(atoi(args[1])));
  } else if (strcmp("amaxt", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.alarm_thres_max, (uint16_t)(atoi(args[1])));
    3c1a:	ce 01       	movw	r24, r28
    3c1c:	80 96       	adiw	r24, 0x20	; 32
    3c1e:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3c22:	bc 01       	movw	r22, r24
    3c24:	8d e0       	ldi	r24, 0x0D	; 13
    3c26:	90 e0       	ldi	r25, 0x00	; 0
    3c28:	0e 94 2c 28 	call	0x5058	; 0x5058 <__eeupd_word_m1284p>
    3c2c:	99 cf       	rjmp	.-206    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("bp", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.backpedal, (uint8_t)(atoi(args[1])));
    3c2e:	ce 01       	movw	r24, r28
    3c30:	80 96       	adiw	r24, 0x20	; 32
    3c32:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3c36:	68 2f       	mov	r22, r24
    3c38:	8f e0       	ldi	r24, 0x0F	; 15
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3c40:	8f cf       	rjmp	.-226    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("bpt", args[0]) == 0) {
    eeprom_update_word(&g_rom_settings.backpedal_thres_min, (uint16_t)(atoi(args[1])));
    3c42:	ce 01       	movw	r24, r28
    3c44:	80 96       	adiw	r24, 0x20	; 32
    3c46:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3c4a:	bc 01       	movw	r22, r24
    3c4c:	80 e1       	ldi	r24, 0x10	; 16
    3c4e:	90 e0       	ldi	r25, 0x00	; 0
    3c50:	0e 94 2c 28 	call	0x5058	; 0x5058 <__eeupd_word_m1284p>
    3c54:	85 cf       	rjmp	.-246    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("ss", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.startup_sound, (uint8_t)(atoi(args[1])));
    3c56:	ce 01       	movw	r24, r28
    3c58:	80 96       	adiw	r24, 0x20	; 32
    3c5a:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3c5e:	68 2f       	mov	r22, r24
    3c60:	82 e1       	ldi	r24, 0x12	; 18
    3c62:	90 e0       	ldi	r25, 0x00	; 0
    3c64:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3c68:	7b cf       	rjmp	.-266    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("as", args[0]) == 0) {
    eeprom_update_byte(&g_rom_settings.alarm_sound, (uint8_t)(atoi(args[1])));
    3c6a:	ce 01       	movw	r24, r28
    3c6c:	80 96       	adiw	r24, 0x20	; 32
    3c6e:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <atoi>
    3c72:	68 2f       	mov	r22, r24
    3c74:	83 e1       	ldi	r24, 0x13	; 19
    3c76:	90 e0       	ldi	r25, 0x00	; 0
    3c78:	0e 94 1a 28 	call	0x5034	; 0x5034 <__eeupd_byte_m1284p>
    3c7c:	71 cf       	rjmp	.-286    	; 0x3b60 <command_handle_set_conf+0x11e>
  } else if (strcmp("p", args[0]) == 0) {
    eeprom_update_block(args[1], &g_rom_settings.passwd, 32);
    3c7e:	40 e2       	ldi	r20, 0x20	; 32
    3c80:	50 e0       	ldi	r21, 0x00	; 0
    3c82:	64 e1       	ldi	r22, 0x14	; 20
    3c84:	70 e0       	ldi	r23, 0x00	; 0
    3c86:	ce 01       	movw	r24, r28
    3c88:	80 96       	adiw	r24, 0x20	; 32
    3c8a:	0e 94 0b 28 	call	0x5016	; 0x5016 <__eeupd_block_m1284p>
    3c8e:	68 cf       	rjmp	.-304    	; 0x3b60 <command_handle_set_conf+0x11e>

00003c90 <command_handle_help>:

void command_handle_show_voltage(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy(cmd_output, display_voltage_info());
}

void command_handle_help(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
    3c90:	0f 93       	push	r16
    3c92:	1f 93       	push	r17
    3c94:	cf 93       	push	r28
    3c96:	df 93       	push	r29
    3c98:	8c 01       	movw	r16, r24
  strcpy_P(uart_buf, help_info);
    3c9a:	62 e0       	ldi	r22, 0x02	; 2
    3c9c:	75 e1       	ldi	r23, 0x15	; 21
    3c9e:	86 e3       	ldi	r24, 0x36	; 54
    3ca0:	90 e1       	ldi	r25, 0x10	; 16
    3ca2:	0e 94 88 27 	call	0x4f10	; 0x4f10 <strcpy_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3ca6:	c6 e3       	ldi	r28, 0x36	; 54
    3ca8:	d0 e1       	ldi	r29, 0x10	; 16
    3caa:	de 01       	movw	r26, r28
    3cac:	0d 90       	ld	r0, X+
    3cae:	00 20       	and	r0, r0
    3cb0:	e9 f7       	brne	.-6      	; 0x3cac <command_handle_help+0x1c>
    3cb2:	11 97       	sbiw	r26, 0x01	; 1
    3cb4:	8a e0       	ldi	r24, 0x0A	; 10
    3cb6:	e2 e8       	ldi	r30, 0x82	; 130
    3cb8:	f2 e0       	ldi	r31, 0x02	; 2
    3cba:	01 90       	ld	r0, Z+
    3cbc:	0d 92       	st	X+, r0
    3cbe:	8a 95       	dec	r24
    3cc0:	e1 f7       	brne	.-8      	; 0x3cba <command_handle_help+0x2a>
  strcat_P(uart_buf, reset_info);
    3cc2:	60 ee       	ldi	r22, 0xE0	; 224
    3cc4:	74 e1       	ldi	r23, 0x14	; 20
    3cc6:	ce 01       	movw	r24, r28
    3cc8:	0e 94 7d 27 	call	0x4efa	; 0x4efa <strcat_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3ccc:	de 01       	movw	r26, r28
    3cce:	0d 90       	ld	r0, X+
    3cd0:	00 20       	and	r0, r0
    3cd2:	e9 f7       	brne	.-6      	; 0x3cce <command_handle_help+0x3e>
    3cd4:	11 97       	sbiw	r26, 0x01	; 1
    3cd6:	8a e0       	ldi	r24, 0x0A	; 10
    3cd8:	e2 e8       	ldi	r30, 0x82	; 130
    3cda:	f2 e0       	ldi	r31, 0x02	; 2
    3cdc:	01 90       	ld	r0, Z+
    3cde:	0d 92       	st	X+, r0
    3ce0:	8a 95       	dec	r24
    3ce2:	e1 f7       	brne	.-8      	; 0x3cdc <command_handle_help+0x4c>
  strcat_P(uart_buf, show_version_info);
    3ce4:	6c eb       	ldi	r22, 0xBC	; 188
    3ce6:	74 e1       	ldi	r23, 0x14	; 20
    3ce8:	ce 01       	movw	r24, r28
    3cea:	0e 94 7d 27 	call	0x4efa	; 0x4efa <strcat_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3cee:	de 01       	movw	r26, r28
    3cf0:	0d 90       	ld	r0, X+
    3cf2:	00 20       	and	r0, r0
    3cf4:	e9 f7       	brne	.-6      	; 0x3cf0 <command_handle_help+0x60>
    3cf6:	11 97       	sbiw	r26, 0x01	; 1
    3cf8:	8a e0       	ldi	r24, 0x0A	; 10
    3cfa:	e2 e8       	ldi	r30, 0x82	; 130
    3cfc:	f2 e0       	ldi	r31, 0x02	; 2
    3cfe:	01 90       	ld	r0, Z+
    3d00:	0d 92       	st	X+, r0
    3d02:	8a 95       	dec	r24
    3d04:	e1 f7       	brne	.-8      	; 0x3cfe <command_handle_help+0x6e>
  strcat_P(uart_buf, show_state_info);
    3d06:	65 e8       	ldi	r22, 0x85	; 133
    3d08:	74 e1       	ldi	r23, 0x14	; 20
    3d0a:	ce 01       	movw	r24, r28
    3d0c:	0e 94 7d 27 	call	0x4efa	; 0x4efa <strcat_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3d10:	de 01       	movw	r26, r28
    3d12:	0d 90       	ld	r0, X+
    3d14:	00 20       	and	r0, r0
    3d16:	e9 f7       	brne	.-6      	; 0x3d12 <command_handle_help+0x82>
    3d18:	11 97       	sbiw	r26, 0x01	; 1
    3d1a:	8a e0       	ldi	r24, 0x0A	; 10
    3d1c:	e2 e8       	ldi	r30, 0x82	; 130
    3d1e:	f2 e0       	ldi	r31, 0x02	; 2
    3d20:	01 90       	ld	r0, Z+
    3d22:	0d 92       	st	X+, r0
    3d24:	8a 95       	dec	r24
    3d26:	e1 f7       	brne	.-8      	; 0x3d20 <command_handle_help+0x90>
  strcat_P(uart_buf, show_voltage_info);
    3d28:	6c e3       	ldi	r22, 0x3C	; 60
    3d2a:	74 e1       	ldi	r23, 0x14	; 20
    3d2c:	ce 01       	movw	r24, r28
    3d2e:	0e 94 7d 27 	call	0x4efa	; 0x4efa <strcat_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3d32:	de 01       	movw	r26, r28
    3d34:	0d 90       	ld	r0, X+
    3d36:	00 20       	and	r0, r0
    3d38:	e9 f7       	brne	.-6      	; 0x3d34 <command_handle_help+0xa4>
    3d3a:	11 97       	sbiw	r26, 0x01	; 1
    3d3c:	8a e0       	ldi	r24, 0x0A	; 10
    3d3e:	e2 e8       	ldi	r30, 0x82	; 130
    3d40:	f2 e0       	ldi	r31, 0x02	; 2
    3d42:	01 90       	ld	r0, Z+
    3d44:	0d 92       	st	X+, r0
    3d46:	8a 95       	dec	r24
    3d48:	e1 f7       	brne	.-8      	; 0x3d42 <command_handle_help+0xb2>
  strcat_P(uart_buf, set_sense_info);
    3d4a:	6f ee       	ldi	r22, 0xEF	; 239
    3d4c:	73 e1       	ldi	r23, 0x13	; 19
    3d4e:	ce 01       	movw	r24, r28
    3d50:	0e 94 7d 27 	call	0x4efa	; 0x4efa <strcat_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3d54:	de 01       	movw	r26, r28
    3d56:	0d 90       	ld	r0, X+
    3d58:	00 20       	and	r0, r0
    3d5a:	e9 f7       	brne	.-6      	; 0x3d56 <command_handle_help+0xc6>
    3d5c:	11 97       	sbiw	r26, 0x01	; 1
    3d5e:	8a e0       	ldi	r24, 0x0A	; 10
    3d60:	e2 e8       	ldi	r30, 0x82	; 130
    3d62:	f2 e0       	ldi	r31, 0x02	; 2
    3d64:	01 90       	ld	r0, Z+
    3d66:	0d 92       	st	X+, r0
    3d68:	8a 95       	dec	r24
    3d6a:	e1 f7       	brne	.-8      	; 0x3d64 <command_handle_help+0xd4>
  strcat_P(uart_buf, set_conf_info);
    3d6c:	61 e9       	ldi	r22, 0x91	; 145
    3d6e:	73 e1       	ldi	r23, 0x13	; 19
    3d70:	ce 01       	movw	r24, r28
    3d72:	0e 94 7d 27 	call	0x4efa	; 0x4efa <strcat_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3d76:	de 01       	movw	r26, r28
    3d78:	0d 90       	ld	r0, X+
    3d7a:	00 20       	and	r0, r0
    3d7c:	e9 f7       	brne	.-6      	; 0x3d78 <command_handle_help+0xe8>
    3d7e:	11 97       	sbiw	r26, 0x01	; 1
    3d80:	8a e0       	ldi	r24, 0x0A	; 10
    3d82:	e2 e8       	ldi	r30, 0x82	; 130
    3d84:	f2 e0       	ldi	r31, 0x02	; 2
    3d86:	01 90       	ld	r0, Z+
    3d88:	0d 92       	st	X+, r0
    3d8a:	8a 95       	dec	r24
    3d8c:	e1 f7       	brne	.-8      	; 0x3d86 <command_handle_help+0xf6>
  strcat_P(uart_buf, show_conf_info);
    3d8e:	6c e6       	ldi	r22, 0x6C	; 108
    3d90:	73 e1       	ldi	r23, 0x13	; 19
    3d92:	ce 01       	movw	r24, r28
    3d94:	0e 94 7d 27 	call	0x4efa	; 0x4efa <strcat_P>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3d98:	09 90       	ld	r0, Y+
    3d9a:	00 20       	and	r0, r0
    3d9c:	e9 f7       	brne	.-6      	; 0x3d98 <command_handle_help+0x108>
    3d9e:	21 97       	sbiw	r28, 0x01	; 1
    3da0:	c6 53       	subi	r28, 0x36	; 54
    3da2:	d0 41       	sbci	r29, 0x10	; 16
    3da4:	de 01       	movw	r26, r28
    3da6:	aa 5c       	subi	r26, 0xCA	; 202
    3da8:	bf 4e       	sbci	r27, 0xEF	; 239
    3daa:	8a e0       	ldi	r24, 0x0A	; 10
    3dac:	e2 e8       	ldi	r30, 0x82	; 130
    3dae:	f2 e0       	ldi	r31, 0x02	; 2
    3db0:	01 90       	ld	r0, Z+
    3db2:	0d 92       	st	X+, r0
    3db4:	8a 95       	dec	r24
    3db6:	e1 f7       	brne	.-8      	; 0x3db0 <command_handle_help+0x120>
  strcpy(cmd_output, uart_buf);
    3db8:	ae 01       	movw	r20, r28
    3dba:	46 5f       	subi	r20, 0xF6	; 246
    3dbc:	5f 4f       	sbci	r21, 0xFF	; 255
    3dbe:	66 e3       	ldi	r22, 0x36	; 54
    3dc0:	70 e1       	ldi	r23, 0x10	; 16
    3dc2:	c8 01       	movw	r24, r16
}
    3dc4:	df 91       	pop	r29
    3dc6:	cf 91       	pop	r28
    3dc8:	1f 91       	pop	r17
    3dca:	0f 91       	pop	r16
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcat_P(uart_buf, set_conf_info);
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcat_P(uart_buf, show_conf_info);
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcpy(cmd_output, uart_buf);
    3dcc:	0c 94 92 27 	jmp	0x4f24	; 0x4f24 <memcpy>

00003dd0 <register_commands>:
  }
  return byte_buf;
}

void register_commands() {
  command_register("help", help_info, COMMAND_NO_PRIV, command_handle_help);
    3dd0:	28 e4       	ldi	r18, 0x48	; 72
    3dd2:	3e e1       	ldi	r19, 0x1E	; 30
    3dd4:	40 e0       	ldi	r20, 0x00	; 0
    3dd6:	62 e0       	ldi	r22, 0x02	; 2
    3dd8:	75 e1       	ldi	r23, 0x15	; 21
    3dda:	80 e9       	ldi	r24, 0x90	; 144
    3ddc:	92 e0       	ldi	r25, 0x02	; 2
    3dde:	b3 dc       	rcall	.-1690   	; 0x3746 <command_register>
    3de0:	23 ee       	ldi	r18, 0xE3	; 227
  command_register("reset", reset_info, COMMAND_NO_PRIV, command_handle_reset);
    3de2:	3c e1       	ldi	r19, 0x1C	; 28
    3de4:	40 e0       	ldi	r20, 0x00	; 0
    3de6:	60 ee       	ldi	r22, 0xE0	; 224
    3de8:	74 e1       	ldi	r23, 0x14	; 20
    3dea:	85 e9       	ldi	r24, 0x95	; 149
    3dec:	92 e0       	ldi	r25, 0x02	; 2
    3dee:	ab dc       	rcall	.-1706   	; 0x3746 <command_register>
    3df0:	2f ee       	ldi	r18, 0xEF	; 239
    3df2:	3c e1       	ldi	r19, 0x1C	; 28
  command_register("show version", show_version_info, COMMAND_NO_PRIV, command_handle_show_version);
    3df4:	40 e0       	ldi	r20, 0x00	; 0
    3df6:	6c eb       	ldi	r22, 0xBC	; 188
    3df8:	74 e1       	ldi	r23, 0x14	; 20
    3dfa:	8b e9       	ldi	r24, 0x9B	; 155
    3dfc:	92 e0       	ldi	r25, 0x02	; 2
    3dfe:	a3 dc       	rcall	.-1722   	; 0x3746 <command_register>
    3e00:	2e ea       	ldi	r18, 0xAE	; 174
    3e02:	30 e2       	ldi	r19, 0x20	; 32
    3e04:	40 e0       	ldi	r20, 0x00	; 0
  command_register("show state", show_state_info, COMMAND_NO_PRIV, command_handle_show_state);
    3e06:	65 e8       	ldi	r22, 0x85	; 133
    3e08:	74 e1       	ldi	r23, 0x14	; 20
    3e0a:	88 ea       	ldi	r24, 0xA8	; 168
    3e0c:	92 e0       	ldi	r25, 0x02	; 2
    3e0e:	9b dc       	rcall	.-1738   	; 0x3746 <command_register>
    3e10:	22 e0       	ldi	r18, 0x02	; 2
    3e12:	34 e2       	ldi	r19, 0x24	; 36
    3e14:	40 e0       	ldi	r20, 0x00	; 0
    3e16:	6c e6       	ldi	r22, 0x6C	; 108
  command_register("show conf", show_conf_info, COMMAND_NO_PRIV, command_handle_show_conf);
    3e18:	73 e1       	ldi	r23, 0x13	; 19
    3e1a:	83 eb       	ldi	r24, 0xB3	; 179
    3e1c:	92 e0       	ldi	r25, 0x02	; 2
    3e1e:	93 dc       	rcall	.-1754   	; 0x3746 <command_register>
    3e20:	2c e4       	ldi	r18, 0x4C	; 76
    3e22:	31 e2       	ldi	r19, 0x21	; 33
    3e24:	40 e0       	ldi	r20, 0x00	; 0
    3e26:	6c e3       	ldi	r22, 0x3C	; 60
    3e28:	74 e1       	ldi	r23, 0x14	; 20
  command_register("show voltage", show_voltage_info, COMMAND_NO_PRIV, command_handle_show_voltage);
    3e2a:	8d eb       	ldi	r24, 0xBD	; 189
    3e2c:	92 e0       	ldi	r25, 0x02	; 2
    3e2e:	8b dc       	rcall	.-1770   	; 0x3746 <command_register>
    3e30:	23 ef       	ldi	r18, 0xF3	; 243
    3e32:	3c e1       	ldi	r19, 0x1C	; 28
    3e34:	40 e0       	ldi	r20, 0x00	; 0
    3e36:	6f ee       	ldi	r22, 0xEF	; 239
    3e38:	73 e1       	ldi	r23, 0x13	; 19
    3e3a:	8a ec       	ldi	r24, 0xCA	; 202
  command_register("set dsense", set_sense_info, COMMAND_NO_PRIV, command_handle_set_sense);
    3e3c:	92 e0       	ldi	r25, 0x02	; 2
    3e3e:	83 dc       	rcall	.-1786   	; 0x3746 <command_register>
    3e40:	21 e2       	ldi	r18, 0x21	; 33
    3e42:	3d e1       	ldi	r19, 0x1D	; 29
    3e44:	40 e0       	ldi	r20, 0x00	; 0
    3e46:	61 e9       	ldi	r22, 0x91	; 145
    3e48:	73 e1       	ldi	r23, 0x13	; 19
    3e4a:	85 ed       	ldi	r24, 0xD5	; 213
    3e4c:	92 e0       	ldi	r25, 0x02	; 2
  command_register("set conf", set_conf_info, COMMAND_NO_PRIV, command_handle_set_conf);
    3e4e:	7b cc       	rjmp	.-1802   	; 0x3746 <command_register>

00003e50 <display_state_info>:
    3e50:	ef 92       	push	r14
    3e52:	ff 92       	push	r15
    3e54:	0f 93       	push	r16
    3e56:	1f 93       	push	r17
    3e58:	cf 93       	push	r28
    3e5a:	df 93       	push	r29
    3e5c:	85 e0       	ldi	r24, 0x05	; 5
    3e5e:	ee ed       	ldi	r30, 0xDE	; 222
}

char *display_state_info() {
  strcpy(uart_buf, "st: ");
    3e60:	f2 e0       	ldi	r31, 0x02	; 2
    3e62:	a6 e3       	ldi	r26, 0x36	; 54
    3e64:	b0 e1       	ldi	r27, 0x10	; 16
    3e66:	01 90       	ld	r0, Z+
    3e68:	0d 92       	st	X+, r0
    3e6a:	8a 95       	dec	r24
    3e6c:	e1 f7       	brne	.-8      	; 0x3e66 <display_state_info+0x16>
  strcat(uart_buf, btob(g_state >> 8));
    3e6e:	80 91 43 12 	lds	r24, 0x1243
    3e72:	90 91 44 12 	lds	r25, 0x1244
    3e76:	59 2f       	mov	r21, r25
#include <avr/eeprom.h>

#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
    3e78:	10 92 2d 10 	sts	0x102D, r1
    3e7c:	88 e0       	ldi	r24, 0x08	; 8
    3e7e:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    3e80:	40 e8       	ldi	r20, 0x80	; 128
    3e82:	cd e2       	ldi	r28, 0x2D	; 45
    3e84:	d0 e1       	ldi	r29, 0x10	; 16
    3e86:	12 c0       	rjmp	.+36     	; 0x3eac <display_state_info+0x5c>
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    3e88:	ae e8       	ldi	r26, 0x8E	; 142
    3e8a:	b2 e0       	ldi	r27, 0x02	; 2
    3e8c:	fe 01       	movw	r30, r28
    3e8e:	01 90       	ld	r0, Z+
    3e90:	00 20       	and	r0, r0
    3e92:	e9 f7       	brne	.-6      	; 0x3e8e <display_state_info+0x3e>
    3e94:	31 97       	sbiw	r30, 0x01	; 1
    3e96:	8f 01       	movw	r16, r30
    3e98:	0d 52       	subi	r16, 0x2D	; 45
    3e9a:	10 41       	sbci	r17, 0x10	; 16
    3e9c:	2d 91       	ld	r18, X+
    3e9e:	3c 91       	ld	r19, X
    3ea0:	31 83       	std	Z+1, r19	; 0x01
    3ea2:	20 83       	st	Z, r18
#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    3ea4:	46 95       	lsr	r20
    3ea6:	01 97       	sbiw	r24, 0x01	; 1
    3ea8:	00 97       	sbiw	r24, 0x00	; 0
    3eaa:	39 f0       	breq	.+14     	; 0x3eba <display_state_info+0x6a>
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    3eac:	24 2f       	mov	r18, r20
    3eae:	25 23       	and	r18, r21
    3eb0:	42 13       	cpse	r20, r18
    3eb2:	ea cf       	rjmp	.-44     	; 0x3e88 <display_state_info+0x38>
    3eb4:	ac e8       	ldi	r26, 0x8C	; 140
    3eb6:	b2 e0       	ldi	r27, 0x02	; 2
    3eb8:	e9 cf       	rjmp	.-46     	; 0x3e8c <display_state_info+0x3c>
  command_register("set conf", set_conf_info, COMMAND_NO_PRIV, command_handle_set_conf);
}

char *display_state_info() {
  strcpy(uart_buf, "st: ");
  strcat(uart_buf, btob(g_state >> 8));
    3eba:	a8 01       	movw	r20, r16
    3ebc:	4e 5f       	subi	r20, 0xFE	; 254
    3ebe:	5f 4f       	sbci	r21, 0xFF	; 255
    3ec0:	6d e2       	ldi	r22, 0x2D	; 45
    3ec2:	70 e1       	ldi	r23, 0x10	; 16
    3ec4:	8a e3       	ldi	r24, 0x3A	; 58
    3ec6:	90 e1       	ldi	r25, 0x10	; 16
    3ec8:	0e 94 92 27 	call	0x4f24	; 0x4f24 <memcpy>
  strcat(uart_buf, ".");
    3ecc:	8e e2       	ldi	r24, 0x2E	; 46
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	f8 01       	movw	r30, r16
    3ed2:	e5 5c       	subi	r30, 0xC5	; 197
    3ed4:	ff 4e       	sbci	r31, 0xEF	; 239
    3ed6:	91 83       	std	Z+1, r25	; 0x01
    3ed8:	80 83       	st	Z, r24
  strcat(uart_buf, btob(g_state));
    3eda:	80 91 43 12 	lds	r24, 0x1243
    3ede:	90 91 44 12 	lds	r25, 0x1244
    3ee2:	58 2f       	mov	r21, r24
#include <avr/eeprom.h>

#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
    3ee4:	10 92 2d 10 	sts	0x102D, r1
    3ee8:	88 e0       	ldi	r24, 0x08	; 8
    3eea:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    3eec:	40 e8       	ldi	r20, 0x80	; 128
    3eee:	13 c0       	rjmp	.+38     	; 0x3f16 <display_state_info+0xc6>
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    3ef0:	ae e8       	ldi	r26, 0x8E	; 142
    3ef2:	b2 e0       	ldi	r27, 0x02	; 2
    3ef4:	fe 01       	movw	r30, r28
    3ef6:	01 90       	ld	r0, Z+
    3ef8:	00 20       	and	r0, r0
    3efa:	e9 f7       	brne	.-6      	; 0x3ef6 <display_state_info+0xa6>
    3efc:	31 97       	sbiw	r30, 0x01	; 1
    3efe:	9f 01       	movw	r18, r30
    3f00:	2d 52       	subi	r18, 0x2D	; 45
    3f02:	30 41       	sbci	r19, 0x10	; 16
    3f04:	79 01       	movw	r14, r18
    3f06:	2d 91       	ld	r18, X+
    3f08:	3c 91       	ld	r19, X
    3f0a:	31 83       	std	Z+1, r19	; 0x01
    3f0c:	20 83       	st	Z, r18
#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    3f0e:	46 95       	lsr	r20
    3f10:	01 97       	sbiw	r24, 0x01	; 1
    3f12:	00 97       	sbiw	r24, 0x00	; 0
    3f14:	39 f0       	breq	.+14     	; 0x3f24 <display_state_info+0xd4>
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    3f16:	24 2f       	mov	r18, r20
    3f18:	25 23       	and	r18, r21
    3f1a:	42 13       	cpse	r20, r18
    3f1c:	e9 cf       	rjmp	.-46     	; 0x3ef0 <display_state_info+0xa0>
    3f1e:	ac e8       	ldi	r26, 0x8C	; 140
    3f20:	b2 e0       	ldi	r27, 0x02	; 2
    3f22:	e8 cf       	rjmp	.-48     	; 0x3ef4 <display_state_info+0xa4>

char *display_state_info() {
  strcpy(uart_buf, "st: ");
  strcat(uart_buf, btob(g_state >> 8));
  strcat(uart_buf, ".");
  strcat(uart_buf, btob(g_state));
    3f24:	a7 01       	movw	r20, r14
    3f26:	4e 5f       	subi	r20, 0xFE	; 254
    3f28:	5f 4f       	sbci	r21, 0xFF	; 255
    3f2a:	6d e2       	ldi	r22, 0x2D	; 45
    3f2c:	70 e1       	ldi	r23, 0x10	; 16
    3f2e:	c8 01       	movw	r24, r16
    3f30:	84 5c       	subi	r24, 0xC4	; 196
    3f32:	9f 4e       	sbci	r25, 0xEF	; 239
    3f34:	f7 d7       	rcall	.+4078   	; 0x4f24 <memcpy>
    3f36:	09 5f       	subi	r16, 0xF9	; 249
    3f38:	1f 4f       	sbci	r17, 0xFF	; 255
    3f3a:	0e 0d       	add	r16, r14
    3f3c:	1f 1d       	adc	r17, r15
    3f3e:	d8 01       	movw	r26, r16
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    3f40:	aa 5c       	subi	r26, 0xCA	; 202
    3f42:	bf 4e       	sbci	r27, 0xEF	; 239
    3f44:	89 e0       	ldi	r24, 0x09	; 9
    3f46:	e2 e8       	ldi	r30, 0x82	; 130
    3f48:	f2 e0       	ldi	r31, 0x02	; 2
    3f4a:	01 90       	ld	r0, Z+
    3f4c:	0d 92       	st	X+, r0
    3f4e:	8a 95       	dec	r24
    3f50:	e1 f7       	brne	.-8      	; 0x3f4a <display_state_info+0xfa>
    3f52:	d8 01       	movw	r26, r16
  strcat(uart_buf, "ds: ");
    3f54:	a1 5c       	subi	r26, 0xC1	; 193
    3f56:	bf 4e       	sbci	r27, 0xEF	; 239
    3f58:	85 e0       	ldi	r24, 0x05	; 5
    3f5a:	e3 ee       	ldi	r30, 0xE3	; 227
    3f5c:	f2 e0       	ldi	r31, 0x02	; 2
    3f5e:	01 90       	ld	r0, Z+
    3f60:	0d 92       	st	X+, r0
    3f62:	8a 95       	dec	r24
    3f64:	e1 f7       	brne	.-8      	; 0x3f5e <display_state_info+0x10e>
    3f66:	80 91 3f 12 	lds	r24, 0x123F
  strcat(uart_buf, btob(g_dyn_senses >> 8));
    3f6a:	90 91 40 12 	lds	r25, 0x1240
    3f6e:	59 2f       	mov	r21, r25
    3f70:	10 92 2d 10 	sts	0x102D, r1
#include <avr/eeprom.h>

#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
    3f74:	88 e0       	ldi	r24, 0x08	; 8
    3f76:	90 e0       	ldi	r25, 0x00	; 0
    3f78:	40 e8       	ldi	r20, 0x80	; 128
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    3f7a:	13 c0       	rjmp	.+38     	; 0x3fa2 <display_state_info+0x152>
    3f7c:	ae e8       	ldi	r26, 0x8E	; 142
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    3f7e:	b2 e0       	ldi	r27, 0x02	; 2
    3f80:	fe 01       	movw	r30, r28
    3f82:	01 90       	ld	r0, Z+
    3f84:	00 20       	and	r0, r0
    3f86:	e9 f7       	brne	.-6      	; 0x3f82 <display_state_info+0x132>
    3f88:	31 97       	sbiw	r30, 0x01	; 1
    3f8a:	9f 01       	movw	r18, r30
    3f8c:	2d 52       	subi	r18, 0x2D	; 45
    3f8e:	30 41       	sbci	r19, 0x10	; 16
    3f90:	79 01       	movw	r14, r18
    3f92:	2d 91       	ld	r18, X+
    3f94:	3c 91       	ld	r19, X
    3f96:	31 83       	std	Z+1, r19	; 0x01
    3f98:	20 83       	st	Z, r18
    3f9a:	46 95       	lsr	r20
#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    3f9c:	01 97       	sbiw	r24, 0x01	; 1
    3f9e:	00 97       	sbiw	r24, 0x00	; 0
    3fa0:	39 f0       	breq	.+14     	; 0x3fb0 <display_state_info+0x160>
    3fa2:	24 2f       	mov	r18, r20
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    3fa4:	25 23       	and	r18, r21
    3fa6:	42 13       	cpse	r20, r18
    3fa8:	e9 cf       	rjmp	.-46     	; 0x3f7c <display_state_info+0x12c>
    3faa:	ac e8       	ldi	r26, 0x8C	; 140
    3fac:	b2 e0       	ldi	r27, 0x02	; 2
    3fae:	e8 cf       	rjmp	.-48     	; 0x3f80 <display_state_info+0x130>
    3fb0:	a7 01       	movw	r20, r14
  strcat(uart_buf, btob(g_state >> 8));
  strcat(uart_buf, ".");
  strcat(uart_buf, btob(g_state));
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcat(uart_buf, "ds: ");
  strcat(uart_buf, btob(g_dyn_senses >> 8));
    3fb2:	4e 5f       	subi	r20, 0xFE	; 254
    3fb4:	5f 4f       	sbci	r21, 0xFF	; 255
    3fb6:	6d e2       	ldi	r22, 0x2D	; 45
    3fb8:	70 e1       	ldi	r23, 0x10	; 16
    3fba:	c8 01       	movw	r24, r16
    3fbc:	8d 5b       	subi	r24, 0xBD	; 189
    3fbe:	9f 4e       	sbci	r25, 0xEF	; 239
    3fc0:	b1 d7       	rcall	.+3938   	; 0x4f24 <memcpy>
    3fc2:	02 5f       	subi	r16, 0xF2	; 242
    3fc4:	1f 4f       	sbci	r17, 0xFF	; 255
    3fc6:	0e 0d       	add	r16, r14
    3fc8:	1f 1d       	adc	r17, r15
    3fca:	f8 01       	movw	r30, r16
    3fcc:	ea 5c       	subi	r30, 0xCA	; 202
  strcat(uart_buf, ".");
    3fce:	ff 4e       	sbci	r31, 0xEF	; 239
    3fd0:	8e e2       	ldi	r24, 0x2E	; 46
    3fd2:	90 e0       	ldi	r25, 0x00	; 0
    3fd4:	91 83       	std	Z+1, r25	; 0x01
    3fd6:	80 83       	st	Z, r24
    3fd8:	80 91 3f 12 	lds	r24, 0x123F
  strcat(uart_buf, btob(g_dyn_senses));
    3fdc:	90 91 40 12 	lds	r25, 0x1240
    3fe0:	58 2f       	mov	r21, r24
    3fe2:	10 92 2d 10 	sts	0x102D, r1
#include <avr/eeprom.h>

#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
    3fe6:	88 e0       	ldi	r24, 0x08	; 8
    3fe8:	90 e0       	ldi	r25, 0x00	; 0
    3fea:	40 e8       	ldi	r20, 0x80	; 128
    3fec:	13 c0       	rjmp	.+38     	; 0x4014 <display_state_info+0x1c4>
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    3fee:	ae e8       	ldi	r26, 0x8E	; 142
    3ff0:	b2 e0       	ldi	r27, 0x02	; 2
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    3ff2:	fe 01       	movw	r30, r28
    3ff4:	01 90       	ld	r0, Z+
    3ff6:	00 20       	and	r0, r0
    3ff8:	e9 f7       	brne	.-6      	; 0x3ff4 <display_state_info+0x1a4>
    3ffa:	31 97       	sbiw	r30, 0x01	; 1
    3ffc:	9f 01       	movw	r18, r30
    3ffe:	2d 52       	subi	r18, 0x2D	; 45
    4000:	30 41       	sbci	r19, 0x10	; 16
    4002:	79 01       	movw	r14, r18
    4004:	2d 91       	ld	r18, X+
    4006:	3c 91       	ld	r19, X
    4008:	31 83       	std	Z+1, r19	; 0x01
    400a:	20 83       	st	Z, r18
    400c:	46 95       	lsr	r20
    400e:	01 97       	sbiw	r24, 0x01	; 1
#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    4010:	00 97       	sbiw	r24, 0x00	; 0
    4012:	39 f0       	breq	.+14     	; 0x4022 <display_state_info+0x1d2>
    4014:	24 2f       	mov	r18, r20
    4016:	25 23       	and	r18, r21
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    4018:	42 13       	cpse	r20, r18
    401a:	e9 cf       	rjmp	.-46     	; 0x3fee <display_state_info+0x19e>
    401c:	ac e8       	ldi	r26, 0x8C	; 140
    401e:	b2 e0       	ldi	r27, 0x02	; 2
    4020:	e8 cf       	rjmp	.-48     	; 0x3ff2 <display_state_info+0x1a2>
    4022:	a7 01       	movw	r20, r14
    4024:	4e 5f       	subi	r20, 0xFE	; 254
  strcat(uart_buf, btob(g_state));
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcat(uart_buf, "ds: ");
  strcat(uart_buf, btob(g_dyn_senses >> 8));
  strcat(uart_buf, ".");
  strcat(uart_buf, btob(g_dyn_senses));
    4026:	5f 4f       	sbci	r21, 0xFF	; 255
    4028:	6d e2       	ldi	r22, 0x2D	; 45
    402a:	70 e1       	ldi	r23, 0x10	; 16
    402c:	c8 01       	movw	r24, r16
    402e:	89 5c       	subi	r24, 0xC9	; 201
    4030:	9f 4e       	sbci	r25, 0xEF	; 239
    4032:	78 d7       	rcall	.+3824   	; 0x4f24 <memcpy>
    4034:	0e 5f       	subi	r16, 0xFE	; 254
    4036:	1f 4f       	sbci	r17, 0xFF	; 255
    4038:	0e 0d       	add	r16, r14
    403a:	1f 1d       	adc	r17, r15
    403c:	d8 01       	movw	r26, r16
    403e:	aa 5c       	subi	r26, 0xCA	; 202
    4040:	bf 4e       	sbci	r27, 0xEF	; 239
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4042:	89 e0       	ldi	r24, 0x09	; 9
    4044:	e2 e8       	ldi	r30, 0x82	; 130
    4046:	f2 e0       	ldi	r31, 0x02	; 2
    4048:	01 90       	ld	r0, Z+
    404a:	0d 92       	st	X+, r0
    404c:	8a 95       	dec	r24
    404e:	e1 f7       	brne	.-8      	; 0x4048 <display_state_info+0x1f8>
    4050:	d8 01       	movw	r26, r16
    4052:	a1 5c       	subi	r26, 0xC1	; 193
    4054:	bf 4e       	sbci	r27, 0xEF	; 239
  strcat(uart_buf, "dss:");
    4056:	85 e0       	ldi	r24, 0x05	; 5
    4058:	e8 ee       	ldi	r30, 0xE8	; 232
    405a:	f2 e0       	ldi	r31, 0x02	; 2
    405c:	01 90       	ld	r0, Z+
    405e:	0d 92       	st	X+, r0
    4060:	8a 95       	dec	r24
    4062:	e1 f7       	brne	.-8      	; 0x405c <display_state_info+0x20c>
    4064:	80 91 41 12 	lds	r24, 0x1241
    4068:	90 91 42 12 	lds	r25, 0x1242
  strcat(uart_buf, btob(g_dyn_senses_status >> 8));
    406c:	59 2f       	mov	r21, r25
    406e:	10 92 2d 10 	sts	0x102D, r1
    4072:	88 e0       	ldi	r24, 0x08	; 8
#include <avr/eeprom.h>

#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
    4074:	90 e0       	ldi	r25, 0x00	; 0
    4076:	40 e8       	ldi	r20, 0x80	; 128
    4078:	13 c0       	rjmp	.+38     	; 0x40a0 <display_state_info+0x250>
    407a:	ae e8       	ldi	r26, 0x8E	; 142
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    407c:	b2 e0       	ldi	r27, 0x02	; 2
    407e:	fe 01       	movw	r30, r28
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    4080:	01 90       	ld	r0, Z+
    4082:	00 20       	and	r0, r0
    4084:	e9 f7       	brne	.-6      	; 0x4080 <display_state_info+0x230>
    4086:	31 97       	sbiw	r30, 0x01	; 1
    4088:	9f 01       	movw	r18, r30
    408a:	2d 52       	subi	r18, 0x2D	; 45
    408c:	30 41       	sbci	r19, 0x10	; 16
    408e:	79 01       	movw	r14, r18
    4090:	2d 91       	ld	r18, X+
    4092:	3c 91       	ld	r19, X
    4094:	31 83       	std	Z+1, r19	; 0x01
    4096:	20 83       	st	Z, r18
    4098:	46 95       	lsr	r20
    409a:	01 97       	sbiw	r24, 0x01	; 1
    409c:	00 97       	sbiw	r24, 0x00	; 0
#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    409e:	39 f0       	breq	.+14     	; 0x40ae <display_state_info+0x25e>
    40a0:	24 2f       	mov	r18, r20
    40a2:	25 23       	and	r18, r21
    40a4:	42 13       	cpse	r20, r18
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    40a6:	e9 cf       	rjmp	.-46     	; 0x407a <display_state_info+0x22a>
    40a8:	ac e8       	ldi	r26, 0x8C	; 140
    40aa:	b2 e0       	ldi	r27, 0x02	; 2
    40ac:	e8 cf       	rjmp	.-48     	; 0x407e <display_state_info+0x22e>
    40ae:	a7 01       	movw	r20, r14
    40b0:	4e 5f       	subi	r20, 0xFE	; 254
    40b2:	5f 4f       	sbci	r21, 0xFF	; 255
  strcat(uart_buf, btob(g_dyn_senses >> 8));
  strcat(uart_buf, ".");
  strcat(uart_buf, btob(g_dyn_senses));
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcat(uart_buf, "dss:");
  strcat(uart_buf, btob(g_dyn_senses_status >> 8));
    40b4:	6d e2       	ldi	r22, 0x2D	; 45
    40b6:	70 e1       	ldi	r23, 0x10	; 16
    40b8:	c8 01       	movw	r24, r16
    40ba:	8d 5b       	subi	r24, 0xBD	; 189
    40bc:	9f 4e       	sbci	r25, 0xEF	; 239
    40be:	32 d7       	rcall	.+3684   	; 0x4f24 <memcpy>
    40c0:	02 5f       	subi	r16, 0xF2	; 242
    40c2:	1f 4f       	sbci	r17, 0xFF	; 255
    40c4:	0e 0d       	add	r16, r14
    40c6:	1f 1d       	adc	r17, r15
    40c8:	f8 01       	movw	r30, r16
    40ca:	ea 5c       	subi	r30, 0xCA	; 202
    40cc:	ff 4e       	sbci	r31, 0xEF	; 239
    40ce:	8e e2       	ldi	r24, 0x2E	; 46
  strcat(uart_buf, ".");
    40d0:	90 e0       	ldi	r25, 0x00	; 0
    40d2:	91 83       	std	Z+1, r25	; 0x01
    40d4:	80 83       	st	Z, r24
    40d6:	80 91 41 12 	lds	r24, 0x1241
    40da:	90 91 42 12 	lds	r25, 0x1242
  strcat(uart_buf, btob(g_dyn_senses_status));
    40de:	58 2f       	mov	r21, r24
    40e0:	10 92 2d 10 	sts	0x102D, r1
    40e4:	88 e0       	ldi	r24, 0x08	; 8
    40e6:	90 e0       	ldi	r25, 0x00	; 0
#include <avr/eeprom.h>

#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
    40e8:	40 e8       	ldi	r20, 0x80	; 128
    40ea:	13 c0       	rjmp	.+38     	; 0x4112 <__stack+0x13>
    40ec:	ae e8       	ldi	r26, 0x8E	; 142
    40ee:	b2 e0       	ldi	r27, 0x02	; 2
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    40f0:	fe 01       	movw	r30, r28
    40f2:	01 90       	ld	r0, Z+
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    40f4:	00 20       	and	r0, r0
    40f6:	e9 f7       	brne	.-6      	; 0x40f2 <display_state_info+0x2a2>
    40f8:	31 97       	sbiw	r30, 0x01	; 1
    40fa:	9f 01       	movw	r18, r30
    40fc:	2d 52       	subi	r18, 0x2D	; 45
    40fe:	30 41       	sbci	r19, 0x10	; 16
    4100:	79 01       	movw	r14, r18
    4102:	2d 91       	ld	r18, X+
    4104:	3c 91       	ld	r19, X
    4106:	31 83       	std	Z+1, r19	; 0x01
    4108:	20 83       	st	Z, r18
    410a:	46 95       	lsr	r20
    410c:	01 97       	sbiw	r24, 0x01	; 1
    410e:	00 97       	sbiw	r24, 0x00	; 0
    4110:	39 f0       	breq	.+14     	; 0x4120 <__stack+0x21>
#include  "command_handlers.h"

const char *btob(uint8_t x) {
  byte_buf[0] = '\0';
  uint8_t z;
  for (z = 128; z > 0; z >>= 1) {
    4112:	24 2f       	mov	r18, r20
    4114:	25 23       	and	r18, r21
    4116:	42 13       	cpse	r20, r18
    4118:	e9 cf       	rjmp	.-46     	; 0x40ec <display_state_info+0x29c>
    strcat(byte_buf, ((x & z) == z) ? "1" : "0");
    411a:	ac e8       	ldi	r26, 0x8C	; 140
    411c:	b2 e0       	ldi	r27, 0x02	; 2
    411e:	e8 cf       	rjmp	.-48     	; 0x40f0 <display_state_info+0x2a0>
    4120:	a7 01       	movw	r20, r14
    4122:	4e 5f       	subi	r20, 0xFE	; 254
    4124:	5f 4f       	sbci	r21, 0xFF	; 255
    4126:	6d e2       	ldi	r22, 0x2D	; 45
  strcat(uart_buf, btob(g_dyn_senses));
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  strcat(uart_buf, "dss:");
  strcat(uart_buf, btob(g_dyn_senses_status >> 8));
  strcat(uart_buf, ".");
  strcat(uart_buf, btob(g_dyn_senses_status));
    4128:	70 e1       	ldi	r23, 0x10	; 16
    412a:	c8 01       	movw	r24, r16
    412c:	89 5c       	subi	r24, 0xC9	; 201
    412e:	9f 4e       	sbci	r25, 0xEF	; 239
    4130:	f9 d6       	rcall	.+3570   	; 0x4f24 <memcpy>
    4132:	d7 01       	movw	r26, r14
    4134:	a0 0f       	add	r26, r16
    4136:	b1 1f       	adc	r27, r17
    4138:	a8 5c       	subi	r26, 0xC8	; 200
    413a:	bf 4e       	sbci	r27, 0xEF	; 239
    413c:	8a e0       	ldi	r24, 0x0A	; 10
    413e:	e2 e8       	ldi	r30, 0x82	; 130
    4140:	f2 e0       	ldi	r31, 0x02	; 2
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4142:	01 90       	ld	r0, Z+
    4144:	0d 92       	st	X+, r0
    4146:	8a 95       	dec	r24
    4148:	e1 f7       	brne	.-8      	; 0x4142 <__stack+0x43>
    414a:	86 e3       	ldi	r24, 0x36	; 54
    414c:	90 e1       	ldi	r25, 0x10	; 16
    414e:	df 91       	pop	r29
    4150:	cf 91       	pop	r28
    4152:	1f 91       	pop	r17
  return uart_buf;
}
    4154:	0f 91       	pop	r16
    4156:	ff 90       	pop	r15
    4158:	ef 90       	pop	r14
    415a:	08 95       	ret

0000415c <command_handle_show_state>:
    415c:	cf 93       	push	r28
    415e:	df 93       	push	r29
    4160:	ec 01       	movw	r28, r24
    4162:	76 de       	rcall	.-788    	; 0x3e50 <display_state_info>
    4164:	bc 01       	movw	r22, r24
void command_handle_show_version(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy_P(cmd_output, g_firmware_version);
}

void command_handle_show_state(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy(cmd_output, display_state_info());
    4166:	ce 01       	movw	r24, r28
    4168:	df 91       	pop	r29
}
    416a:	cf 91       	pop	r28
    416c:	ed c6       	rjmp	.+3546   	; 0x4f48 <strcpy>

0000416e <display_voltage_info>:
void command_handle_show_version(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy_P(cmd_output, g_firmware_version);
}

void command_handle_show_state(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy(cmd_output, display_state_info());
    416e:	0f 93       	push	r16
    4170:	1f 93       	push	r17
  strcat(uart_buf, btob(g_dyn_senses_status));
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  return uart_buf;
}

char *display_voltage_info() {
    4172:	cf 93       	push	r28
    4174:	df 93       	push	r29
    4176:	cd b7       	in	r28, 0x3d	; 61
    4178:	de b7       	in	r29, 0x3e	; 62
    417a:	64 97       	sbiw	r28, 0x14	; 20
    417c:	0f b6       	in	r0, 0x3f	; 63
    417e:	f8 94       	cli
    4180:	de bf       	out	0x3e, r29	; 62
    4182:	0f be       	out	0x3f, r0	; 63
    4184:	cd bf       	out	0x3d, r28	; 61
  char accu_str[5];
  char x_str[5];
  char y_str[5];
  char z_str[5];
  utoa(g_adc_voltage[0],accu_str,10);
    4186:	80 91 37 12 	lds	r24, 0x1237
    418a:	90 91 38 12 	lds	r25, 0x1238
    418e:	4a e0       	ldi	r20, 0x0A	; 10
    4190:	50 e0       	ldi	r21, 0x00	; 0
    4192:	be 01       	movw	r22, r28
    4194:	60 5f       	subi	r22, 0xF0	; 240
    4196:	7f 4f       	sbci	r23, 0xFF	; 255
    4198:	0d d7       	rcall	.+3610   	; 0x4fb4 <utoa>
    419a:	80 91 39 12 	lds	r24, 0x1239
  utoa(g_adc_voltage[1],x_str,10);
    419e:	90 91 3a 12 	lds	r25, 0x123A
    41a2:	4a e0       	ldi	r20, 0x0A	; 10
    41a4:	50 e0       	ldi	r21, 0x00	; 0
    41a6:	be 01       	movw	r22, r28
    41a8:	65 5f       	subi	r22, 0xF5	; 245
    41aa:	7f 4f       	sbci	r23, 0xFF	; 255
    41ac:	03 d7       	rcall	.+3590   	; 0x4fb4 <utoa>
    41ae:	80 91 3b 12 	lds	r24, 0x123B
  utoa(g_adc_voltage[2],y_str,10);
    41b2:	90 91 3c 12 	lds	r25, 0x123C
    41b6:	4a e0       	ldi	r20, 0x0A	; 10
    41b8:	50 e0       	ldi	r21, 0x00	; 0
    41ba:	be 01       	movw	r22, r28
    41bc:	6a 5f       	subi	r22, 0xFA	; 250
    41be:	7f 4f       	sbci	r23, 0xFF	; 255
    41c0:	f9 d6       	rcall	.+3570   	; 0x4fb4 <utoa>
    41c2:	80 91 3d 12 	lds	r24, 0x123D
    41c6:	90 91 3e 12 	lds	r25, 0x123E
  utoa(g_adc_voltage[3],z_str,10);
    41ca:	4a e0       	ldi	r20, 0x0A	; 10
    41cc:	50 e0       	ldi	r21, 0x00	; 0
    41ce:	be 01       	movw	r22, r28
    41d0:	6f 5f       	subi	r22, 0xFF	; 255
    41d2:	7f 4f       	sbci	r23, 0xFF	; 255
    41d4:	ef d6       	rcall	.+3550   	; 0x4fb4 <utoa>
    41d6:	06 e3       	ldi	r16, 0x36	; 54
    41d8:	10 e1       	ldi	r17, 0x10	; 16
    41da:	89 e0       	ldi	r24, 0x09	; 9
    41dc:	ed ee       	ldi	r30, 0xED	; 237
  strcpy(uart_buf, "battery: ");
    41de:	f2 e0       	ldi	r31, 0x02	; 2
    41e0:	d8 01       	movw	r26, r16
    41e2:	01 90       	ld	r0, Z+
    41e4:	0d 92       	st	X+, r0
    41e6:	8a 95       	dec	r24
    41e8:	e1 f7       	brne	.-8      	; 0x41e2 <display_voltage_info+0x74>
    41ea:	be 01       	movw	r22, r28
    41ec:	60 5f       	subi	r22, 0xF0	; 240
    41ee:	7f 4f       	sbci	r23, 0xFF	; 255
    41f0:	8f e3       	ldi	r24, 0x3F	; 63
  strcat(uart_buf, accu_str);
    41f2:	90 e1       	ldi	r25, 0x10	; 16
    41f4:	a9 d6       	rcall	.+3410   	; 0x4f48 <strcpy>
    41f6:	f8 01       	movw	r30, r16
    41f8:	01 90       	ld	r0, Z+
    41fa:	00 20       	and	r0, r0
    41fc:	e9 f7       	brne	.-6      	; 0x41f8 <display_voltage_info+0x8a>
    41fe:	31 97       	sbiw	r30, 0x01	; 1
  strcat(uart_buf, " x: ");
    4200:	40 e2       	ldi	r20, 0x20	; 32
    4202:	58 e7       	ldi	r21, 0x78	; 120
    4204:	6a e3       	ldi	r22, 0x3A	; 58
    4206:	70 e2       	ldi	r23, 0x20	; 32
    4208:	40 83       	st	Z, r20
    420a:	51 83       	std	Z+1, r21	; 0x01
    420c:	62 83       	std	Z+2, r22	; 0x02
    420e:	73 83       	std	Z+3, r23	; 0x03
    4210:	be 01       	movw	r22, r28
    4212:	65 5f       	subi	r22, 0xF5	; 245
    4214:	7f 4f       	sbci	r23, 0xFF	; 255
    4216:	cf 01       	movw	r24, r30
    4218:	04 96       	adiw	r24, 0x04	; 4
  strcat(uart_buf, x_str);
    421a:	96 d6       	rcall	.+3372   	; 0x4f48 <strcpy>
    421c:	f8 01       	movw	r30, r16
    421e:	01 90       	ld	r0, Z+
    4220:	00 20       	and	r0, r0
    4222:	e9 f7       	brne	.-6      	; 0x421e <display_voltage_info+0xb0>
    4224:	31 97       	sbiw	r30, 0x01	; 1
    4226:	40 e2       	ldi	r20, 0x20	; 32
  strcat(uart_buf, " y: ");
    4228:	59 e7       	ldi	r21, 0x79	; 121
    422a:	6a e3       	ldi	r22, 0x3A	; 58
    422c:	70 e2       	ldi	r23, 0x20	; 32
    422e:	40 83       	st	Z, r20
    4230:	51 83       	std	Z+1, r21	; 0x01
    4232:	62 83       	std	Z+2, r22	; 0x02
    4234:	73 83       	std	Z+3, r23	; 0x03
    4236:	be 01       	movw	r22, r28
    4238:	6a 5f       	subi	r22, 0xFA	; 250
    423a:	7f 4f       	sbci	r23, 0xFF	; 255
    423c:	cf 01       	movw	r24, r30
    423e:	04 96       	adiw	r24, 0x04	; 4
    4240:	83 d6       	rcall	.+3334   	; 0x4f48 <strcpy>
  strcat(uart_buf, y_str);
    4242:	f8 01       	movw	r30, r16
    4244:	01 90       	ld	r0, Z+
    4246:	00 20       	and	r0, r0
    4248:	e9 f7       	brne	.-6      	; 0x4244 <display_voltage_info+0xd6>
    424a:	31 97       	sbiw	r30, 0x01	; 1
    424c:	40 e2       	ldi	r20, 0x20	; 32
    424e:	5a e7       	ldi	r21, 0x7A	; 122
  strcat(uart_buf, " z: ");
    4250:	6a e3       	ldi	r22, 0x3A	; 58
    4252:	70 e2       	ldi	r23, 0x20	; 32
    4254:	40 83       	st	Z, r20
    4256:	51 83       	std	Z+1, r21	; 0x01
    4258:	62 83       	std	Z+2, r22	; 0x02
    425a:	73 83       	std	Z+3, r23	; 0x03
    425c:	be 01       	movw	r22, r28
    425e:	6f 5f       	subi	r22, 0xFF	; 255
    4260:	7f 4f       	sbci	r23, 0xFF	; 255
    4262:	cf 01       	movw	r24, r30
    4264:	04 96       	adiw	r24, 0x04	; 4
    4266:	70 d6       	rcall	.+3296   	; 0x4f48 <strcpy>
    4268:	d8 01       	movw	r26, r16
  strcat(uart_buf, z_str);
    426a:	0d 90       	ld	r0, X+
    426c:	00 20       	and	r0, r0
    426e:	e9 f7       	brne	.-6      	; 0x426a <display_voltage_info+0xfc>
    4270:	11 97       	sbiw	r26, 0x01	; 1
    4272:	8a e0       	ldi	r24, 0x0A	; 10
    4274:	e2 e8       	ldi	r30, 0x82	; 130
    4276:	f2 e0       	ldi	r31, 0x02	; 2
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4278:	01 90       	ld	r0, Z+
    427a:	0d 92       	st	X+, r0
    427c:	8a 95       	dec	r24
    427e:	e1 f7       	brne	.-8      	; 0x4278 <display_voltage_info+0x10a>
    4280:	c8 01       	movw	r24, r16
    4282:	64 96       	adiw	r28, 0x14	; 20
    4284:	0f b6       	in	r0, 0x3f	; 63
    4286:	f8 94       	cli
    4288:	de bf       	out	0x3e, r29	; 62
    428a:	0f be       	out	0x3f, r0	; 63
    428c:	cd bf       	out	0x3d, r28	; 61
    428e:	df 91       	pop	r29
  return uart_buf;
}
    4290:	cf 91       	pop	r28
    4292:	1f 91       	pop	r17
    4294:	0f 91       	pop	r16
    4296:	08 95       	ret

00004298 <command_handle_show_voltage>:
    4298:	cf 93       	push	r28
    429a:	df 93       	push	r29
    429c:	ec 01       	movw	r28, r24
    429e:	67 df       	rcall	.-306    	; 0x416e <display_voltage_info>
    42a0:	bc 01       	movw	r22, r24
    42a2:	ce 01       	movw	r24, r28
    42a4:	df 91       	pop	r29
    42a6:	cf 91       	pop	r28
  strcpy(cmd_output, display_conf_info());
}

void command_handle_show_voltage(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy(cmd_output, display_voltage_info());
}
    42a8:	4f c6       	rjmp	.+3230   	; 0x4f48 <strcpy>

000042aa <display_conf_info>:
void command_handle_show_conf(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy(cmd_output, display_conf_info());
}

void command_handle_show_voltage(char *cmd_output, char (*args)[CMD_MAX_ARGS_SIZE]) {
  strcpy(cmd_output, display_voltage_info());
    42aa:	0f 93       	push	r16
    42ac:	1f 93       	push	r17
  strcat(uart_buf, z_str);
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
  return uart_buf;
}

char *display_conf_info() {
    42ae:	cf 93       	push	r28
    42b0:	df 93       	push	r29
    42b2:	cd b7       	in	r28, 0x3d	; 61
    42b4:	de b7       	in	r29, 0x3e	; 62
    42b6:	a0 97       	sbiw	r28, 0x20	; 32
    42b8:	0f b6       	in	r0, 0x3f	; 63
    42ba:	f8 94       	cli
    42bc:	de bf       	out	0x3e, r29	; 62
    42be:	0f be       	out	0x3f, r0	; 63
    42c0:	cd bf       	out	0x3d, r28	; 61
  char tmp_str[32];
  utoa(g_settings.deep_sleep_counter,tmp_str,10);
    42c2:	4a e0       	ldi	r20, 0x0A	; 10
    42c4:	50 e0       	ldi	r21, 0x00	; 0
    42c6:	be 01       	movw	r22, r28
    42c8:	6f 5f       	subi	r22, 0xFF	; 255
    42ca:	7f 4f       	sbci	r23, 0xFF	; 255
    42cc:	80 91 64 01 	lds	r24, 0x0164
    42d0:	90 91 65 01 	lds	r25, 0x0165
    42d4:	6f d6       	rcall	.+3294   	; 0x4fb4 <utoa>
    42d6:	06 e3       	ldi	r16, 0x36	; 54
  strcpy(uart_buf, "deep sleep counter (dsc): ");
    42d8:	10 e1       	ldi	r17, 0x10	; 16
    42da:	8a e1       	ldi	r24, 0x1A	; 26
    42dc:	e7 ef       	ldi	r30, 0xF7	; 247
    42de:	f2 e0       	ldi	r31, 0x02	; 2
    42e0:	d8 01       	movw	r26, r16
    42e2:	01 90       	ld	r0, Z+
    42e4:	0d 92       	st	X+, r0
    42e6:	8a 95       	dec	r24
    42e8:	e1 f7       	brne	.-8      	; 0x42e2 <display_conf_info+0x38>
    42ea:	be 01       	movw	r22, r28
  strcat(uart_buf, tmp_str);
    42ec:	6f 5f       	subi	r22, 0xFF	; 255
    42ee:	7f 4f       	sbci	r23, 0xFF	; 255
    42f0:	80 e5       	ldi	r24, 0x50	; 80
    42f2:	90 e1       	ldi	r25, 0x10	; 16
    42f4:	29 d6       	rcall	.+3154   	; 0x4f48 <strcpy>
    42f6:	d8 01       	movw	r26, r16
    42f8:	0d 90       	ld	r0, X+
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    42fa:	00 20       	and	r0, r0
    42fc:	e9 f7       	brne	.-6      	; 0x42f8 <display_conf_info+0x4e>
    42fe:	11 97       	sbiw	r26, 0x01	; 1
    4300:	8a e0       	ldi	r24, 0x0A	; 10
    4302:	e2 e8       	ldi	r30, 0x82	; 130
    4304:	f2 e0       	ldi	r31, 0x02	; 2
    4306:	01 90       	ld	r0, Z+
    4308:	0d 92       	st	X+, r0
    430a:	8a 95       	dec	r24
    430c:	e1 f7       	brne	.-8      	; 0x4306 <display_conf_info+0x5c>
    430e:	4a e0       	ldi	r20, 0x0A	; 10
    4310:	50 e0       	ldi	r21, 0x00	; 0
  utoa(g_settings.settle_time,tmp_str,10);
    4312:	be 01       	movw	r22, r28
    4314:	6f 5f       	subi	r22, 0xFF	; 255
    4316:	7f 4f       	sbci	r23, 0xFF	; 255
    4318:	80 91 66 01 	lds	r24, 0x0166
    431c:	90 91 67 01 	lds	r25, 0x0167
    4320:	49 d6       	rcall	.+3218   	; 0x4fb4 <utoa>
    4322:	f8 01       	movw	r30, r16
    4324:	01 90       	ld	r0, Z+
    4326:	00 20       	and	r0, r0
  strcat(uart_buf, "settle time (st): ");
    4328:	e9 f7       	brne	.-6      	; 0x4324 <display_conf_info+0x7a>
    432a:	cf 01       	movw	r24, r30
    432c:	01 97       	sbiw	r24, 0x01	; 1
    432e:	86 53       	subi	r24, 0x36	; 54
    4330:	90 41       	sbci	r25, 0x10	; 16
    4332:	dc 01       	movw	r26, r24
    4334:	aa 5c       	subi	r26, 0xCA	; 202
    4336:	bf 4e       	sbci	r27, 0xEF	; 239
    4338:	22 e1       	ldi	r18, 0x12	; 18
    433a:	e2 e1       	ldi	r30, 0x12	; 18
    433c:	f3 e0       	ldi	r31, 0x03	; 3
    433e:	01 90       	ld	r0, Z+
    4340:	0d 92       	st	X+, r0
    4342:	2a 95       	dec	r18
    4344:	e1 f7       	brne	.-8      	; 0x433e <display_conf_info+0x94>
    4346:	be 01       	movw	r22, r28
    4348:	6f 5f       	subi	r22, 0xFF	; 255
    434a:	7f 4f       	sbci	r23, 0xFF	; 255
  strcat(uart_buf, tmp_str);
    434c:	88 5b       	subi	r24, 0xB8	; 184
    434e:	9f 4e       	sbci	r25, 0xEF	; 239
    4350:	fb d5       	rcall	.+3062   	; 0x4f48 <strcpy>
    4352:	d8 01       	movw	r26, r16
    4354:	0d 90       	ld	r0, X+
    4356:	00 20       	and	r0, r0
    4358:	e9 f7       	brne	.-6      	; 0x4354 <display_conf_info+0xaa>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    435a:	11 97       	sbiw	r26, 0x01	; 1
    435c:	8a e0       	ldi	r24, 0x0A	; 10
    435e:	e2 e8       	ldi	r30, 0x82	; 130
    4360:	f2 e0       	ldi	r31, 0x02	; 2
    4362:	01 90       	ld	r0, Z+
    4364:	0d 92       	st	X+, r0
    4366:	8a 95       	dec	r24
    4368:	e1 f7       	brne	.-8      	; 0x4362 <display_conf_info+0xb8>
    436a:	4a e0       	ldi	r20, 0x0A	; 10
    436c:	50 e0       	ldi	r21, 0x00	; 0
    436e:	be 01       	movw	r22, r28
    4370:	6f 5f       	subi	r22, 0xFF	; 255
  utoa(g_settings.alarm_settle_time,tmp_str,10);
    4372:	7f 4f       	sbci	r23, 0xFF	; 255
    4374:	80 91 68 01 	lds	r24, 0x0168
    4378:	90 91 69 01 	lds	r25, 0x0169
    437c:	1b d6       	rcall	.+3126   	; 0x4fb4 <utoa>
    437e:	f8 01       	movw	r30, r16
    4380:	01 90       	ld	r0, Z+
    4382:	00 20       	and	r0, r0
    4384:	e9 f7       	brne	.-6      	; 0x4380 <display_conf_info+0xd6>
    4386:	cf 01       	movw	r24, r30
  strcat(uart_buf, "alarm settle time (ast): ");
    4388:	01 97       	sbiw	r24, 0x01	; 1
    438a:	86 53       	subi	r24, 0x36	; 54
    438c:	90 41       	sbci	r25, 0x10	; 16
    438e:	dc 01       	movw	r26, r24
    4390:	aa 5c       	subi	r26, 0xCA	; 202
    4392:	bf 4e       	sbci	r27, 0xEF	; 239
    4394:	29 e1       	ldi	r18, 0x19	; 25
    4396:	e5 e2       	ldi	r30, 0x25	; 37
    4398:	f3 e0       	ldi	r31, 0x03	; 3
    439a:	01 90       	ld	r0, Z+
    439c:	0d 92       	st	X+, r0
    439e:	2a 95       	dec	r18
    43a0:	e1 f7       	brne	.-8      	; 0x439a <display_conf_info+0xf0>
    43a2:	be 01       	movw	r22, r28
    43a4:	6f 5f       	subi	r22, 0xFF	; 255
    43a6:	7f 4f       	sbci	r23, 0xFF	; 255
    43a8:	81 5b       	subi	r24, 0xB1	; 177
    43aa:	9f 4e       	sbci	r25, 0xEF	; 239
  strcat(uart_buf, tmp_str);
    43ac:	cd d5       	rcall	.+2970   	; 0x4f48 <strcpy>
    43ae:	d8 01       	movw	r26, r16
    43b0:	0d 90       	ld	r0, X+
    43b2:	00 20       	and	r0, r0
    43b4:	e9 f7       	brne	.-6      	; 0x43b0 <display_conf_info+0x106>
    43b6:	11 97       	sbiw	r26, 0x01	; 1
    43b8:	8a e0       	ldi	r24, 0x0A	; 10
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    43ba:	e2 e8       	ldi	r30, 0x82	; 130
    43bc:	f2 e0       	ldi	r31, 0x02	; 2
    43be:	01 90       	ld	r0, Z+
    43c0:	0d 92       	st	X+, r0
    43c2:	8a 95       	dec	r24
    43c4:	e1 f7       	brne	.-8      	; 0x43be <display_conf_info+0x114>
    43c6:	80 91 6a 01 	lds	r24, 0x016A
    43ca:	4a e0       	ldi	r20, 0x0A	; 10
    43cc:	50 e0       	ldi	r21, 0x00	; 0
    43ce:	be 01       	movw	r22, r28
    43d0:	6f 5f       	subi	r22, 0xFF	; 255
  utoa(g_settings.indicator_sound,tmp_str,10);
    43d2:	7f 4f       	sbci	r23, 0xFF	; 255
    43d4:	90 e0       	ldi	r25, 0x00	; 0
    43d6:	ee d5       	rcall	.+3036   	; 0x4fb4 <utoa>
    43d8:	f8 01       	movw	r30, r16
    43da:	01 90       	ld	r0, Z+
    43dc:	00 20       	and	r0, r0
    43de:	e9 f7       	brne	.-6      	; 0x43da <display_conf_info+0x130>
    43e0:	cf 01       	movw	r24, r30
    43e2:	01 97       	sbiw	r24, 0x01	; 1
    43e4:	86 53       	subi	r24, 0x36	; 54
  strcat(uart_buf, "indicator sound (is): ");
    43e6:	90 41       	sbci	r25, 0x10	; 16
    43e8:	dc 01       	movw	r26, r24
    43ea:	aa 5c       	subi	r26, 0xCA	; 202
    43ec:	bf 4e       	sbci	r27, 0xEF	; 239
    43ee:	26 e1       	ldi	r18, 0x16	; 22
    43f0:	ef e3       	ldi	r30, 0x3F	; 63
    43f2:	f3 e0       	ldi	r31, 0x03	; 3
    43f4:	01 90       	ld	r0, Z+
    43f6:	0d 92       	st	X+, r0
    43f8:	2a 95       	dec	r18
    43fa:	e1 f7       	brne	.-8      	; 0x43f4 <display_conf_info+0x14a>
    43fc:	be 01       	movw	r22, r28
    43fe:	6f 5f       	subi	r22, 0xFF	; 255
    4400:	7f 4f       	sbci	r23, 0xFF	; 255
    4402:	84 5b       	subi	r24, 0xB4	; 180
    4404:	9f 4e       	sbci	r25, 0xEF	; 239
    4406:	a0 d5       	rcall	.+2880   	; 0x4f48 <strcpy>
    4408:	d8 01       	movw	r26, r16
  strcat(uart_buf, tmp_str);
    440a:	0d 90       	ld	r0, X+
    440c:	00 20       	and	r0, r0
    440e:	e9 f7       	brne	.-6      	; 0x440a <display_conf_info+0x160>
    4410:	11 97       	sbiw	r26, 0x01	; 1
    4412:	8a e0       	ldi	r24, 0x0A	; 10
    4414:	e2 e8       	ldi	r30, 0x82	; 130
    4416:	f2 e0       	ldi	r31, 0x02	; 2
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4418:	01 90       	ld	r0, Z+
    441a:	0d 92       	st	X+, r0
    441c:	8a 95       	dec	r24
    441e:	e1 f7       	brne	.-8      	; 0x4418 <display_conf_info+0x16e>
    4420:	4a e0       	ldi	r20, 0x0A	; 10
    4422:	50 e0       	ldi	r21, 0x00	; 0
    4424:	be 01       	movw	r22, r28
    4426:	6f 5f       	subi	r22, 0xFF	; 255
    4428:	7f 4f       	sbci	r23, 0xFF	; 255
    442a:	80 91 6b 01 	lds	r24, 0x016B
    442e:	90 91 6c 01 	lds	r25, 0x016C
  utoa(g_settings.blink_speed,tmp_str,10);
    4432:	c0 d5       	rcall	.+2944   	; 0x4fb4 <utoa>
    4434:	f8 01       	movw	r30, r16
    4436:	01 90       	ld	r0, Z+
    4438:	00 20       	and	r0, r0
    443a:	e9 f7       	brne	.-6      	; 0x4436 <display_conf_info+0x18c>
    443c:	cf 01       	movw	r24, r30
    443e:	01 97       	sbiw	r24, 0x01	; 1
    4440:	86 53       	subi	r24, 0x36	; 54
    4442:	90 41       	sbci	r25, 0x10	; 16
    4444:	dc 01       	movw	r26, r24
  strcat(uart_buf, "blink speed (bs): ");
    4446:	aa 5c       	subi	r26, 0xCA	; 202
    4448:	bf 4e       	sbci	r27, 0xEF	; 239
    444a:	22 e1       	ldi	r18, 0x12	; 18
    444c:	e6 e5       	ldi	r30, 0x56	; 86
    444e:	f3 e0       	ldi	r31, 0x03	; 3
    4450:	01 90       	ld	r0, Z+
    4452:	0d 92       	st	X+, r0
    4454:	2a 95       	dec	r18
    4456:	e1 f7       	brne	.-8      	; 0x4450 <display_conf_info+0x1a6>
    4458:	be 01       	movw	r22, r28
    445a:	6f 5f       	subi	r22, 0xFF	; 255
    445c:	7f 4f       	sbci	r23, 0xFF	; 255
    445e:	88 5b       	subi	r24, 0xB8	; 184
    4460:	9f 4e       	sbci	r25, 0xEF	; 239
    4462:	72 d5       	rcall	.+2788   	; 0x4f48 <strcpy>
    4464:	d8 01       	movw	r26, r16
    4466:	0d 90       	ld	r0, X+
    4468:	00 20       	and	r0, r0
  strcat(uart_buf, tmp_str);
    446a:	e9 f7       	brne	.-6      	; 0x4466 <display_conf_info+0x1bc>
    446c:	11 97       	sbiw	r26, 0x01	; 1
    446e:	8a e0       	ldi	r24, 0x0A	; 10
    4470:	e2 e8       	ldi	r30, 0x82	; 130
    4472:	f2 e0       	ldi	r31, 0x02	; 2
    4474:	01 90       	ld	r0, Z+
    4476:	0d 92       	st	X+, r0
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4478:	8a 95       	dec	r24
    447a:	e1 f7       	brne	.-8      	; 0x4474 <display_conf_info+0x1ca>
    447c:	80 91 6d 01 	lds	r24, 0x016D
    4480:	4a e0       	ldi	r20, 0x0A	; 10
    4482:	50 e0       	ldi	r21, 0x00	; 0
    4484:	be 01       	movw	r22, r28
    4486:	6f 5f       	subi	r22, 0xFF	; 255
    4488:	7f 4f       	sbci	r23, 0xFF	; 255
    448a:	90 e0       	ldi	r25, 0x00	; 0
    448c:	93 d5       	rcall	.+2854   	; 0x4fb4 <utoa>
    448e:	f8 01       	movw	r30, r16
  utoa(g_settings.alarm_counter,tmp_str,10);
    4490:	01 90       	ld	r0, Z+
    4492:	00 20       	and	r0, r0
    4494:	e9 f7       	brne	.-6      	; 0x4490 <display_conf_info+0x1e6>
    4496:	cf 01       	movw	r24, r30
    4498:	01 97       	sbiw	r24, 0x01	; 1
    449a:	86 53       	subi	r24, 0x36	; 54
    449c:	90 41       	sbci	r25, 0x10	; 16
    449e:	dc 01       	movw	r26, r24
    44a0:	aa 5c       	subi	r26, 0xCA	; 202
    44a2:	bf 4e       	sbci	r27, 0xEF	; 239
  strcat(uart_buf, "alarm counter (ac): ");
    44a4:	24 e1       	ldi	r18, 0x14	; 20
    44a6:	e9 e6       	ldi	r30, 0x69	; 105
    44a8:	f3 e0       	ldi	r31, 0x03	; 3
    44aa:	01 90       	ld	r0, Z+
    44ac:	0d 92       	st	X+, r0
    44ae:	2a 95       	dec	r18
    44b0:	e1 f7       	brne	.-8      	; 0x44aa <display_conf_info+0x200>
    44b2:	be 01       	movw	r22, r28
    44b4:	6f 5f       	subi	r22, 0xFF	; 255
    44b6:	7f 4f       	sbci	r23, 0xFF	; 255
    44b8:	86 5b       	subi	r24, 0xB6	; 182
    44ba:	9f 4e       	sbci	r25, 0xEF	; 239
    44bc:	45 d5       	rcall	.+2698   	; 0x4f48 <strcpy>
    44be:	d8 01       	movw	r26, r16
    44c0:	0d 90       	ld	r0, X+
    44c2:	00 20       	and	r0, r0
    44c4:	e9 f7       	brne	.-6      	; 0x44c0 <display_conf_info+0x216>
    44c6:	11 97       	sbiw	r26, 0x01	; 1
  strcat(uart_buf, tmp_str);
    44c8:	8a e0       	ldi	r24, 0x0A	; 10
    44ca:	e2 e8       	ldi	r30, 0x82	; 130
    44cc:	f2 e0       	ldi	r31, 0x02	; 2
    44ce:	01 90       	ld	r0, Z+
    44d0:	0d 92       	st	X+, r0
    44d2:	8a 95       	dec	r24
    44d4:	e1 f7       	brne	.-8      	; 0x44ce <display_conf_info+0x224>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    44d6:	80 91 6e 01 	lds	r24, 0x016E
    44da:	4a e0       	ldi	r20, 0x0A	; 10
    44dc:	50 e0       	ldi	r21, 0x00	; 0
    44de:	be 01       	movw	r22, r28
    44e0:	6f 5f       	subi	r22, 0xFF	; 255
    44e2:	7f 4f       	sbci	r23, 0xFF	; 255
    44e4:	90 e0       	ldi	r25, 0x00	; 0
    44e6:	66 d5       	rcall	.+2764   	; 0x4fb4 <utoa>
    44e8:	f8 01       	movw	r30, r16
    44ea:	01 90       	ld	r0, Z+
    44ec:	00 20       	and	r0, r0
  utoa(g_settings.alarm_trigger,tmp_str,10);
    44ee:	e9 f7       	brne	.-6      	; 0x44ea <display_conf_info+0x240>
    44f0:	cf 01       	movw	r24, r30
    44f2:	01 97       	sbiw	r24, 0x01	; 1
    44f4:	86 53       	subi	r24, 0x36	; 54
    44f6:	90 41       	sbci	r25, 0x10	; 16
    44f8:	dc 01       	movw	r26, r24
    44fa:	aa 5c       	subi	r26, 0xCA	; 202
    44fc:	bf 4e       	sbci	r27, 0xEF	; 239
    44fe:	24 e1       	ldi	r18, 0x14	; 20
    4500:	ee e7       	ldi	r30, 0x7E	; 126
  strcat(uart_buf, "alarm trigger (at): ");
    4502:	f3 e0       	ldi	r31, 0x03	; 3
    4504:	01 90       	ld	r0, Z+
    4506:	0d 92       	st	X+, r0
    4508:	2a 95       	dec	r18
    450a:	e1 f7       	brne	.-8      	; 0x4504 <display_conf_info+0x25a>
    450c:	be 01       	movw	r22, r28
    450e:	6f 5f       	subi	r22, 0xFF	; 255
    4510:	7f 4f       	sbci	r23, 0xFF	; 255
    4512:	86 5b       	subi	r24, 0xB6	; 182
    4514:	9f 4e       	sbci	r25, 0xEF	; 239
    4516:	18 d5       	rcall	.+2608   	; 0x4f48 <strcpy>
    4518:	d8 01       	movw	r26, r16
    451a:	0d 90       	ld	r0, X+
    451c:	00 20       	and	r0, r0
    451e:	e9 f7       	brne	.-6      	; 0x451a <display_conf_info+0x270>
    4520:	11 97       	sbiw	r26, 0x01	; 1
    4522:	8a e0       	ldi	r24, 0x0A	; 10
    4524:	e2 e8       	ldi	r30, 0x82	; 130
  strcat(uart_buf, tmp_str);
    4526:	f2 e0       	ldi	r31, 0x02	; 2
    4528:	01 90       	ld	r0, Z+
    452a:	0d 92       	st	X+, r0
    452c:	8a 95       	dec	r24
    452e:	e1 f7       	brne	.-8      	; 0x4528 <display_conf_info+0x27e>
    4530:	80 91 6f 01 	lds	r24, 0x016F
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4534:	4a e0       	ldi	r20, 0x0A	; 10
    4536:	50 e0       	ldi	r21, 0x00	; 0
    4538:	be 01       	movw	r22, r28
    453a:	6f 5f       	subi	r22, 0xFF	; 255
    453c:	7f 4f       	sbci	r23, 0xFF	; 255
    453e:	90 e0       	ldi	r25, 0x00	; 0
    4540:	39 d5       	rcall	.+2674   	; 0x4fb4 <utoa>
    4542:	f8 01       	movw	r30, r16
    4544:	01 90       	ld	r0, Z+
    4546:	00 20       	and	r0, r0
    4548:	e9 f7       	brne	.-6      	; 0x4544 <display_conf_info+0x29a>
    454a:	cf 01       	movw	r24, r30
  utoa(g_settings.alarm_trigger_counter,tmp_str,10);
    454c:	01 97       	sbiw	r24, 0x01	; 1
    454e:	86 53       	subi	r24, 0x36	; 54
    4550:	90 41       	sbci	r25, 0x10	; 16
    4552:	dc 01       	movw	r26, r24
    4554:	aa 5c       	subi	r26, 0xCA	; 202
    4556:	bf 4e       	sbci	r27, 0xEF	; 239
    4558:	25 e1       	ldi	r18, 0x15	; 21
    455a:	e3 e9       	ldi	r30, 0x93	; 147
    455c:	f3 e0       	ldi	r31, 0x03	; 3
    455e:	01 90       	ld	r0, Z+
  strcat(uart_buf, "alarm trigger (atc): ");
    4560:	0d 92       	st	X+, r0
    4562:	2a 95       	dec	r18
    4564:	e1 f7       	brne	.-8      	; 0x455e <display_conf_info+0x2b4>
    4566:	be 01       	movw	r22, r28
    4568:	6f 5f       	subi	r22, 0xFF	; 255
    456a:	7f 4f       	sbci	r23, 0xFF	; 255
    456c:	85 5b       	subi	r24, 0xB5	; 181
    456e:	9f 4e       	sbci	r25, 0xEF	; 239
    4570:	eb d4       	rcall	.+2518   	; 0x4f48 <strcpy>
    4572:	d8 01       	movw	r26, r16
    4574:	0d 90       	ld	r0, X+
    4576:	00 20       	and	r0, r0
    4578:	e9 f7       	brne	.-6      	; 0x4574 <display_conf_info+0x2ca>
    457a:	11 97       	sbiw	r26, 0x01	; 1
    457c:	8a e0       	ldi	r24, 0x0A	; 10
    457e:	e2 e8       	ldi	r30, 0x82	; 130
    4580:	f2 e0       	ldi	r31, 0x02	; 2
    4582:	01 90       	ld	r0, Z+
  strcat(uart_buf, tmp_str);
    4584:	0d 92       	st	X+, r0
    4586:	8a 95       	dec	r24
    4588:	e1 f7       	brne	.-8      	; 0x4582 <display_conf_info+0x2d8>
    458a:	80 91 70 01 	lds	r24, 0x0170
    458e:	4a e0       	ldi	r20, 0x0A	; 10
    4590:	50 e0       	ldi	r21, 0x00	; 0
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4592:	be 01       	movw	r22, r28
    4594:	6f 5f       	subi	r22, 0xFF	; 255
    4596:	7f 4f       	sbci	r23, 0xFF	; 255
    4598:	90 e0       	ldi	r25, 0x00	; 0
    459a:	0c d5       	rcall	.+2584   	; 0x4fb4 <utoa>
    459c:	f8 01       	movw	r30, r16
    459e:	01 90       	ld	r0, Z+
    45a0:	00 20       	and	r0, r0
    45a2:	e9 f7       	brne	.-6      	; 0x459e <display_conf_info+0x2f4>
    45a4:	cf 01       	movw	r24, r30
    45a6:	01 97       	sbiw	r24, 0x01	; 1
    45a8:	86 53       	subi	r24, 0x36	; 54
  utoa(g_settings.alarm_thres_min,tmp_str,10);
    45aa:	90 41       	sbci	r25, 0x10	; 16
    45ac:	dc 01       	movw	r26, r24
    45ae:	aa 5c       	subi	r26, 0xCA	; 202
    45b0:	bf 4e       	sbci	r27, 0xEF	; 239
    45b2:	2e e1       	ldi	r18, 0x1E	; 30
    45b4:	e9 ea       	ldi	r30, 0xA9	; 169
    45b6:	f3 e0       	ldi	r31, 0x03	; 3
    45b8:	01 90       	ld	r0, Z+
    45ba:	0d 92       	st	X+, r0
    45bc:	2a 95       	dec	r18
  strcat(uart_buf, "alarm min. threshold (amint): ");
    45be:	e1 f7       	brne	.-8      	; 0x45b8 <display_conf_info+0x30e>
    45c0:	be 01       	movw	r22, r28
    45c2:	6f 5f       	subi	r22, 0xFF	; 255
    45c4:	7f 4f       	sbci	r23, 0xFF	; 255
    45c6:	8c 5a       	subi	r24, 0xAC	; 172
    45c8:	9f 4e       	sbci	r25, 0xEF	; 239
    45ca:	be d4       	rcall	.+2428   	; 0x4f48 <strcpy>
    45cc:	d8 01       	movw	r26, r16
    45ce:	0d 90       	ld	r0, X+
    45d0:	00 20       	and	r0, r0
    45d2:	e9 f7       	brne	.-6      	; 0x45ce <display_conf_info+0x324>
    45d4:	11 97       	sbiw	r26, 0x01	; 1
    45d6:	8a e0       	ldi	r24, 0x0A	; 10
    45d8:	e2 e8       	ldi	r30, 0x82	; 130
    45da:	f2 e0       	ldi	r31, 0x02	; 2
    45dc:	01 90       	ld	r0, Z+
    45de:	0d 92       	st	X+, r0
    45e0:	8a 95       	dec	r24
  strcat(uart_buf, tmp_str);
    45e2:	e1 f7       	brne	.-8      	; 0x45dc <display_conf_info+0x332>
    45e4:	4a e0       	ldi	r20, 0x0A	; 10
    45e6:	50 e0       	ldi	r21, 0x00	; 0
    45e8:	be 01       	movw	r22, r28
    45ea:	6f 5f       	subi	r22, 0xFF	; 255
    45ec:	7f 4f       	sbci	r23, 0xFF	; 255
    45ee:	80 91 71 01 	lds	r24, 0x0171
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    45f2:	90 91 72 01 	lds	r25, 0x0172
    45f6:	de d4       	rcall	.+2492   	; 0x4fb4 <utoa>
    45f8:	f8 01       	movw	r30, r16
    45fa:	01 90       	ld	r0, Z+
    45fc:	00 20       	and	r0, r0
    45fe:	e9 f7       	brne	.-6      	; 0x45fa <display_conf_info+0x350>
    4600:	cf 01       	movw	r24, r30
    4602:	01 97       	sbiw	r24, 0x01	; 1
    4604:	86 53       	subi	r24, 0x36	; 54
    4606:	90 41       	sbci	r25, 0x10	; 16
  utoa(g_settings.alarm_thres_max,tmp_str,10);
    4608:	dc 01       	movw	r26, r24
    460a:	aa 5c       	subi	r26, 0xCA	; 202
    460c:	bf 4e       	sbci	r27, 0xEF	; 239
    460e:	2d e1       	ldi	r18, 0x1D	; 29
    4610:	e8 ec       	ldi	r30, 0xC8	; 200
    4612:	f3 e0       	ldi	r31, 0x03	; 3
    4614:	01 90       	ld	r0, Z+
    4616:	0d 92       	st	X+, r0
    4618:	2a 95       	dec	r18
    461a:	e1 f7       	brne	.-8      	; 0x4614 <display_conf_info+0x36a>
    461c:	be 01       	movw	r22, r28
  strcat(uart_buf, "alarm max.threshold (amaxt): ");
    461e:	6f 5f       	subi	r22, 0xFF	; 255
    4620:	7f 4f       	sbci	r23, 0xFF	; 255
    4622:	8d 5a       	subi	r24, 0xAD	; 173
    4624:	9f 4e       	sbci	r25, 0xEF	; 239
    4626:	90 d4       	rcall	.+2336   	; 0x4f48 <strcpy>
    4628:	d8 01       	movw	r26, r16
    462a:	0d 90       	ld	r0, X+
    462c:	00 20       	and	r0, r0
    462e:	e9 f7       	brne	.-6      	; 0x462a <display_conf_info+0x380>
    4630:	11 97       	sbiw	r26, 0x01	; 1
    4632:	8a e0       	ldi	r24, 0x0A	; 10
    4634:	e2 e8       	ldi	r30, 0x82	; 130
    4636:	f2 e0       	ldi	r31, 0x02	; 2
    4638:	01 90       	ld	r0, Z+
    463a:	0d 92       	st	X+, r0
    463c:	8a 95       	dec	r24
    463e:	e1 f7       	brne	.-8      	; 0x4638 <display_conf_info+0x38e>
    4640:	80 91 73 01 	lds	r24, 0x0173
  strcat(uart_buf, tmp_str);
    4644:	4a e0       	ldi	r20, 0x0A	; 10
    4646:	50 e0       	ldi	r21, 0x00	; 0
    4648:	be 01       	movw	r22, r28
    464a:	6f 5f       	subi	r22, 0xFF	; 255
    464c:	7f 4f       	sbci	r23, 0xFF	; 255
    464e:	90 e0       	ldi	r25, 0x00	; 0
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    4650:	b1 d4       	rcall	.+2402   	; 0x4fb4 <utoa>
    4652:	f8 01       	movw	r30, r16
    4654:	01 90       	ld	r0, Z+
    4656:	00 20       	and	r0, r0
    4658:	e9 f7       	brne	.-6      	; 0x4654 <display_conf_info+0x3aa>
    465a:	cf 01       	movw	r24, r30
    465c:	01 97       	sbiw	r24, 0x01	; 1
    465e:	86 53       	subi	r24, 0x36	; 54
    4660:	90 41       	sbci	r25, 0x10	; 16
    4662:	dc 01       	movw	r26, r24
    4664:	aa 5c       	subi	r26, 0xCA	; 202
    4666:	bf 4e       	sbci	r27, 0xEF	; 239
  utoa(g_settings.backpedal,tmp_str,10);
    4668:	20 e1       	ldi	r18, 0x10	; 16
    466a:	e6 ee       	ldi	r30, 0xE6	; 230
    466c:	f3 e0       	ldi	r31, 0x03	; 3
    466e:	01 90       	ld	r0, Z+
    4670:	0d 92       	st	X+, r0
    4672:	2a 95       	dec	r18
    4674:	e1 f7       	brne	.-8      	; 0x466e <display_conf_info+0x3c4>
    4676:	be 01       	movw	r22, r28
    4678:	6f 5f       	subi	r22, 0xFF	; 255
    467a:	7f 4f       	sbci	r23, 0xFF	; 255
  strcat(uart_buf, "backpedal (bp): ");
    467c:	8a 5b       	subi	r24, 0xBA	; 186
    467e:	9f 4e       	sbci	r25, 0xEF	; 239
    4680:	63 d4       	rcall	.+2246   	; 0x4f48 <strcpy>
    4682:	d8 01       	movw	r26, r16
    4684:	0d 90       	ld	r0, X+
    4686:	00 20       	and	r0, r0
    4688:	e9 f7       	brne	.-6      	; 0x4684 <display_conf_info+0x3da>
    468a:	11 97       	sbiw	r26, 0x01	; 1
    468c:	8a e0       	ldi	r24, 0x0A	; 10
    468e:	e2 e8       	ldi	r30, 0x82	; 130
    4690:	f2 e0       	ldi	r31, 0x02	; 2
    4692:	01 90       	ld	r0, Z+
    4694:	0d 92       	st	X+, r0
    4696:	8a 95       	dec	r24
    4698:	e1 f7       	brne	.-8      	; 0x4692 <display_conf_info+0x3e8>
    469a:	4a e0       	ldi	r20, 0x0A	; 10
    469c:	50 e0       	ldi	r21, 0x00	; 0
    469e:	be 01       	movw	r22, r28
  strcat(uart_buf, tmp_str);
    46a0:	6f 5f       	subi	r22, 0xFF	; 255
    46a2:	7f 4f       	sbci	r23, 0xFF	; 255
    46a4:	80 91 74 01 	lds	r24, 0x0174
    46a8:	90 91 75 01 	lds	r25, 0x0175
    46ac:	83 d4       	rcall	.+2310   	; 0x4fb4 <utoa>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    46ae:	f8 01       	movw	r30, r16
    46b0:	01 90       	ld	r0, Z+
    46b2:	00 20       	and	r0, r0
    46b4:	e9 f7       	brne	.-6      	; 0x46b0 <display_conf_info+0x406>
    46b6:	cf 01       	movw	r24, r30
    46b8:	01 97       	sbiw	r24, 0x01	; 1
    46ba:	86 53       	subi	r24, 0x36	; 54
    46bc:	90 41       	sbci	r25, 0x10	; 16
    46be:	dc 01       	movw	r26, r24
    46c0:	aa 5c       	subi	r26, 0xCA	; 202
    46c2:	bf 4e       	sbci	r27, 0xEF	; 239
    46c4:	2c e1       	ldi	r18, 0x1C	; 28
  utoa(g_settings.backpedal_thres_min,tmp_str,10);
    46c6:	e7 ef       	ldi	r30, 0xF7	; 247
    46c8:	f3 e0       	ldi	r31, 0x03	; 3
    46ca:	01 90       	ld	r0, Z+
    46cc:	0d 92       	st	X+, r0
    46ce:	2a 95       	dec	r18
    46d0:	e1 f7       	brne	.-8      	; 0x46ca <display_conf_info+0x420>
    46d2:	be 01       	movw	r22, r28
    46d4:	6f 5f       	subi	r22, 0xFF	; 255
    46d6:	7f 4f       	sbci	r23, 0xFF	; 255
    46d8:	8f 5a       	subi	r24, 0xAF	; 175
    46da:	9f 4e       	sbci	r25, 0xEF	; 239
  strcat(uart_buf, "backpedal threshold (bpt): ");
    46dc:	35 d4       	rcall	.+2154   	; 0x4f48 <strcpy>
    46de:	d8 01       	movw	r26, r16
    46e0:	0d 90       	ld	r0, X+
    46e2:	00 20       	and	r0, r0
    46e4:	e9 f7       	brne	.-6      	; 0x46e0 <display_conf_info+0x436>
    46e6:	11 97       	sbiw	r26, 0x01	; 1
    46e8:	8a e0       	ldi	r24, 0x0A	; 10
    46ea:	e2 e8       	ldi	r30, 0x82	; 130
    46ec:	f2 e0       	ldi	r31, 0x02	; 2
    46ee:	01 90       	ld	r0, Z+
    46f0:	0d 92       	st	X+, r0
    46f2:	8a 95       	dec	r24
    46f4:	e1 f7       	brne	.-8      	; 0x46ee <display_conf_info+0x444>
    46f6:	80 91 76 01 	lds	r24, 0x0176
    46fa:	4a e0       	ldi	r20, 0x0A	; 10
    46fc:	50 e0       	ldi	r21, 0x00	; 0
    46fe:	be 01       	movw	r22, r28
  strcat(uart_buf, tmp_str);
    4700:	6f 5f       	subi	r22, 0xFF	; 255
    4702:	7f 4f       	sbci	r23, 0xFF	; 255
    4704:	90 e0       	ldi	r25, 0x00	; 0
    4706:	56 d4       	rcall	.+2220   	; 0x4fb4 <utoa>
    4708:	f8 01       	movw	r30, r16
    470a:	01 90       	ld	r0, Z+
    470c:	00 20       	and	r0, r0
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    470e:	e9 f7       	brne	.-6      	; 0x470a <display_conf_info+0x460>
    4710:	cf 01       	movw	r24, r30
    4712:	01 97       	sbiw	r24, 0x01	; 1
    4714:	86 53       	subi	r24, 0x36	; 54
    4716:	90 41       	sbci	r25, 0x10	; 16
    4718:	dc 01       	movw	r26, r24
    471a:	aa 5c       	subi	r26, 0xCA	; 202
    471c:	bf 4e       	sbci	r27, 0xEF	; 239
    471e:	24 e1       	ldi	r18, 0x14	; 20
    4720:	e3 e1       	ldi	r30, 0x13	; 19
    4722:	f4 e0       	ldi	r31, 0x04	; 4
    4724:	01 90       	ld	r0, Z+
  utoa(g_settings.startup_sound,tmp_str,10);
    4726:	0d 92       	st	X+, r0
    4728:	2a 95       	dec	r18
    472a:	e1 f7       	brne	.-8      	; 0x4724 <display_conf_info+0x47a>
    472c:	be 01       	movw	r22, r28
    472e:	6f 5f       	subi	r22, 0xFF	; 255
    4730:	7f 4f       	sbci	r23, 0xFF	; 255
    4732:	86 5b       	subi	r24, 0xB6	; 182
    4734:	9f 4e       	sbci	r25, 0xEF	; 239
    4736:	08 d4       	rcall	.+2064   	; 0x4f48 <strcpy>
    4738:	d8 01       	movw	r26, r16
  strcat(uart_buf, "startup sound (ss): ");
    473a:	0d 90       	ld	r0, X+
    473c:	00 20       	and	r0, r0
    473e:	e9 f7       	brne	.-6      	; 0x473a <display_conf_info+0x490>
    4740:	11 97       	sbiw	r26, 0x01	; 1
    4742:	8a e0       	ldi	r24, 0x0A	; 10
    4744:	e2 e8       	ldi	r30, 0x82	; 130
    4746:	f2 e0       	ldi	r31, 0x02	; 2
    4748:	01 90       	ld	r0, Z+
    474a:	0d 92       	st	X+, r0
    474c:	8a 95       	dec	r24
    474e:	e1 f7       	brne	.-8      	; 0x4748 <display_conf_info+0x49e>
    4750:	80 91 77 01 	lds	r24, 0x0177
    4754:	4a e0       	ldi	r20, 0x0A	; 10
    4756:	50 e0       	ldi	r21, 0x00	; 0
    4758:	be 01       	movw	r22, r28
    475a:	6f 5f       	subi	r22, 0xFF	; 255
    475c:	7f 4f       	sbci	r23, 0xFF	; 255
  strcat(uart_buf, tmp_str);
    475e:	90 e0       	ldi	r25, 0x00	; 0
    4760:	29 d4       	rcall	.+2130   	; 0x4fb4 <utoa>
    4762:	f8 01       	movw	r30, r16
    4764:	01 90       	ld	r0, Z+
    4766:	00 20       	and	r0, r0
    4768:	e9 f7       	brne	.-6      	; 0x4764 <display_conf_info+0x4ba>
    476a:	cf 01       	movw	r24, r30
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    476c:	01 97       	sbiw	r24, 0x01	; 1
    476e:	86 53       	subi	r24, 0x36	; 54
    4770:	90 41       	sbci	r25, 0x10	; 16
    4772:	dc 01       	movw	r26, r24
    4774:	aa 5c       	subi	r26, 0xCA	; 202
    4776:	bf 4e       	sbci	r27, 0xEF	; 239
    4778:	22 e1       	ldi	r18, 0x12	; 18
    477a:	e8 e2       	ldi	r30, 0x28	; 40
    477c:	f4 e0       	ldi	r31, 0x04	; 4
    477e:	01 90       	ld	r0, Z+
    4780:	0d 92       	st	X+, r0
    4782:	2a 95       	dec	r18
  utoa(g_settings.alarm_sound,tmp_str,10);
    4784:	e1 f7       	brne	.-8      	; 0x477e <display_conf_info+0x4d4>
    4786:	be 01       	movw	r22, r28
    4788:	6f 5f       	subi	r22, 0xFF	; 255
    478a:	7f 4f       	sbci	r23, 0xFF	; 255
    478c:	88 5b       	subi	r24, 0xB8	; 184
    478e:	9f 4e       	sbci	r25, 0xEF	; 239
    4790:	db d3       	rcall	.+1974   	; 0x4f48 <strcpy>
    4792:	f8 01       	movw	r30, r16
    4794:	01 90       	ld	r0, Z+
    4796:	00 20       	and	r0, r0
  strcat(uart_buf, "alarm sound (as): ");
    4798:	e9 f7       	brne	.-6      	; 0x4794 <display_conf_info+0x4ea>
    479a:	cf 01       	movw	r24, r30
    479c:	01 97       	sbiw	r24, 0x01	; 1
    479e:	86 53       	subi	r24, 0x36	; 54
    47a0:	90 41       	sbci	r25, 0x10	; 16
    47a2:	dc 01       	movw	r26, r24
    47a4:	aa 5c       	subi	r26, 0xCA	; 202
    47a6:	bf 4e       	sbci	r27, 0xEF	; 239
    47a8:	29 e0       	ldi	r18, 0x09	; 9
    47aa:	e2 e8       	ldi	r30, 0x82	; 130
    47ac:	f2 e0       	ldi	r31, 0x02	; 2
    47ae:	01 90       	ld	r0, Z+
    47b0:	0d 92       	st	X+, r0
    47b2:	2a 95       	dec	r18
    47b4:	e1 f7       	brne	.-8      	; 0x47ae <display_conf_info+0x504>
    47b6:	dc 01       	movw	r26, r24
    47b8:	a1 5c       	subi	r26, 0xC1	; 193
    47ba:	bf 4e       	sbci	r27, 0xEF	; 239
  strcat(uart_buf, tmp_str);
    47bc:	2e e0       	ldi	r18, 0x0E	; 14
    47be:	eb e3       	ldi	r30, 0x3B	; 59
    47c0:	f4 e0       	ldi	r31, 0x04	; 4
    47c2:	01 90       	ld	r0, Z+
    47c4:	0d 92       	st	X+, r0
    47c6:	2a 95       	dec	r18
    47c8:	e1 f7       	brne	.-8      	; 0x47c2 <display_conf_info+0x518>
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    47ca:	68 e7       	ldi	r22, 0x78	; 120
    47cc:	71 e0       	ldi	r23, 0x01	; 1
    47ce:	83 5b       	subi	r24, 0xB3	; 179
    47d0:	9f 4e       	sbci	r25, 0xEF	; 239
    47d2:	ba d3       	rcall	.+1908   	; 0x4f48 <strcpy>
    47d4:	d8 01       	movw	r26, r16
    47d6:	0d 90       	ld	r0, X+
    47d8:	00 20       	and	r0, r0
    47da:	e9 f7       	brne	.-6      	; 0x47d6 <display_conf_info+0x52c>
    47dc:	11 97       	sbiw	r26, 0x01	; 1
    47de:	8a e0       	ldi	r24, 0x0A	; 10
    47e0:	e2 e8       	ldi	r30, 0x82	; 130
    47e2:	f2 e0       	ldi	r31, 0x02	; 2
    47e4:	01 90       	ld	r0, Z+
    47e6:	0d 92       	st	X+, r0
    47e8:	8a 95       	dec	r24
    47ea:	e1 f7       	brne	.-8      	; 0x47e4 <display_conf_info+0x53a>
    47ec:	c8 01       	movw	r24, r16
  strcat(uart_buf, "password (p): ");
    47ee:	a0 96       	adiw	r28, 0x20	; 32
    47f0:	0f b6       	in	r0, 0x3f	; 63
    47f2:	f8 94       	cli
    47f4:	de bf       	out	0x3e, r29	; 62
    47f6:	0f be       	out	0x3f, r0	; 63
    47f8:	cd bf       	out	0x3d, r28	; 61
    47fa:	df 91       	pop	r29
    47fc:	cf 91       	pop	r28
    47fe:	1f 91       	pop	r17
    4800:	0f 91       	pop	r16
  strcat(uart_buf, g_settings.passwd);
    4802:	08 95       	ret

00004804 <command_handle_show_conf>:
    4804:	cf 93       	push	r28
    4806:	df 93       	push	r29
    4808:	ec 01       	movw	r28, r24
    480a:	4f dd       	rcall	.-1378   	; 0x42aa <display_conf_info>
    480c:	bc 01       	movw	r22, r24
  strcat(uart_buf, "\x1B[1B\x1B[2K\x0D");
    480e:	ce 01       	movw	r24, r28
    4810:	df 91       	pop	r29
    4812:	cf 91       	pop	r28
    4814:	99 c3       	rjmp	.+1842   	; 0x4f48 <strcpy>

00004816 <command_usart_input>:
static uint8_t g_buffer_pos;
static uint8_t g_command_status;

#define B_SIZE ((int) (sizeof(g_buffer) / sizeof(g_buffer[0]))) 

void command_usart_input(uint8_t event, char *cmd) {
    4816:	1f 93       	push	r17
    4818:	cf 93       	push	r28
    481a:	df 93       	push	r29
    481c:	eb 01       	movw	r28, r22
  uint8_t status, current;
  if (event == 0) {
    481e:	88 23       	and	r24, r24
    4820:	21 f0       	breq	.+8      	; 0x482a <command_usart_input+0x14>
      g_command_status = CMD_IN_PROCESS;
    } else { // set command as "still empty"
      cmd[0] = '\0'; 
    }
  }
}
    4822:	df 91       	pop	r29
    4824:	cf 91       	pop	r28
    4826:	1f 91       	pop	r17
    4828:	08 95       	ret
#define B_SIZE ((int) (sizeof(g_buffer) / sizeof(g_buffer[0]))) 

void command_usart_input(uint8_t event, char *cmd) {
  uint8_t status, current;
  if (event == 0) {
    if (uart_available()) { // data ready
    482a:	0e 94 9d 1b 	call	0x373a	; 0x373a <uart_available>
    482e:	81 11       	cpse	r24, r1
    4830:	09 c0       	rjmp	.+18     	; 0x4844 <command_usart_input+0x2e>
    4832:	80 91 23 0d 	lds	r24, 0x0D23
          g_buffer[g_buffer_pos] = '\0'; // mark current pos as end
          g_buffer_pos = 0;
          g_command_status = CMD_RDY;
      }
    }
    if (g_command_status == CMD_RDY) { // copy buffer to command
    4836:	81 30       	cpi	r24, 0x01	; 1
    4838:	39 f1       	breq	.+78     	; 0x4888 <command_usart_input+0x72>
      strcpy(cmd, g_buffer);
      g_command_status = CMD_IN_PROCESS;
    } else { // set command as "still empty"
      cmd[0] = '\0'; 
    483a:	18 82       	st	Y, r1
    }
  }
}
    483c:	df 91       	pop	r29
    483e:	cf 91       	pop	r28
    4840:	1f 91       	pop	r17
    4842:	08 95       	ret

void command_usart_input(uint8_t event, char *cmd) {
  uint8_t status, current;
  if (event == 0) {
    if (uart_available()) { // data ready
      current = uart_get();
    4844:	0e 94 03 1b 	call	0x3606	; 0x3606 <uart_get>
    4848:	18 2f       	mov	r17, r24
    uart_put_str("\x1B[2K\x0D"); // clear line and CR
  }
}

uint8_t command_usart_parse(uint8_t *current) {
  if (*current == 0x0d) {
    484a:	8d 30       	cpi	r24, 0x0D	; 13
    484c:	a9 f0       	breq	.+42     	; 0x4878 <command_usart_input+0x62>
    return CHAR_ENTER;
  } else if (*current == 0x08) {
    484e:	80 ee       	ldi	r24, 0xE0	; 224
    4850:	81 0f       	add	r24, r17
    4852:	8f 35       	cpi	r24, 0x5F	; 95
    4854:	70 f7       	brcc	.-36     	; 0x4832 <command_usart_input+0x1c>
      status = command_usart_parse(&current);
      if (status == CHAR_NORMAL) {
        if (g_buffer_pos >= B_SIZE) { // reset when full
          g_buffer_pos = 0;
        }
        uart_put(current); // echo valid char back
    4856:	81 2f       	mov	r24, r17
    4858:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <uart_put>
        g_buffer[g_buffer_pos] = current; // add to buffer
    485c:	80 91 24 0d 	lds	r24, 0x0D24
    4860:	e8 2f       	mov	r30, r24
    4862:	f0 e0       	ldi	r31, 0x00	; 0
    4864:	eb 5d       	subi	r30, 0xDB	; 219
    4866:	f2 4f       	sbci	r31, 0xF2	; 242
    4868:	10 83       	st	Z, r17
        g_command_status = CMD_IN_PROCESS;
    486a:	10 92 23 0d 	sts	0x0D23, r1
        g_buffer_pos++;
    486e:	8f 5f       	subi	r24, 0xFF	; 255
    4870:	80 93 24 0d 	sts	0x0D24, r24
    }
    if (g_command_status == CMD_RDY) { // copy buffer to command
      strcpy(cmd, g_buffer);
      g_command_status = CMD_IN_PROCESS;
    } else { // set command as "still empty"
      cmd[0] = '\0'; 
    4874:	18 82       	st	Y, r1
    4876:	e2 cf       	rjmp	.-60     	; 0x483c <command_usart_input+0x26>
        uart_put(current); // echo valid char back
        g_buffer[g_buffer_pos] = current; // add to buffer
        g_command_status = CMD_IN_PROCESS;
        g_buffer_pos++;
      } else if (status == CHAR_ENTER) { // enter pressed
          g_buffer[g_buffer_pos] = '\0'; // mark current pos as end
    4878:	e0 91 24 0d 	lds	r30, 0x0D24
    487c:	f0 e0       	ldi	r31, 0x00	; 0
    487e:	eb 5d       	subi	r30, 0xDB	; 219
    4880:	f2 4f       	sbci	r31, 0xF2	; 242
    4882:	10 82       	st	Z, r1
          g_buffer_pos = 0;
    4884:	10 92 24 0d 	sts	0x0D24, r1
          g_command_status = CMD_RDY;
      }
    }
    if (g_command_status == CMD_RDY) { // copy buffer to command
      strcpy(cmd, g_buffer);
    4888:	65 e2       	ldi	r22, 0x25	; 37
    488a:	7d e0       	ldi	r23, 0x0D	; 13
    488c:	ce 01       	movw	r24, r28
    488e:	5c d3       	rcall	.+1720   	; 0x4f48 <strcpy>
    4890:	10 92 23 0d 	sts	0x0D23, r1
      g_command_status = CMD_IN_PROCESS;
    4894:	c6 cf       	rjmp	.-116    	; 0x4822 <command_usart_input+0xc>

00004896 <command_usart_output>:
    4896:	ef 92       	push	r14
      cmd[0] = '\0'; 
    }
  }
}

void command_usart_output(const char *cmd, uint8_t flashmem, uint8_t clear) {
    4898:	ff 92       	push	r15
    489a:	1f 93       	push	r17
    489c:	cf 93       	push	r28
    489e:	df 93       	push	r29
    48a0:	1f 92       	push	r1
    48a2:	cd b7       	in	r28, 0x3d	; 61
    48a4:	de b7       	in	r29, 0x3e	; 62
    48a6:	7c 01       	movw	r14, r24
    48a8:	14 2f       	mov	r17, r20
  if (clear == 1 || clear == 3) {
    48aa:	84 2f       	mov	r24, r20
    48ac:	8d 7f       	andi	r24, 0xFD	; 253
    48ae:	81 30       	cpi	r24, 0x01	; 1
    48b0:	11 f1       	breq	.+68     	; 0x48f6 <command_usart_output+0x60>
    uart_put_str("\x1B[2J\x0D"); // clear entire screen
  }
  if (flashmem) {
    uart_put_str_P(cmd);
    48b2:	c7 01       	movw	r24, r14

void command_usart_output(const char *cmd, uint8_t flashmem, uint8_t clear) {
  if (clear == 1 || clear == 3) {
    uart_put_str("\x1B[2J\x0D"); // clear entire screen
  }
  if (flashmem) {
    48b4:	66 23       	and	r22, r22
    48b6:	61 f0       	breq	.+24     	; 0x48d0 <command_usart_output+0x3a>
    uart_put_str_P(cmd);
    48b8:	0e 94 29 1b 	call	0x3652	; 0x3652 <uart_put_str_P>
  } else {
    uart_put_str(cmd);
  }
  if (clear == 2 || clear == 3) {
    48bc:	12 50       	subi	r17, 0x02	; 2
    48be:	12 30       	cpi	r17, 0x02	; 2
    48c0:	60 f0       	brcs	.+24     	; 0x48da <command_usart_output+0x44>
    uart_put_str("\x1B[1B"); // next line
    uart_put_str("\x1B[2K\x0D"); // clear line and CR
  }
}
    48c2:	0f 90       	pop	r0
    48c4:	df 91       	pop	r29
    48c6:	cf 91       	pop	r28
    48c8:	1f 91       	pop	r17
    48ca:	ff 90       	pop	r15
    48cc:	ef 90       	pop	r14
    48ce:	08 95       	ret
    uart_put_str("\x1B[2J\x0D"); // clear entire screen
  }
  if (flashmem) {
    uart_put_str_P(cmd);
  } else {
    uart_put_str(cmd);
    48d0:	0e 94 0e 1b 	call	0x361c	; 0x361c <uart_put_str>
  }
  if (clear == 2 || clear == 3) {
    48d4:	12 50       	subi	r17, 0x02	; 2
    48d6:	12 30       	cpi	r17, 0x02	; 2
    48d8:	a0 f7       	brcc	.-24     	; 0x48c2 <command_usart_output+0x2c>
    uart_put_str("\x1B[1B"); // next line
    48da:	80 e5       	ldi	r24, 0x50	; 80
    48dc:	94 e0       	ldi	r25, 0x04	; 4
    48de:	0e 94 0e 1b 	call	0x361c	; 0x361c <uart_put_str>
    uart_put_str("\x1B[2K\x0D"); // clear line and CR
    48e2:	86 e8       	ldi	r24, 0x86	; 134
    48e4:	92 e0       	ldi	r25, 0x02	; 2
  }
}
    48e6:	0f 90       	pop	r0
    48e8:	df 91       	pop	r29
    48ea:	cf 91       	pop	r28
    48ec:	1f 91       	pop	r17
    48ee:	ff 90       	pop	r15
    48f0:	ef 90       	pop	r14
  } else {
    uart_put_str(cmd);
  }
  if (clear == 2 || clear == 3) {
    uart_put_str("\x1B[1B"); // next line
    uart_put_str("\x1B[2K\x0D"); // clear line and CR
    48f2:	0c 94 0e 1b 	jmp	0x361c	; 0x361c <uart_put_str>
  }
}

void command_usart_output(const char *cmd, uint8_t flashmem, uint8_t clear) {
  if (clear == 1 || clear == 3) {
    uart_put_str("\x1B[2J\x0D"); // clear entire screen
    48f6:	8a e4       	ldi	r24, 0x4A	; 74
    48f8:	94 e0       	ldi	r25, 0x04	; 4
    48fa:	69 83       	std	Y+1, r22	; 0x01
    48fc:	0e 94 0e 1b 	call	0x361c	; 0x361c <uart_put_str>
    4900:	69 81       	ldd	r22, Y+1	; 0x01
    4902:	d7 cf       	rjmp	.-82     	; 0x48b2 <command_usart_output+0x1c>

00004904 <__udivmodhi4>:
    4904:	aa 1b       	sub	r26, r26
    4906:	bb 1b       	sub	r27, r27
    4908:	51 e1       	ldi	r21, 0x11	; 17
    490a:	07 c0       	rjmp	.+14     	; 0x491a <__udivmodhi4_ep>

0000490c <__udivmodhi4_loop>:
    490c:	aa 1f       	adc	r26, r26
    490e:	bb 1f       	adc	r27, r27
    4910:	a6 17       	cp	r26, r22
    4912:	b7 07       	cpc	r27, r23
    4914:	10 f0       	brcs	.+4      	; 0x491a <__udivmodhi4_ep>
    4916:	a6 1b       	sub	r26, r22
    4918:	b7 0b       	sbc	r27, r23

0000491a <__udivmodhi4_ep>:
    491a:	88 1f       	adc	r24, r24
    491c:	99 1f       	adc	r25, r25
    491e:	5a 95       	dec	r21
    4920:	a9 f7       	brne	.-22     	; 0x490c <__udivmodhi4_loop>
    4922:	80 95       	com	r24
    4924:	90 95       	com	r25
    4926:	bc 01       	movw	r22, r24
    4928:	cd 01       	movw	r24, r26
    492a:	08 95       	ret

0000492c <__divmodhi4>:
    492c:	97 fb       	bst	r25, 7
    492e:	07 2e       	mov	r0, r23
    4930:	16 f4       	brtc	.+4      	; 0x4936 <__divmodhi4+0xa>
    4932:	00 94       	com	r0
    4934:	06 d0       	rcall	.+12     	; 0x4942 <__divmodhi4_neg1>
    4936:	77 fd       	sbrc	r23, 7
    4938:	08 d0       	rcall	.+16     	; 0x494a <__divmodhi4_neg2>
    493a:	e4 df       	rcall	.-56     	; 0x4904 <__udivmodhi4>
    493c:	07 fc       	sbrc	r0, 7
    493e:	05 d0       	rcall	.+10     	; 0x494a <__divmodhi4_neg2>
    4940:	3e f4       	brtc	.+14     	; 0x4950 <__divmodhi4_exit>

00004942 <__divmodhi4_neg1>:
    4942:	90 95       	com	r25
    4944:	81 95       	neg	r24
    4946:	9f 4f       	sbci	r25, 0xFF	; 255
    4948:	08 95       	ret

0000494a <__divmodhi4_neg2>:
    494a:	70 95       	com	r23
    494c:	61 95       	neg	r22
    494e:	7f 4f       	sbci	r23, 0xFF	; 255

00004950 <__divmodhi4_exit>:
    4950:	08 95       	ret

00004952 <malloc>:
    4952:	cf 93       	push	r28
    4954:	df 93       	push	r29
    4956:	82 30       	cpi	r24, 0x02	; 2
    4958:	91 05       	cpc	r25, r1
    495a:	10 f4       	brcc	.+4      	; 0x4960 <malloc+0xe>
    495c:	82 e0       	ldi	r24, 0x02	; 2
    495e:	90 e0       	ldi	r25, 0x00	; 0
    4960:	e0 91 47 12 	lds	r30, 0x1247
    4964:	f0 91 48 12 	lds	r31, 0x1248
    4968:	20 e0       	ldi	r18, 0x00	; 0
    496a:	30 e0       	ldi	r19, 0x00	; 0
    496c:	a0 e0       	ldi	r26, 0x00	; 0
    496e:	b0 e0       	ldi	r27, 0x00	; 0
    4970:	30 97       	sbiw	r30, 0x00	; 0
    4972:	39 f1       	breq	.+78     	; 0x49c2 <malloc+0x70>
    4974:	40 81       	ld	r20, Z
    4976:	51 81       	ldd	r21, Z+1	; 0x01
    4978:	48 17       	cp	r20, r24
    497a:	59 07       	cpc	r21, r25
    497c:	b8 f0       	brcs	.+46     	; 0x49ac <malloc+0x5a>
    497e:	48 17       	cp	r20, r24
    4980:	59 07       	cpc	r21, r25
    4982:	71 f4       	brne	.+28     	; 0x49a0 <malloc+0x4e>
    4984:	82 81       	ldd	r24, Z+2	; 0x02
    4986:	93 81       	ldd	r25, Z+3	; 0x03
    4988:	10 97       	sbiw	r26, 0x00	; 0
    498a:	29 f0       	breq	.+10     	; 0x4996 <malloc+0x44>
    498c:	13 96       	adiw	r26, 0x03	; 3
    498e:	9c 93       	st	X, r25
    4990:	8e 93       	st	-X, r24
    4992:	12 97       	sbiw	r26, 0x02	; 2
    4994:	2c c0       	rjmp	.+88     	; 0x49ee <malloc+0x9c>
    4996:	90 93 48 12 	sts	0x1248, r25
    499a:	80 93 47 12 	sts	0x1247, r24
    499e:	27 c0       	rjmp	.+78     	; 0x49ee <malloc+0x9c>
    49a0:	21 15       	cp	r18, r1
    49a2:	31 05       	cpc	r19, r1
    49a4:	31 f0       	breq	.+12     	; 0x49b2 <malloc+0x60>
    49a6:	42 17       	cp	r20, r18
    49a8:	53 07       	cpc	r21, r19
    49aa:	18 f0       	brcs	.+6      	; 0x49b2 <malloc+0x60>
    49ac:	a9 01       	movw	r20, r18
    49ae:	db 01       	movw	r26, r22
    49b0:	01 c0       	rjmp	.+2      	; 0x49b4 <malloc+0x62>
    49b2:	ef 01       	movw	r28, r30
    49b4:	9a 01       	movw	r18, r20
    49b6:	bd 01       	movw	r22, r26
    49b8:	df 01       	movw	r26, r30
    49ba:	02 80       	ldd	r0, Z+2	; 0x02
    49bc:	f3 81       	ldd	r31, Z+3	; 0x03
    49be:	e0 2d       	mov	r30, r0
    49c0:	d7 cf       	rjmp	.-82     	; 0x4970 <malloc+0x1e>
    49c2:	21 15       	cp	r18, r1
    49c4:	31 05       	cpc	r19, r1
    49c6:	f9 f0       	breq	.+62     	; 0x4a06 <malloc+0xb4>
    49c8:	28 1b       	sub	r18, r24
    49ca:	39 0b       	sbc	r19, r25
    49cc:	24 30       	cpi	r18, 0x04	; 4
    49ce:	31 05       	cpc	r19, r1
    49d0:	80 f4       	brcc	.+32     	; 0x49f2 <malloc+0xa0>
    49d2:	8a 81       	ldd	r24, Y+2	; 0x02
    49d4:	9b 81       	ldd	r25, Y+3	; 0x03
    49d6:	61 15       	cp	r22, r1
    49d8:	71 05       	cpc	r23, r1
    49da:	21 f0       	breq	.+8      	; 0x49e4 <malloc+0x92>
    49dc:	fb 01       	movw	r30, r22
    49de:	93 83       	std	Z+3, r25	; 0x03
    49e0:	82 83       	std	Z+2, r24	; 0x02
    49e2:	04 c0       	rjmp	.+8      	; 0x49ec <malloc+0x9a>
    49e4:	90 93 48 12 	sts	0x1248, r25
    49e8:	80 93 47 12 	sts	0x1247, r24
    49ec:	fe 01       	movw	r30, r28
    49ee:	32 96       	adiw	r30, 0x02	; 2
    49f0:	44 c0       	rjmp	.+136    	; 0x4a7a <malloc+0x128>
    49f2:	fe 01       	movw	r30, r28
    49f4:	e2 0f       	add	r30, r18
    49f6:	f3 1f       	adc	r31, r19
    49f8:	81 93       	st	Z+, r24
    49fa:	91 93       	st	Z+, r25
    49fc:	22 50       	subi	r18, 0x02	; 2
    49fe:	31 09       	sbc	r19, r1
    4a00:	39 83       	std	Y+1, r19	; 0x01
    4a02:	28 83       	st	Y, r18
    4a04:	3a c0       	rjmp	.+116    	; 0x4a7a <malloc+0x128>
    4a06:	20 91 45 12 	lds	r18, 0x1245
    4a0a:	30 91 46 12 	lds	r19, 0x1246
    4a0e:	23 2b       	or	r18, r19
    4a10:	41 f4       	brne	.+16     	; 0x4a22 <malloc+0xd0>
    4a12:	20 91 9e 01 	lds	r18, 0x019E
    4a16:	30 91 9f 01 	lds	r19, 0x019F
    4a1a:	30 93 46 12 	sts	0x1246, r19
    4a1e:	20 93 45 12 	sts	0x1245, r18
    4a22:	20 91 9c 01 	lds	r18, 0x019C
    4a26:	30 91 9d 01 	lds	r19, 0x019D
    4a2a:	21 15       	cp	r18, r1
    4a2c:	31 05       	cpc	r19, r1
    4a2e:	41 f4       	brne	.+16     	; 0x4a40 <malloc+0xee>
    4a30:	2d b7       	in	r18, 0x3d	; 61
    4a32:	3e b7       	in	r19, 0x3e	; 62
    4a34:	40 91 a0 01 	lds	r20, 0x01A0
    4a38:	50 91 a1 01 	lds	r21, 0x01A1
    4a3c:	24 1b       	sub	r18, r20
    4a3e:	35 0b       	sbc	r19, r21
    4a40:	e0 91 45 12 	lds	r30, 0x1245
    4a44:	f0 91 46 12 	lds	r31, 0x1246
    4a48:	e2 17       	cp	r30, r18
    4a4a:	f3 07       	cpc	r31, r19
    4a4c:	a0 f4       	brcc	.+40     	; 0x4a76 <malloc+0x124>
    4a4e:	2e 1b       	sub	r18, r30
    4a50:	3f 0b       	sbc	r19, r31
    4a52:	28 17       	cp	r18, r24
    4a54:	39 07       	cpc	r19, r25
    4a56:	78 f0       	brcs	.+30     	; 0x4a76 <malloc+0x124>
    4a58:	ac 01       	movw	r20, r24
    4a5a:	4e 5f       	subi	r20, 0xFE	; 254
    4a5c:	5f 4f       	sbci	r21, 0xFF	; 255
    4a5e:	24 17       	cp	r18, r20
    4a60:	35 07       	cpc	r19, r21
    4a62:	48 f0       	brcs	.+18     	; 0x4a76 <malloc+0x124>
    4a64:	4e 0f       	add	r20, r30
    4a66:	5f 1f       	adc	r21, r31
    4a68:	50 93 46 12 	sts	0x1246, r21
    4a6c:	40 93 45 12 	sts	0x1245, r20
    4a70:	81 93       	st	Z+, r24
    4a72:	91 93       	st	Z+, r25
    4a74:	02 c0       	rjmp	.+4      	; 0x4a7a <malloc+0x128>
    4a76:	e0 e0       	ldi	r30, 0x00	; 0
    4a78:	f0 e0       	ldi	r31, 0x00	; 0
    4a7a:	cf 01       	movw	r24, r30
    4a7c:	df 91       	pop	r29
    4a7e:	cf 91       	pop	r28
    4a80:	08 95       	ret

00004a82 <free>:
    4a82:	cf 93       	push	r28
    4a84:	df 93       	push	r29
    4a86:	00 97       	sbiw	r24, 0x00	; 0
    4a88:	09 f4       	brne	.+2      	; 0x4a8c <free+0xa>
    4a8a:	87 c0       	rjmp	.+270    	; 0x4b9a <free+0x118>
    4a8c:	fc 01       	movw	r30, r24
    4a8e:	32 97       	sbiw	r30, 0x02	; 2
    4a90:	13 82       	std	Z+3, r1	; 0x03
    4a92:	12 82       	std	Z+2, r1	; 0x02
    4a94:	c0 91 47 12 	lds	r28, 0x1247
    4a98:	d0 91 48 12 	lds	r29, 0x1248
    4a9c:	20 97       	sbiw	r28, 0x00	; 0
    4a9e:	81 f4       	brne	.+32     	; 0x4ac0 <free+0x3e>
    4aa0:	20 81       	ld	r18, Z
    4aa2:	31 81       	ldd	r19, Z+1	; 0x01
    4aa4:	28 0f       	add	r18, r24
    4aa6:	39 1f       	adc	r19, r25
    4aa8:	80 91 45 12 	lds	r24, 0x1245
    4aac:	90 91 46 12 	lds	r25, 0x1246
    4ab0:	82 17       	cp	r24, r18
    4ab2:	93 07       	cpc	r25, r19
    4ab4:	79 f5       	brne	.+94     	; 0x4b14 <free+0x92>
    4ab6:	f0 93 46 12 	sts	0x1246, r31
    4aba:	e0 93 45 12 	sts	0x1245, r30
    4abe:	6d c0       	rjmp	.+218    	; 0x4b9a <free+0x118>
    4ac0:	de 01       	movw	r26, r28
    4ac2:	20 e0       	ldi	r18, 0x00	; 0
    4ac4:	30 e0       	ldi	r19, 0x00	; 0
    4ac6:	ae 17       	cp	r26, r30
    4ac8:	bf 07       	cpc	r27, r31
    4aca:	50 f4       	brcc	.+20     	; 0x4ae0 <free+0x5e>
    4acc:	12 96       	adiw	r26, 0x02	; 2
    4ace:	4d 91       	ld	r20, X+
    4ad0:	5c 91       	ld	r21, X
    4ad2:	13 97       	sbiw	r26, 0x03	; 3
    4ad4:	9d 01       	movw	r18, r26
    4ad6:	41 15       	cp	r20, r1
    4ad8:	51 05       	cpc	r21, r1
    4ada:	09 f1       	breq	.+66     	; 0x4b1e <free+0x9c>
    4adc:	da 01       	movw	r26, r20
    4ade:	f3 cf       	rjmp	.-26     	; 0x4ac6 <free+0x44>
    4ae0:	b3 83       	std	Z+3, r27	; 0x03
    4ae2:	a2 83       	std	Z+2, r26	; 0x02
    4ae4:	40 81       	ld	r20, Z
    4ae6:	51 81       	ldd	r21, Z+1	; 0x01
    4ae8:	84 0f       	add	r24, r20
    4aea:	95 1f       	adc	r25, r21
    4aec:	8a 17       	cp	r24, r26
    4aee:	9b 07       	cpc	r25, r27
    4af0:	71 f4       	brne	.+28     	; 0x4b0e <free+0x8c>
    4af2:	8d 91       	ld	r24, X+
    4af4:	9c 91       	ld	r25, X
    4af6:	11 97       	sbiw	r26, 0x01	; 1
    4af8:	84 0f       	add	r24, r20
    4afa:	95 1f       	adc	r25, r21
    4afc:	02 96       	adiw	r24, 0x02	; 2
    4afe:	91 83       	std	Z+1, r25	; 0x01
    4b00:	80 83       	st	Z, r24
    4b02:	12 96       	adiw	r26, 0x02	; 2
    4b04:	8d 91       	ld	r24, X+
    4b06:	9c 91       	ld	r25, X
    4b08:	13 97       	sbiw	r26, 0x03	; 3
    4b0a:	93 83       	std	Z+3, r25	; 0x03
    4b0c:	82 83       	std	Z+2, r24	; 0x02
    4b0e:	21 15       	cp	r18, r1
    4b10:	31 05       	cpc	r19, r1
    4b12:	29 f4       	brne	.+10     	; 0x4b1e <free+0x9c>
    4b14:	f0 93 48 12 	sts	0x1248, r31
    4b18:	e0 93 47 12 	sts	0x1247, r30
    4b1c:	3e c0       	rjmp	.+124    	; 0x4b9a <free+0x118>
    4b1e:	d9 01       	movw	r26, r18
    4b20:	13 96       	adiw	r26, 0x03	; 3
    4b22:	fc 93       	st	X, r31
    4b24:	ee 93       	st	-X, r30
    4b26:	12 97       	sbiw	r26, 0x02	; 2
    4b28:	4d 91       	ld	r20, X+
    4b2a:	5d 91       	ld	r21, X+
    4b2c:	a4 0f       	add	r26, r20
    4b2e:	b5 1f       	adc	r27, r21
    4b30:	ea 17       	cp	r30, r26
    4b32:	fb 07       	cpc	r31, r27
    4b34:	79 f4       	brne	.+30     	; 0x4b54 <free+0xd2>
    4b36:	80 81       	ld	r24, Z
    4b38:	91 81       	ldd	r25, Z+1	; 0x01
    4b3a:	84 0f       	add	r24, r20
    4b3c:	95 1f       	adc	r25, r21
    4b3e:	02 96       	adiw	r24, 0x02	; 2
    4b40:	d9 01       	movw	r26, r18
    4b42:	11 96       	adiw	r26, 0x01	; 1
    4b44:	9c 93       	st	X, r25
    4b46:	8e 93       	st	-X, r24
    4b48:	82 81       	ldd	r24, Z+2	; 0x02
    4b4a:	93 81       	ldd	r25, Z+3	; 0x03
    4b4c:	13 96       	adiw	r26, 0x03	; 3
    4b4e:	9c 93       	st	X, r25
    4b50:	8e 93       	st	-X, r24
    4b52:	12 97       	sbiw	r26, 0x02	; 2
    4b54:	e0 e0       	ldi	r30, 0x00	; 0
    4b56:	f0 e0       	ldi	r31, 0x00	; 0
    4b58:	8a 81       	ldd	r24, Y+2	; 0x02
    4b5a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b5c:	00 97       	sbiw	r24, 0x00	; 0
    4b5e:	19 f0       	breq	.+6      	; 0x4b66 <free+0xe4>
    4b60:	fe 01       	movw	r30, r28
    4b62:	ec 01       	movw	r28, r24
    4b64:	f9 cf       	rjmp	.-14     	; 0x4b58 <free+0xd6>
    4b66:	ce 01       	movw	r24, r28
    4b68:	02 96       	adiw	r24, 0x02	; 2
    4b6a:	28 81       	ld	r18, Y
    4b6c:	39 81       	ldd	r19, Y+1	; 0x01
    4b6e:	82 0f       	add	r24, r18
    4b70:	93 1f       	adc	r25, r19
    4b72:	20 91 45 12 	lds	r18, 0x1245
    4b76:	30 91 46 12 	lds	r19, 0x1246
    4b7a:	28 17       	cp	r18, r24
    4b7c:	39 07       	cpc	r19, r25
    4b7e:	69 f4       	brne	.+26     	; 0x4b9a <free+0x118>
    4b80:	30 97       	sbiw	r30, 0x00	; 0
    4b82:	29 f4       	brne	.+10     	; 0x4b8e <free+0x10c>
    4b84:	10 92 48 12 	sts	0x1248, r1
    4b88:	10 92 47 12 	sts	0x1247, r1
    4b8c:	02 c0       	rjmp	.+4      	; 0x4b92 <free+0x110>
    4b8e:	13 82       	std	Z+3, r1	; 0x03
    4b90:	12 82       	std	Z+2, r1	; 0x02
    4b92:	d0 93 46 12 	sts	0x1246, r29
    4b96:	c0 93 45 12 	sts	0x1245, r28
    4b9a:	df 91       	pop	r29
    4b9c:	cf 91       	pop	r28
    4b9e:	08 95       	ret

00004ba0 <do_rand>:
    4ba0:	8f 92       	push	r8
    4ba2:	9f 92       	push	r9
    4ba4:	af 92       	push	r10
    4ba6:	bf 92       	push	r11
    4ba8:	cf 92       	push	r12
    4baa:	df 92       	push	r13
    4bac:	ef 92       	push	r14
    4bae:	ff 92       	push	r15
    4bb0:	cf 93       	push	r28
    4bb2:	df 93       	push	r29
    4bb4:	ec 01       	movw	r28, r24
    4bb6:	68 81       	ld	r22, Y
    4bb8:	79 81       	ldd	r23, Y+1	; 0x01
    4bba:	8a 81       	ldd	r24, Y+2	; 0x02
    4bbc:	9b 81       	ldd	r25, Y+3	; 0x03
    4bbe:	61 15       	cp	r22, r1
    4bc0:	71 05       	cpc	r23, r1
    4bc2:	81 05       	cpc	r24, r1
    4bc4:	91 05       	cpc	r25, r1
    4bc6:	21 f4       	brne	.+8      	; 0x4bd0 <do_rand+0x30>
    4bc8:	64 e2       	ldi	r22, 0x24	; 36
    4bca:	79 ed       	ldi	r23, 0xD9	; 217
    4bcc:	8b e5       	ldi	r24, 0x5B	; 91
    4bce:	97 e0       	ldi	r25, 0x07	; 7
    4bd0:	2d e1       	ldi	r18, 0x1D	; 29
    4bd2:	33 ef       	ldi	r19, 0xF3	; 243
    4bd4:	41 e0       	ldi	r20, 0x01	; 1
    4bd6:	50 e0       	ldi	r21, 0x00	; 0
    4bd8:	97 d2       	rcall	.+1326   	; 0x5108 <__divmodsi4>
    4bda:	49 01       	movw	r8, r18
    4bdc:	5a 01       	movw	r10, r20
    4bde:	9b 01       	movw	r18, r22
    4be0:	ac 01       	movw	r20, r24
    4be2:	a7 ea       	ldi	r26, 0xA7	; 167
    4be4:	b1 e4       	ldi	r27, 0x41	; 65
    4be6:	4f d2       	rcall	.+1182   	; 0x5086 <__muluhisi3>
    4be8:	6b 01       	movw	r12, r22
    4bea:	7c 01       	movw	r14, r24
    4bec:	ac ee       	ldi	r26, 0xEC	; 236
    4bee:	b4 ef       	ldi	r27, 0xF4	; 244
    4bf0:	a5 01       	movw	r20, r10
    4bf2:	94 01       	movw	r18, r8
    4bf4:	54 d2       	rcall	.+1192   	; 0x509e <__mulohisi3>
    4bf6:	c6 0e       	add	r12, r22
    4bf8:	d7 1e       	adc	r13, r23
    4bfa:	e8 1e       	adc	r14, r24
    4bfc:	f9 1e       	adc	r15, r25
    4bfe:	f7 fe       	sbrs	r15, 7
    4c00:	06 c0       	rjmp	.+12     	; 0x4c0e <do_rand+0x6e>
    4c02:	81 e0       	ldi	r24, 0x01	; 1
    4c04:	c8 1a       	sub	r12, r24
    4c06:	d1 08       	sbc	r13, r1
    4c08:	e1 08       	sbc	r14, r1
    4c0a:	80 e8       	ldi	r24, 0x80	; 128
    4c0c:	f8 0a       	sbc	r15, r24
    4c0e:	c8 82       	st	Y, r12
    4c10:	d9 82       	std	Y+1, r13	; 0x01
    4c12:	ea 82       	std	Y+2, r14	; 0x02
    4c14:	fb 82       	std	Y+3, r15	; 0x03
    4c16:	c6 01       	movw	r24, r12
    4c18:	9f 77       	andi	r25, 0x7F	; 127
    4c1a:	df 91       	pop	r29
    4c1c:	cf 91       	pop	r28
    4c1e:	ff 90       	pop	r15
    4c20:	ef 90       	pop	r14
    4c22:	df 90       	pop	r13
    4c24:	cf 90       	pop	r12
    4c26:	bf 90       	pop	r11
    4c28:	af 90       	pop	r10
    4c2a:	9f 90       	pop	r9
    4c2c:	8f 90       	pop	r8
    4c2e:	08 95       	ret

00004c30 <rand_r>:
    4c30:	b7 cf       	rjmp	.-146    	; 0x4ba0 <do_rand>

00004c32 <rand>:
    4c32:	82 ea       	ldi	r24, 0xA2	; 162
    4c34:	91 e0       	ldi	r25, 0x01	; 1
    4c36:	b4 cf       	rjmp	.-152    	; 0x4ba0 <do_rand>

00004c38 <srand>:
    4c38:	a0 e0       	ldi	r26, 0x00	; 0
    4c3a:	b0 e0       	ldi	r27, 0x00	; 0
    4c3c:	80 93 a2 01 	sts	0x01A2, r24
    4c40:	90 93 a3 01 	sts	0x01A3, r25
    4c44:	a0 93 a4 01 	sts	0x01A4, r26
    4c48:	b0 93 a5 01 	sts	0x01A5, r27
    4c4c:	08 95       	ret

00004c4e <strtol>:
    4c4e:	2f 92       	push	r2
    4c50:	3f 92       	push	r3
    4c52:	5f 92       	push	r5
    4c54:	6f 92       	push	r6
    4c56:	7f 92       	push	r7
    4c58:	8f 92       	push	r8
    4c5a:	9f 92       	push	r9
    4c5c:	af 92       	push	r10
    4c5e:	bf 92       	push	r11
    4c60:	cf 92       	push	r12
    4c62:	df 92       	push	r13
    4c64:	ef 92       	push	r14
    4c66:	ff 92       	push	r15
    4c68:	0f 93       	push	r16
    4c6a:	1f 93       	push	r17
    4c6c:	cf 93       	push	r28
    4c6e:	df 93       	push	r29
    4c70:	8b 01       	movw	r16, r22
    4c72:	ea 01       	movw	r28, r20
    4c74:	61 15       	cp	r22, r1
    4c76:	71 05       	cpc	r23, r1
    4c78:	21 f0       	breq	.+8      	; 0x4c82 <strtol+0x34>
    4c7a:	db 01       	movw	r26, r22
    4c7c:	8c 93       	st	X, r24
    4c7e:	11 96       	adiw	r26, 0x01	; 1
    4c80:	9c 93       	st	X, r25
    4c82:	20 97       	sbiw	r28, 0x00	; 0
    4c84:	39 f0       	breq	.+14     	; 0x4c94 <strtol+0x46>
    4c86:	9e 01       	movw	r18, r28
    4c88:	22 50       	subi	r18, 0x02	; 2
    4c8a:	31 09       	sbc	r19, r1
    4c8c:	23 32       	cpi	r18, 0x23	; 35
    4c8e:	31 05       	cpc	r19, r1
    4c90:	08 f0       	brcs	.+2      	; 0x4c94 <strtol+0x46>
    4c92:	f8 c0       	rjmp	.+496    	; 0x4e84 <strtol+0x236>
    4c94:	7c 01       	movw	r14, r24
    4c96:	67 01       	movw	r12, r14
    4c98:	bf ef       	ldi	r27, 0xFF	; 255
    4c9a:	cb 1a       	sub	r12, r27
    4c9c:	db 0a       	sbc	r13, r27
    4c9e:	56 01       	movw	r10, r12
    4ca0:	f7 01       	movw	r30, r14
    4ca2:	60 80       	ld	r6, Z
    4ca4:	86 2d       	mov	r24, r6
    4ca6:	90 e0       	ldi	r25, 0x00	; 0
    4ca8:	20 d1       	rcall	.+576    	; 0x4eea <isspace>
    4caa:	89 2b       	or	r24, r25
    4cac:	11 f0       	breq	.+4      	; 0x4cb2 <strtol+0x64>
    4cae:	76 01       	movw	r14, r12
    4cb0:	f2 cf       	rjmp	.-28     	; 0x4c96 <strtol+0x48>
    4cb2:	fd e2       	ldi	r31, 0x2D	; 45
    4cb4:	6f 12       	cpse	r6, r31
    4cb6:	0a c0       	rjmp	.+20     	; 0x4ccc <strtol+0x7e>
    4cb8:	57 01       	movw	r10, r14
    4cba:	82 e0       	ldi	r24, 0x02	; 2
    4cbc:	a8 0e       	add	r10, r24
    4cbe:	b1 1c       	adc	r11, r1
    4cc0:	d7 01       	movw	r26, r14
    4cc2:	11 96       	adiw	r26, 0x01	; 1
    4cc4:	6c 90       	ld	r6, X
    4cc6:	77 24       	eor	r7, r7
    4cc8:	73 94       	inc	r7
    4cca:	0b c0       	rjmp	.+22     	; 0x4ce2 <strtol+0x94>
    4ccc:	bb e2       	ldi	r27, 0x2B	; 43
    4cce:	6b 12       	cpse	r6, r27
    4cd0:	07 c0       	rjmp	.+14     	; 0x4ce0 <strtol+0x92>
    4cd2:	57 01       	movw	r10, r14
    4cd4:	e2 e0       	ldi	r30, 0x02	; 2
    4cd6:	ae 0e       	add	r10, r30
    4cd8:	b1 1c       	adc	r11, r1
    4cda:	d7 01       	movw	r26, r14
    4cdc:	11 96       	adiw	r26, 0x01	; 1
    4cde:	6c 90       	ld	r6, X
    4ce0:	71 2c       	mov	r7, r1
    4ce2:	ce 01       	movw	r24, r28
    4ce4:	8f 7e       	andi	r24, 0xEF	; 239
    4ce6:	89 2b       	or	r24, r25
    4ce8:	89 f4       	brne	.+34     	; 0x4d0c <strtol+0xbe>
    4cea:	b0 e3       	ldi	r27, 0x30	; 48
    4cec:	6b 12       	cpse	r6, r27
    4cee:	22 c0       	rjmp	.+68     	; 0x4d34 <strtol+0xe6>
    4cf0:	f5 01       	movw	r30, r10
    4cf2:	80 81       	ld	r24, Z
    4cf4:	8f 7d       	andi	r24, 0xDF	; 223
    4cf6:	88 35       	cpi	r24, 0x58	; 88
    4cf8:	41 f5       	brne	.+80     	; 0x4d4a <strtol+0xfc>
    4cfa:	61 80       	ldd	r6, Z+1	; 0x01
    4cfc:	f2 e0       	ldi	r31, 0x02	; 2
    4cfe:	af 0e       	add	r10, r31
    4d00:	b1 1c       	adc	r11, r1
    4d02:	87 2d       	mov	r24, r7
    4d04:	82 60       	ori	r24, 0x02	; 2
    4d06:	78 2e       	mov	r7, r24
    4d08:	c0 e1       	ldi	r28, 0x10	; 16
    4d0a:	d0 e0       	ldi	r29, 0x00	; 0
    4d0c:	c8 30       	cpi	r28, 0x08	; 8
    4d0e:	d1 05       	cpc	r29, r1
    4d10:	f1 f0       	breq	.+60     	; 0x4d4e <strtol+0x100>
    4d12:	4c f4       	brge	.+18     	; 0x4d26 <strtol+0xd8>
    4d14:	c2 30       	cpi	r28, 0x02	; 2
    4d16:	d1 05       	cpc	r29, r1
    4d18:	11 f5       	brne	.+68     	; 0x4d5e <strtol+0x110>
    4d1a:	c1 2c       	mov	r12, r1
    4d1c:	d1 2c       	mov	r13, r1
    4d1e:	e1 2c       	mov	r14, r1
    4d20:	b0 e4       	ldi	r27, 0x40	; 64
    4d22:	fb 2e       	mov	r15, r27
    4d24:	2e c0       	rjmp	.+92     	; 0x4d82 <strtol+0x134>
    4d26:	ca 30       	cpi	r28, 0x0A	; 10
    4d28:	d1 05       	cpc	r29, r1
    4d2a:	31 f0       	breq	.+12     	; 0x4d38 <strtol+0xea>
    4d2c:	c0 31       	cpi	r28, 0x10	; 16
    4d2e:	d1 05       	cpc	r29, r1
    4d30:	19 f1       	breq	.+70     	; 0x4d78 <strtol+0x12a>
    4d32:	15 c0       	rjmp	.+42     	; 0x4d5e <strtol+0x110>
    4d34:	20 97       	sbiw	r28, 0x00	; 0
    4d36:	51 f7       	brne	.-44     	; 0x4d0c <strtol+0xbe>
    4d38:	ca e0       	ldi	r28, 0x0A	; 10
    4d3a:	d0 e0       	ldi	r29, 0x00	; 0
    4d3c:	ac ec       	ldi	r26, 0xCC	; 204
    4d3e:	ca 2e       	mov	r12, r26
    4d40:	dc 2c       	mov	r13, r12
    4d42:	ec 2c       	mov	r14, r12
    4d44:	ac e0       	ldi	r26, 0x0C	; 12
    4d46:	fa 2e       	mov	r15, r26
    4d48:	1c c0       	rjmp	.+56     	; 0x4d82 <strtol+0x134>
    4d4a:	20 97       	sbiw	r28, 0x00	; 0
    4d4c:	f9 f6       	brne	.-66     	; 0x4d0c <strtol+0xbe>
    4d4e:	c8 e0       	ldi	r28, 0x08	; 8
    4d50:	d0 e0       	ldi	r29, 0x00	; 0
    4d52:	c1 2c       	mov	r12, r1
    4d54:	d1 2c       	mov	r13, r1
    4d56:	e1 2c       	mov	r14, r1
    4d58:	f0 e1       	ldi	r31, 0x10	; 16
    4d5a:	ff 2e       	mov	r15, r31
    4d5c:	12 c0       	rjmp	.+36     	; 0x4d82 <strtol+0x134>
    4d5e:	60 e0       	ldi	r22, 0x00	; 0
    4d60:	70 e0       	ldi	r23, 0x00	; 0
    4d62:	80 e0       	ldi	r24, 0x00	; 0
    4d64:	90 e8       	ldi	r25, 0x80	; 128
    4d66:	9e 01       	movw	r18, r28
    4d68:	44 27       	eor	r20, r20
    4d6a:	37 fd       	sbrc	r19, 7
    4d6c:	40 95       	com	r20
    4d6e:	54 2f       	mov	r21, r20
    4d70:	a9 d1       	rcall	.+850    	; 0x50c4 <__udivmodsi4>
    4d72:	69 01       	movw	r12, r18
    4d74:	7a 01       	movw	r14, r20
    4d76:	05 c0       	rjmp	.+10     	; 0x4d82 <strtol+0x134>
    4d78:	c1 2c       	mov	r12, r1
    4d7a:	d1 2c       	mov	r13, r1
    4d7c:	e1 2c       	mov	r14, r1
    4d7e:	e8 e0       	ldi	r30, 0x08	; 8
    4d80:	fe 2e       	mov	r15, r30
    4d82:	f5 01       	movw	r30, r10
    4d84:	60 e0       	ldi	r22, 0x00	; 0
    4d86:	20 e0       	ldi	r18, 0x00	; 0
    4d88:	30 e0       	ldi	r19, 0x00	; 0
    4d8a:	a9 01       	movw	r20, r18
    4d8c:	4e 01       	movw	r8, r28
    4d8e:	aa 24       	eor	r10, r10
    4d90:	97 fc       	sbrc	r9, 7
    4d92:	a0 94       	com	r10
    4d94:	ba 2c       	mov	r11, r10
    4d96:	1f 01       	movw	r2, r30
    4d98:	70 ed       	ldi	r23, 0xD0	; 208
    4d9a:	57 2e       	mov	r5, r23
    4d9c:	56 0c       	add	r5, r6
    4d9e:	a9 e0       	ldi	r26, 0x09	; 9
    4da0:	a5 15       	cp	r26, r5
    4da2:	70 f4       	brcc	.+28     	; 0x4dc0 <strtol+0x172>
    4da4:	8f eb       	ldi	r24, 0xBF	; 191
    4da6:	86 0d       	add	r24, r6
    4da8:	8a 31       	cpi	r24, 0x1A	; 26
    4daa:	18 f4       	brcc	.+6      	; 0x4db2 <strtol+0x164>
    4dac:	99 ec       	ldi	r25, 0xC9	; 201
    4dae:	59 2e       	mov	r5, r25
    4db0:	06 c0       	rjmp	.+12     	; 0x4dbe <strtol+0x170>
    4db2:	8f e9       	ldi	r24, 0x9F	; 159
    4db4:	86 0d       	add	r24, r6
    4db6:	8a 31       	cpi	r24, 0x1A	; 26
    4db8:	28 f5       	brcc	.+74     	; 0x4e04 <strtol+0x1b6>
    4dba:	89 ea       	ldi	r24, 0xA9	; 169
    4dbc:	58 2e       	mov	r5, r24
    4dbe:	56 0c       	add	r5, r6
    4dc0:	85 2d       	mov	r24, r5
    4dc2:	90 e0       	ldi	r25, 0x00	; 0
    4dc4:	8c 17       	cp	r24, r28
    4dc6:	9d 07       	cpc	r25, r29
    4dc8:	ec f4       	brge	.+58     	; 0x4e04 <strtol+0x1b6>
    4dca:	67 fd       	sbrc	r22, 7
    4dcc:	17 c0       	rjmp	.+46     	; 0x4dfc <strtol+0x1ae>
    4dce:	c2 16       	cp	r12, r18
    4dd0:	d3 06       	cpc	r13, r19
    4dd2:	e4 06       	cpc	r14, r20
    4dd4:	f5 06       	cpc	r15, r21
    4dd6:	78 f0       	brcs	.+30     	; 0x4df6 <strtol+0x1a8>
    4dd8:	c5 01       	movw	r24, r10
    4dda:	b4 01       	movw	r22, r8
    4ddc:	64 d1       	rcall	.+712    	; 0x50a6 <__mulsi3>
    4dde:	9b 01       	movw	r18, r22
    4de0:	ac 01       	movw	r20, r24
    4de2:	25 0d       	add	r18, r5
    4de4:	31 1d       	adc	r19, r1
    4de6:	41 1d       	adc	r20, r1
    4de8:	51 1d       	adc	r21, r1
    4dea:	21 30       	cpi	r18, 0x01	; 1
    4dec:	31 05       	cpc	r19, r1
    4dee:	41 05       	cpc	r20, r1
    4df0:	b0 e8       	ldi	r27, 0x80	; 128
    4df2:	5b 07       	cpc	r21, r27
    4df4:	10 f0       	brcs	.+4      	; 0x4dfa <strtol+0x1ac>
    4df6:	6f ef       	ldi	r22, 0xFF	; 255
    4df8:	01 c0       	rjmp	.+2      	; 0x4dfc <strtol+0x1ae>
    4dfa:	61 e0       	ldi	r22, 0x01	; 1
    4dfc:	31 96       	adiw	r30, 0x01	; 1
    4dfe:	d1 01       	movw	r26, r2
    4e00:	6c 90       	ld	r6, X
    4e02:	c9 cf       	rjmp	.-110    	; 0x4d96 <strtol+0x148>
    4e04:	87 2d       	mov	r24, r7
    4e06:	81 70       	andi	r24, 0x01	; 1
    4e08:	01 15       	cp	r16, r1
    4e0a:	11 05       	cpc	r17, r1
    4e0c:	71 f0       	breq	.+28     	; 0x4e2a <strtol+0x1dc>
    4e0e:	66 23       	and	r22, r22
    4e10:	29 f0       	breq	.+10     	; 0x4e1c <strtol+0x1ce>
    4e12:	31 97       	sbiw	r30, 0x01	; 1
    4e14:	d8 01       	movw	r26, r16
    4e16:	ed 93       	st	X+, r30
    4e18:	fc 93       	st	X, r31
    4e1a:	07 c0       	rjmp	.+14     	; 0x4e2a <strtol+0x1dc>
    4e1c:	71 fe       	sbrs	r7, 1
    4e1e:	19 c0       	rjmp	.+50     	; 0x4e52 <strtol+0x204>
    4e20:	32 97       	sbiw	r30, 0x02	; 2
    4e22:	d8 01       	movw	r26, r16
    4e24:	ed 93       	st	X+, r30
    4e26:	fc 93       	st	X, r31
    4e28:	14 c0       	rjmp	.+40     	; 0x4e52 <strtol+0x204>
    4e2a:	67 ff       	sbrs	r22, 7
    4e2c:	12 c0       	rjmp	.+36     	; 0x4e52 <strtol+0x204>
    4e2e:	88 23       	and	r24, r24
    4e30:	29 f0       	breq	.+10     	; 0x4e3c <strtol+0x1ee>
    4e32:	20 e0       	ldi	r18, 0x00	; 0
    4e34:	30 e0       	ldi	r19, 0x00	; 0
    4e36:	40 e0       	ldi	r20, 0x00	; 0
    4e38:	50 e8       	ldi	r21, 0x80	; 128
    4e3a:	04 c0       	rjmp	.+8      	; 0x4e44 <strtol+0x1f6>
    4e3c:	2f ef       	ldi	r18, 0xFF	; 255
    4e3e:	3f ef       	ldi	r19, 0xFF	; 255
    4e40:	4f ef       	ldi	r20, 0xFF	; 255
    4e42:	5f e7       	ldi	r21, 0x7F	; 127
    4e44:	82 e2       	ldi	r24, 0x22	; 34
    4e46:	90 e0       	ldi	r25, 0x00	; 0
    4e48:	90 93 4a 12 	sts	0x124A, r25
    4e4c:	80 93 49 12 	sts	0x1249, r24
    4e50:	16 c0       	rjmp	.+44     	; 0x4e7e <strtol+0x230>
    4e52:	88 23       	and	r24, r24
    4e54:	41 f0       	breq	.+16     	; 0x4e66 <strtol+0x218>
    4e56:	50 95       	com	r21
    4e58:	40 95       	com	r20
    4e5a:	30 95       	com	r19
    4e5c:	21 95       	neg	r18
    4e5e:	3f 4f       	sbci	r19, 0xFF	; 255
    4e60:	4f 4f       	sbci	r20, 0xFF	; 255
    4e62:	5f 4f       	sbci	r21, 0xFF	; 255
    4e64:	0c c0       	rjmp	.+24     	; 0x4e7e <strtol+0x230>
    4e66:	57 ff       	sbrs	r21, 7
    4e68:	0a c0       	rjmp	.+20     	; 0x4e7e <strtol+0x230>
    4e6a:	82 e2       	ldi	r24, 0x22	; 34
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	90 93 4a 12 	sts	0x124A, r25
    4e72:	80 93 49 12 	sts	0x1249, r24
    4e76:	2f ef       	ldi	r18, 0xFF	; 255
    4e78:	3f ef       	ldi	r19, 0xFF	; 255
    4e7a:	4f ef       	ldi	r20, 0xFF	; 255
    4e7c:	5f e7       	ldi	r21, 0x7F	; 127
    4e7e:	b9 01       	movw	r22, r18
    4e80:	ca 01       	movw	r24, r20
    4e82:	04 c0       	rjmp	.+8      	; 0x4e8c <strtol+0x23e>
    4e84:	60 e0       	ldi	r22, 0x00	; 0
    4e86:	70 e0       	ldi	r23, 0x00	; 0
    4e88:	80 e0       	ldi	r24, 0x00	; 0
    4e8a:	90 e0       	ldi	r25, 0x00	; 0
    4e8c:	df 91       	pop	r29
    4e8e:	cf 91       	pop	r28
    4e90:	1f 91       	pop	r17
    4e92:	0f 91       	pop	r16
    4e94:	ff 90       	pop	r15
    4e96:	ef 90       	pop	r14
    4e98:	df 90       	pop	r13
    4e9a:	cf 90       	pop	r12
    4e9c:	bf 90       	pop	r11
    4e9e:	af 90       	pop	r10
    4ea0:	9f 90       	pop	r9
    4ea2:	8f 90       	pop	r8
    4ea4:	7f 90       	pop	r7
    4ea6:	6f 90       	pop	r6
    4ea8:	5f 90       	pop	r5
    4eaa:	3f 90       	pop	r3
    4eac:	2f 90       	pop	r2
    4eae:	08 95       	ret

00004eb0 <atoi>:
    4eb0:	fc 01       	movw	r30, r24
    4eb2:	88 27       	eor	r24, r24
    4eb4:	99 27       	eor	r25, r25
    4eb6:	e8 94       	clt
    4eb8:	21 91       	ld	r18, Z+
    4eba:	20 32       	cpi	r18, 0x20	; 32
    4ebc:	e9 f3       	breq	.-6      	; 0x4eb8 <atoi+0x8>
    4ebe:	29 30       	cpi	r18, 0x09	; 9
    4ec0:	10 f0       	brcs	.+4      	; 0x4ec6 <atoi+0x16>
    4ec2:	2e 30       	cpi	r18, 0x0E	; 14
    4ec4:	c8 f3       	brcs	.-14     	; 0x4eb8 <atoi+0x8>
    4ec6:	2b 32       	cpi	r18, 0x2B	; 43
    4ec8:	39 f0       	breq	.+14     	; 0x4ed8 <atoi+0x28>
    4eca:	2d 32       	cpi	r18, 0x2D	; 45
    4ecc:	31 f4       	brne	.+12     	; 0x4eda <atoi+0x2a>
    4ece:	68 94       	set
    4ed0:	03 c0       	rjmp	.+6      	; 0x4ed8 <atoi+0x28>
    4ed2:	68 d0       	rcall	.+208    	; 0x4fa4 <__mulhi_const_10>
    4ed4:	82 0f       	add	r24, r18
    4ed6:	91 1d       	adc	r25, r1
    4ed8:	21 91       	ld	r18, Z+
    4eda:	20 53       	subi	r18, 0x30	; 48
    4edc:	2a 30       	cpi	r18, 0x0A	; 10
    4ede:	c8 f3       	brcs	.-14     	; 0x4ed2 <atoi+0x22>
    4ee0:	1e f4       	brtc	.+6      	; 0x4ee8 <atoi+0x38>
    4ee2:	90 95       	com	r25
    4ee4:	81 95       	neg	r24
    4ee6:	9f 4f       	sbci	r25, 0xFF	; 255
    4ee8:	08 95       	ret

00004eea <isspace>:
    4eea:	91 11       	cpse	r25, r1
    4eec:	b9 c0       	rjmp	.+370    	; 0x5060 <__ctype_isfalse>
    4eee:	80 32       	cpi	r24, 0x20	; 32
    4ef0:	19 f0       	breq	.+6      	; 0x4ef8 <isspace+0xe>
    4ef2:	89 50       	subi	r24, 0x09	; 9
    4ef4:	85 50       	subi	r24, 0x05	; 5
    4ef6:	d0 f7       	brcc	.-12     	; 0x4eec <isspace+0x2>
    4ef8:	08 95       	ret

00004efa <strcat_P>:
    4efa:	fb 01       	movw	r30, r22
    4efc:	dc 01       	movw	r26, r24
    4efe:	0d 90       	ld	r0, X+
    4f00:	00 20       	and	r0, r0
    4f02:	e9 f7       	brne	.-6      	; 0x4efe <strcat_P+0x4>
    4f04:	11 97       	sbiw	r26, 0x01	; 1
    4f06:	05 90       	lpm	r0, Z+
    4f08:	0d 92       	st	X+, r0
    4f0a:	00 20       	and	r0, r0
    4f0c:	e1 f7       	brne	.-8      	; 0x4f06 <strcat_P+0xc>
    4f0e:	08 95       	ret

00004f10 <strcpy_P>:
    4f10:	fb 01       	movw	r30, r22
    4f12:	dc 01       	movw	r26, r24
    4f14:	05 90       	lpm	r0, Z+
    4f16:	0d 92       	st	X+, r0
    4f18:	00 20       	and	r0, r0
    4f1a:	e1 f7       	brne	.-8      	; 0x4f14 <strcpy_P+0x4>
    4f1c:	08 95       	ret

00004f1e <strtok>:
    4f1e:	49 e2       	ldi	r20, 0x29	; 41
    4f20:	50 e1       	ldi	r21, 0x10	; 16
    4f22:	19 c0       	rjmp	.+50     	; 0x4f56 <strtok_r>

00004f24 <memcpy>:
    4f24:	fb 01       	movw	r30, r22
    4f26:	dc 01       	movw	r26, r24
    4f28:	02 c0       	rjmp	.+4      	; 0x4f2e <memcpy+0xa>
    4f2a:	01 90       	ld	r0, Z+
    4f2c:	0d 92       	st	X+, r0
    4f2e:	41 50       	subi	r20, 0x01	; 1
    4f30:	50 40       	sbci	r21, 0x00	; 0
    4f32:	d8 f7       	brcc	.-10     	; 0x4f2a <memcpy+0x6>
    4f34:	08 95       	ret

00004f36 <strcmp>:
    4f36:	fb 01       	movw	r30, r22
    4f38:	dc 01       	movw	r26, r24
    4f3a:	8d 91       	ld	r24, X+
    4f3c:	01 90       	ld	r0, Z+
    4f3e:	80 19       	sub	r24, r0
    4f40:	01 10       	cpse	r0, r1
    4f42:	d9 f3       	breq	.-10     	; 0x4f3a <strcmp+0x4>
    4f44:	99 0b       	sbc	r25, r25
    4f46:	08 95       	ret

00004f48 <strcpy>:
    4f48:	fb 01       	movw	r30, r22
    4f4a:	dc 01       	movw	r26, r24
    4f4c:	01 90       	ld	r0, Z+
    4f4e:	0d 92       	st	X+, r0
    4f50:	00 20       	and	r0, r0
    4f52:	e1 f7       	brne	.-8      	; 0x4f4c <strcpy+0x4>
    4f54:	08 95       	ret

00004f56 <strtok_r>:
    4f56:	fa 01       	movw	r30, r20
    4f58:	a1 91       	ld	r26, Z+
    4f5a:	b0 81       	ld	r27, Z
    4f5c:	00 97       	sbiw	r24, 0x00	; 0
    4f5e:	19 f4       	brne	.+6      	; 0x4f66 <strtok_r+0x10>
    4f60:	10 97       	sbiw	r26, 0x00	; 0
    4f62:	e1 f0       	breq	.+56     	; 0x4f9c <strtok_r+0x46>
    4f64:	cd 01       	movw	r24, r26
    4f66:	dc 01       	movw	r26, r24
    4f68:	cd 01       	movw	r24, r26
    4f6a:	0d 90       	ld	r0, X+
    4f6c:	00 20       	and	r0, r0
    4f6e:	11 f4       	brne	.+4      	; 0x4f74 <strtok_r+0x1e>
    4f70:	c0 01       	movw	r24, r0
    4f72:	13 c0       	rjmp	.+38     	; 0x4f9a <strtok_r+0x44>
    4f74:	fb 01       	movw	r30, r22
    4f76:	21 91       	ld	r18, Z+
    4f78:	22 23       	and	r18, r18
    4f7a:	19 f0       	breq	.+6      	; 0x4f82 <strtok_r+0x2c>
    4f7c:	20 15       	cp	r18, r0
    4f7e:	d9 f7       	brne	.-10     	; 0x4f76 <strtok_r+0x20>
    4f80:	f3 cf       	rjmp	.-26     	; 0x4f68 <strtok_r+0x12>
    4f82:	fb 01       	movw	r30, r22
    4f84:	21 91       	ld	r18, Z+
    4f86:	20 15       	cp	r18, r0
    4f88:	19 f4       	brne	.+6      	; 0x4f90 <strtok_r+0x3a>
    4f8a:	1e 92       	st	-X, r1
    4f8c:	11 96       	adiw	r26, 0x01	; 1
    4f8e:	06 c0       	rjmp	.+12     	; 0x4f9c <strtok_r+0x46>
    4f90:	22 23       	and	r18, r18
    4f92:	c1 f7       	brne	.-16     	; 0x4f84 <strtok_r+0x2e>
    4f94:	0d 90       	ld	r0, X+
    4f96:	00 20       	and	r0, r0
    4f98:	a1 f7       	brne	.-24     	; 0x4f82 <strtok_r+0x2c>
    4f9a:	d0 01       	movw	r26, r0
    4f9c:	fa 01       	movw	r30, r20
    4f9e:	a1 93       	st	Z+, r26
    4fa0:	b0 83       	st	Z, r27
    4fa2:	08 95       	ret

00004fa4 <__mulhi_const_10>:
    4fa4:	7a e0       	ldi	r23, 0x0A	; 10
    4fa6:	97 9f       	mul	r25, r23
    4fa8:	90 2d       	mov	r25, r0
    4faa:	87 9f       	mul	r24, r23
    4fac:	80 2d       	mov	r24, r0
    4fae:	91 0d       	add	r25, r1
    4fb0:	11 24       	eor	r1, r1
    4fb2:	08 95       	ret

00004fb4 <utoa>:
    4fb4:	fb 01       	movw	r30, r22
    4fb6:	9f 01       	movw	r18, r30
    4fb8:	42 30       	cpi	r20, 0x02	; 2
    4fba:	6c f0       	brlt	.+26     	; 0x4fd6 <utoa+0x22>
    4fbc:	45 32       	cpi	r20, 0x25	; 37
    4fbe:	5c f4       	brge	.+22     	; 0x4fd6 <utoa+0x22>
    4fc0:	64 2f       	mov	r22, r20
    4fc2:	77 27       	eor	r23, r23
    4fc4:	9f dc       	rcall	.-1730   	; 0x4904 <__udivmodhi4>
    4fc6:	80 5d       	subi	r24, 0xD0	; 208
    4fc8:	8a 33       	cpi	r24, 0x3A	; 58
    4fca:	0c f0       	brlt	.+2      	; 0x4fce <utoa+0x1a>
    4fcc:	89 5d       	subi	r24, 0xD9	; 217
    4fce:	81 93       	st	Z+, r24
    4fd0:	cb 01       	movw	r24, r22
    4fd2:	00 97       	sbiw	r24, 0x00	; 0
    4fd4:	a9 f7       	brne	.-22     	; 0x4fc0 <utoa+0xc>
    4fd6:	10 82       	st	Z, r1
    4fd8:	c9 01       	movw	r24, r18
    4fda:	45 c0       	rjmp	.+138    	; 0x5066 <strrev>

00004fdc <__eerd_block_m1284p>:
    4fdc:	dc 01       	movw	r26, r24
    4fde:	cb 01       	movw	r24, r22

00004fe0 <__eerd_blraw_m1284p>:
    4fe0:	fc 01       	movw	r30, r24
    4fe2:	f9 99       	sbic	0x1f, 1	; 31
    4fe4:	fe cf       	rjmp	.-4      	; 0x4fe2 <__eerd_blraw_m1284p+0x2>
    4fe6:	06 c0       	rjmp	.+12     	; 0x4ff4 <__eerd_blraw_m1284p+0x14>
    4fe8:	f2 bd       	out	0x22, r31	; 34
    4fea:	e1 bd       	out	0x21, r30	; 33
    4fec:	f8 9a       	sbi	0x1f, 0	; 31
    4fee:	31 96       	adiw	r30, 0x01	; 1
    4ff0:	00 b4       	in	r0, 0x20	; 32
    4ff2:	0d 92       	st	X+, r0
    4ff4:	41 50       	subi	r20, 0x01	; 1
    4ff6:	50 40       	sbci	r21, 0x00	; 0
    4ff8:	b8 f7       	brcc	.-18     	; 0x4fe8 <__eerd_blraw_m1284p+0x8>
    4ffa:	08 95       	ret

00004ffc <__eerd_byte_m1284p>:
    4ffc:	f9 99       	sbic	0x1f, 1	; 31
    4ffe:	fe cf       	rjmp	.-4      	; 0x4ffc <__eerd_byte_m1284p>
    5000:	92 bd       	out	0x22, r25	; 34
    5002:	81 bd       	out	0x21, r24	; 33
    5004:	f8 9a       	sbi	0x1f, 0	; 31
    5006:	99 27       	eor	r25, r25
    5008:	80 b5       	in	r24, 0x20	; 32
    500a:	08 95       	ret

0000500c <__eerd_word_m1284p>:
    500c:	a8 e1       	ldi	r26, 0x18	; 24
    500e:	b0 e0       	ldi	r27, 0x00	; 0
    5010:	42 e0       	ldi	r20, 0x02	; 2
    5012:	50 e0       	ldi	r21, 0x00	; 0
    5014:	e5 cf       	rjmp	.-54     	; 0x4fe0 <__eerd_blraw_m1284p>

00005016 <__eeupd_block_m1284p>:
    5016:	dc 01       	movw	r26, r24
    5018:	a4 0f       	add	r26, r20
    501a:	b5 1f       	adc	r27, r21
    501c:	41 50       	subi	r20, 0x01	; 1
    501e:	50 40       	sbci	r21, 0x00	; 0
    5020:	40 f0       	brcs	.+16     	; 0x5032 <__eeupd_block_m1284p+0x1c>
    5022:	cb 01       	movw	r24, r22
    5024:	84 0f       	add	r24, r20
    5026:	95 1f       	adc	r25, r21
    5028:	2e 91       	ld	r18, -X
    502a:	05 d0       	rcall	.+10     	; 0x5036 <__eeupd_r18_m1284p>
    502c:	41 50       	subi	r20, 0x01	; 1
    502e:	50 40       	sbci	r21, 0x00	; 0
    5030:	d8 f7       	brcc	.-10     	; 0x5028 <__eeupd_block_m1284p+0x12>
    5032:	08 95       	ret

00005034 <__eeupd_byte_m1284p>:
    5034:	26 2f       	mov	r18, r22

00005036 <__eeupd_r18_m1284p>:
    5036:	f9 99       	sbic	0x1f, 1	; 31
    5038:	fe cf       	rjmp	.-4      	; 0x5036 <__eeupd_r18_m1284p>
    503a:	92 bd       	out	0x22, r25	; 34
    503c:	81 bd       	out	0x21, r24	; 33
    503e:	f8 9a       	sbi	0x1f, 0	; 31
    5040:	01 97       	sbiw	r24, 0x01	; 1
    5042:	00 b4       	in	r0, 0x20	; 32
    5044:	02 16       	cp	r0, r18
    5046:	39 f0       	breq	.+14     	; 0x5056 <__eeupd_r18_m1284p+0x20>
    5048:	1f ba       	out	0x1f, r1	; 31
    504a:	20 bd       	out	0x20, r18	; 32
    504c:	0f b6       	in	r0, 0x3f	; 63
    504e:	f8 94       	cli
    5050:	fa 9a       	sbi	0x1f, 2	; 31
    5052:	f9 9a       	sbi	0x1f, 1	; 31
    5054:	0f be       	out	0x3f, r0	; 63
    5056:	08 95       	ret

00005058 <__eeupd_word_m1284p>:
    5058:	01 96       	adiw	r24, 0x01	; 1
    505a:	27 2f       	mov	r18, r23
    505c:	ec df       	rcall	.-40     	; 0x5036 <__eeupd_r18_m1284p>
    505e:	ea cf       	rjmp	.-44     	; 0x5034 <__eeupd_byte_m1284p>

00005060 <__ctype_isfalse>:
    5060:	99 27       	eor	r25, r25
    5062:	88 27       	eor	r24, r24

00005064 <__ctype_istrue>:
    5064:	08 95       	ret

00005066 <strrev>:
    5066:	dc 01       	movw	r26, r24
    5068:	fc 01       	movw	r30, r24
    506a:	67 2f       	mov	r22, r23
    506c:	71 91       	ld	r23, Z+
    506e:	77 23       	and	r23, r23
    5070:	e1 f7       	brne	.-8      	; 0x506a <strrev+0x4>
    5072:	32 97       	sbiw	r30, 0x02	; 2
    5074:	04 c0       	rjmp	.+8      	; 0x507e <strrev+0x18>
    5076:	7c 91       	ld	r23, X
    5078:	6d 93       	st	X+, r22
    507a:	70 83       	st	Z, r23
    507c:	62 91       	ld	r22, -Z
    507e:	ae 17       	cp	r26, r30
    5080:	bf 07       	cpc	r27, r31
    5082:	c8 f3       	brcs	.-14     	; 0x5076 <strrev+0x10>
    5084:	08 95       	ret

00005086 <__muluhisi3>:
    5086:	5c d0       	rcall	.+184    	; 0x5140 <__umulhisi3>
    5088:	a5 9f       	mul	r26, r21
    508a:	90 0d       	add	r25, r0
    508c:	b4 9f       	mul	r27, r20
    508e:	90 0d       	add	r25, r0
    5090:	a4 9f       	mul	r26, r20
    5092:	80 0d       	add	r24, r0
    5094:	91 1d       	adc	r25, r1
    5096:	11 24       	eor	r1, r1
    5098:	08 95       	ret

0000509a <__mulshisi3>:
    509a:	b7 ff       	sbrs	r27, 7
    509c:	f4 cf       	rjmp	.-24     	; 0x5086 <__muluhisi3>

0000509e <__mulohisi3>:
    509e:	f3 df       	rcall	.-26     	; 0x5086 <__muluhisi3>
    50a0:	82 1b       	sub	r24, r18
    50a2:	93 0b       	sbc	r25, r19
    50a4:	08 95       	ret

000050a6 <__mulsi3>:
    50a6:	db 01       	movw	r26, r22
    50a8:	8f 93       	push	r24
    50aa:	9f 93       	push	r25
    50ac:	ec df       	rcall	.-40     	; 0x5086 <__muluhisi3>
    50ae:	bf 91       	pop	r27
    50b0:	af 91       	pop	r26
    50b2:	a2 9f       	mul	r26, r18
    50b4:	80 0d       	add	r24, r0
    50b6:	91 1d       	adc	r25, r1
    50b8:	a3 9f       	mul	r26, r19
    50ba:	90 0d       	add	r25, r0
    50bc:	b2 9f       	mul	r27, r18
    50be:	90 0d       	add	r25, r0
    50c0:	11 24       	eor	r1, r1
    50c2:	08 95       	ret

000050c4 <__udivmodsi4>:
    50c4:	a1 e2       	ldi	r26, 0x21	; 33
    50c6:	1a 2e       	mov	r1, r26
    50c8:	aa 1b       	sub	r26, r26
    50ca:	bb 1b       	sub	r27, r27
    50cc:	fd 01       	movw	r30, r26
    50ce:	0d c0       	rjmp	.+26     	; 0x50ea <__udivmodsi4_ep>

000050d0 <__udivmodsi4_loop>:
    50d0:	aa 1f       	adc	r26, r26
    50d2:	bb 1f       	adc	r27, r27
    50d4:	ee 1f       	adc	r30, r30
    50d6:	ff 1f       	adc	r31, r31
    50d8:	a2 17       	cp	r26, r18
    50da:	b3 07       	cpc	r27, r19
    50dc:	e4 07       	cpc	r30, r20
    50de:	f5 07       	cpc	r31, r21
    50e0:	20 f0       	brcs	.+8      	; 0x50ea <__udivmodsi4_ep>
    50e2:	a2 1b       	sub	r26, r18
    50e4:	b3 0b       	sbc	r27, r19
    50e6:	e4 0b       	sbc	r30, r20
    50e8:	f5 0b       	sbc	r31, r21

000050ea <__udivmodsi4_ep>:
    50ea:	66 1f       	adc	r22, r22
    50ec:	77 1f       	adc	r23, r23
    50ee:	88 1f       	adc	r24, r24
    50f0:	99 1f       	adc	r25, r25
    50f2:	1a 94       	dec	r1
    50f4:	69 f7       	brne	.-38     	; 0x50d0 <__udivmodsi4_loop>
    50f6:	60 95       	com	r22
    50f8:	70 95       	com	r23
    50fa:	80 95       	com	r24
    50fc:	90 95       	com	r25
    50fe:	9b 01       	movw	r18, r22
    5100:	ac 01       	movw	r20, r24
    5102:	bd 01       	movw	r22, r26
    5104:	cf 01       	movw	r24, r30
    5106:	08 95       	ret

00005108 <__divmodsi4>:
    5108:	05 2e       	mov	r0, r21
    510a:	97 fb       	bst	r25, 7
    510c:	16 f4       	brtc	.+4      	; 0x5112 <__divmodsi4+0xa>
    510e:	00 94       	com	r0
    5110:	0f d0       	rcall	.+30     	; 0x5130 <__negsi2>
    5112:	57 fd       	sbrc	r21, 7
    5114:	05 d0       	rcall	.+10     	; 0x5120 <__divmodsi4_neg2>
    5116:	d6 df       	rcall	.-84     	; 0x50c4 <__udivmodsi4>
    5118:	07 fc       	sbrc	r0, 7
    511a:	02 d0       	rcall	.+4      	; 0x5120 <__divmodsi4_neg2>
    511c:	46 f4       	brtc	.+16     	; 0x512e <__divmodsi4_exit>
    511e:	08 c0       	rjmp	.+16     	; 0x5130 <__negsi2>

00005120 <__divmodsi4_neg2>:
    5120:	50 95       	com	r21
    5122:	40 95       	com	r20
    5124:	30 95       	com	r19
    5126:	21 95       	neg	r18
    5128:	3f 4f       	sbci	r19, 0xFF	; 255
    512a:	4f 4f       	sbci	r20, 0xFF	; 255
    512c:	5f 4f       	sbci	r21, 0xFF	; 255

0000512e <__divmodsi4_exit>:
    512e:	08 95       	ret

00005130 <__negsi2>:
    5130:	90 95       	com	r25
    5132:	80 95       	com	r24
    5134:	70 95       	com	r23
    5136:	61 95       	neg	r22
    5138:	7f 4f       	sbci	r23, 0xFF	; 255
    513a:	8f 4f       	sbci	r24, 0xFF	; 255
    513c:	9f 4f       	sbci	r25, 0xFF	; 255
    513e:	08 95       	ret

00005140 <__umulhisi3>:
    5140:	a2 9f       	mul	r26, r18
    5142:	b0 01       	movw	r22, r0
    5144:	b3 9f       	mul	r27, r19
    5146:	c0 01       	movw	r24, r0
    5148:	a3 9f       	mul	r26, r19
    514a:	70 0d       	add	r23, r0
    514c:	81 1d       	adc	r24, r1
    514e:	11 24       	eor	r1, r1
    5150:	91 1d       	adc	r25, r1
    5152:	b2 9f       	mul	r27, r18
    5154:	70 0d       	add	r23, r0
    5156:	81 1d       	adc	r24, r1
    5158:	11 24       	eor	r1, r1
    515a:	91 1d       	adc	r25, r1
    515c:	08 95       	ret

0000515e <_exit>:
    515e:	f8 94       	cli

00005160 <__stop_program>:
    5160:	ff cf       	rjmp	.-2      	; 0x5160 <__stop_program>
